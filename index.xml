<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>icecat471&#39;s Devlog</title>
    <link>https://icecat471.github.io/devlog/</link>
    <description>Recent content on icecat471&#39;s Devlog</description>
    <image>
      <url>https://icecat471.github.io/devlog/papermod-cover.png</url>
      <link>https://icecat471.github.io/devlog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 22:50:49 +0900</lastBuildDate><atom:link href="https://icecat471.github.io/devlog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gRPC란?</title>
      <link>https://icecat471.github.io/devlog/post/network/grpc/</link>
      <pubDate>Thu, 15 Apr 2021 22:50:49 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/network/grpc/</guid>
      <description>gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.
HTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.
HTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling</description>
    </item>
    
    <item>
      <title>Go언어 log.SetPrefix()</title>
      <link>https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/</link>
      <pubDate>Thu, 15 Apr 2021 15:04:43 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; ) func init() { log.SetPrefix(&amp;#34;Blockchain: &amp;#34;) } func main() { fmt.Println(&amp;#34;test&amp;#34;) log.Println(&amp;#34;test&amp;#34;) } 실행시켜보면
test Blockchain: 2021/04/15 15:04:03 test </description>
    </item>
    
    <item>
      <title>html 캔버스에 이미지 그리기</title>
      <link>https://icecat471.github.io/devlog/post/html/draw_image_on_canvas/</link>
      <pubDate>Wed, 14 Apr 2021 22:40:37 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/html/draw_image_on_canvas/</guid>
      <description>&amp;lt;canvas id=&amp;#34;myCanvas&amp;#34; width=&amp;#34;500&amp;#34; height=&amp;#34;800&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; let canvas = document.querySelector(&amp;#39;#myCanvas&amp;#39;); let context = canvas.getContext(&amp;#39;2d&amp;#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = &amp;#39;이미지 경로&amp;#39;; context.drawImage(dragon, x좌표, y좌표, width, height); 
setInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.
// 1초마다 새로 그림 setInterval(()=&amp;gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms </description>
    </item>
    
    <item>
      <title>Go언어 defer와 panic</title>
      <link>https://icecat471.github.io/devlog/post/golang/defer_and_panic/</link>
      <pubDate>Tue, 13 Apr 2021 22:13:26 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/defer_and_panic/</guid>
      <description>출처: 예제로 배우는 Go 프로그래밍
1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.
package main import &amp;#34;os&amp;#34; func main() { f, err := os.Open(&amp;#34;1.txt&amp;#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } 
2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.
이것은 콜스택을 따라 상위함수에도 모두 적용.</description>
    </item>
    
    <item>
      <title>Go언어 flag 패키지를 통한 command-line flag 파싱</title>
      <link>https://icecat471.github.io/devlog/post/golang/flag/</link>
      <pubDate>Mon, 12 Apr 2021 23:18:41 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/flag/</guid>
      <description>golang flag package
command-line flag를 파싱해주는 패키지.
// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(&amp;#34;max&amp;#34;, 10, &amp;#34;Defines maximum value&amp;#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(&amp;amp;minValue, &amp;#34;min&amp;#34;, 0, &amp;#34;Defines minimum value&amp;#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() 
Boolean flag는 0, 1, t, f, T, F, true, false, TRUE, FALSE, True, False 등으로 넘겨줄 수 있음.</description>
    </item>
    
    <item>
      <title>Go언어 프로젝트 외부의 모듈 import하기</title>
      <link>https://icecat471.github.io/devlog/post/golang/external_module/</link>
      <pubDate>Mon, 12 Apr 2021 22:14:23 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/external_module/</guid>
      <description>go.mod 파일에서
require ( &amp;lt;모듈명&amp;gt; v0.0.0 ) replace &amp;lt;모듈명&amp;gt; v0.0.0 =&amp;gt; ../module // 이런 형태로 경로를 지정해줌 </description>
    </item>
    
    <item>
      <title>브라우저에서 유니티 함수 호출하기</title>
      <link>https://icecat471.github.io/devlog/post/unity/call_unity_func_in_js/</link>
      <pubDate>Mon, 12 Apr 2021 12:36:10 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/unity/call_unity_func_in_js/</guid>
      <description>참고: Unity Document WebGL
build시 생성되는 unityInstance에 메세지를 보내서 호출.
unityInstace.SendMessage(&amp;#39;오브젝트명&amp;#39;, &amp;#39;함수명&amp;#39;); </description>
    </item>
    
    <item>
      <title>유니티 WebGL 자바스크립트 함수 호출</title>
      <link>https://icecat471.github.io/devlog/post/unity/call_javascript/</link>
      <pubDate>Mon, 12 Apr 2021 11:28:39 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/unity/call_javascript/</guid>
      <description>참고: Unity Document WebGL
Assets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다
// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(&amp;#34;Hello, world!&amp;#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i &amp;lt; size; i++) console.log(HEAPF32[(array &amp;gt;&amp;gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = &amp;#34;bla&amp;#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.</description>
    </item>
    
    <item>
      <title>터미널에서 command not found: dotnet 에러</title>
      <link>https://icecat471.github.io/devlog/post/unity/command_not_found_dotnet/</link>
      <pubDate>Mon, 12 Apr 2021 09:23:08 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/unity/command_not_found_dotnet/</guid>
      <description>아래처럼 나올 때
zsh: command not found: dotnet dotnet package를 설치했다면
/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인.
/usr/local/bin 경로에 링크를 만들어주면 된다.
ln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow</description>
    </item>
    
    <item>
      <title>유니티 webGL 프로젝트 로컬서버에서 실행하기</title>
      <link>https://icecat471.github.io/devlog/post/unity/local_server/</link>
      <pubDate>Sun, 11 Apr 2021 18:33:11 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/unity/local_server/</guid>
      <description>webGL &amp;ldquo;build and run&amp;rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림
로컬에서 서버를 열어서 실행해볼 수 있다.
http-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.</description>
    </item>
    
    <item>
      <title>Docker 컨테이너 메모리 및 CPU 제한하기</title>
      <link>https://icecat471.github.io/devlog/post/docker/docker_memory_limit/</link>
      <pubDate>Sun, 11 Apr 2021 16:35:36 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/docker/docker_memory_limit/</guid>
      <description>// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 &amp;lt;image name&amp;gt; // stat 확인 docker stats &amp;lt;container id&amp;gt; </description>
    </item>
    
    <item>
      <title>Hugo로 블로그 시작하기</title>
      <link>https://icecat471.github.io/devlog/post/hugo/start_hugo/</link>
      <pubDate>Sun, 11 Apr 2021 12:11:05 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/hugo/start_hugo/</guid>
      <description>출처: IALY&amp;rsquo;s BLOG
1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown 
2. Hugo Project 생성 hugo new site &amp;lt;프로젝트명&amp;gt; 
3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.
원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운
$ git clone &amp;lt;테마 깃허브 주소&amp;gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.</description>
    </item>
    
    
  </channel>
</rss>
