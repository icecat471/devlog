<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on icecat471&#39;s Devlog</title>
    <link>https://icecat471.github.io/devlog/tags/golang/</link>
    <description>Recent content in golang on icecat471&#39;s Devlog</description>
    <image>
      <url>https://icecat471.github.io/devlog/papermod-cover.png</url>
      <link>https://icecat471.github.io/devlog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 18 Apr 2021 11:53:14 +0900</lastBuildDate><atom:link href="https://icecat471.github.io/devlog/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[디자인패턴] Singleton 패턴</title>
      <link>https://icecat471.github.io/devlog/post/design_pattern/singleton/</link>
      <pubDate>Sun, 18 Apr 2021 11:53:14 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/design_pattern/singleton/</guid>
      <description>Singleton 패턴 하나의 클래스에 대해 하나의 인스턴스만 존재하는 패턴go에서는 sync.Once를 통해 구현 가능하다.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) type User struct { uid int name string level int } type userDatabase struct { users map[int]*User } var once sync.Once var instance *userDatabase func (d *userDatabase) GetUser(uid int) (*User, bool) { user, ok := d.users[uid] return user, ok } func GetUserDatabase() *userDatabase { // sync.Once.Do()는 딱 한번만 실행  once.</description>
    </item>
    
    <item>
      <title>[디자인패턴] Prototype 패턴</title>
      <link>https://icecat471.github.io/devlog/post/design_pattern/prototype_pattern/</link>
      <pubDate>Sat, 17 Apr 2021 21:18:19 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/design_pattern/prototype_pattern/</guid>
      <description>프로토타입 패턴 프로토타입 패턴(prototype pattern)은 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.얕은 복사(shallow copy) vs 깊은 복사(deep copy) 얕은 복사 객체를 복사할때 참조값을 가진 멤버는 참조값만 복사 됨.
type Status struct { str int dex int wis int } type Monster struct { Name string Status *Status } func main() { slime := Monster{ &amp;#34;slime&amp;#34;, &amp;amp;Status{1,1,1}, } goblin := slime goblin.Name = &amp;#34;goblin&amp;#34; goblin.</description>
    </item>
    
    <item>
      <title>[디자인패턴] Factory 패턴</title>
      <link>https://icecat471.github.io/devlog/post/design_pattern/factory/</link>
      <pubDate>Fri, 16 Apr 2021 17:50:07 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/design_pattern/factory/</guid>
      <description>Factory Pattern 1. factory method pattern 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.
package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; ) type Character interface { Attack() } const ( warrior = iota mage ) type Warrior struct { } func (w *Warrior) Attack() { fmt.Println(&amp;#34;sword attack&amp;#34;) } type Mage struct { } func (m *Mage) Attack() { fmt.Println(&amp;#34;magic attack&amp;#34;) }  Factory struct  type CharacterFactory struct { } func (f *CharacterFactory) Create(job int) (Character, error) { switch job { case warrior: return &amp;amp;Warrior{}, nil case mage: return &amp;amp;Mage{}, nil default: return nil, errors.</description>
    </item>
    
    <item>
      <title>[디자인패턴] Builder 패턴</title>
      <link>https://icecat471.github.io/devlog/post/design_pattern/bulilder/</link>
      <pubDate>Fri, 16 Apr 2021 12:08:15 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/design_pattern/bulilder/</guid>
      <description>1. Builder Pattern Person 객체를 예로 들어보자
type Person struct { name string age int job string height float32 weight float32 } func NewPerson(name string, age int, job string, height float32, weight float32) *Person { return &amp;amp;Person{ name, age, job, height, weight, } } func main() { p := NewPerson(&amp;#34;홍길동&amp;#34;, 22, &amp;#34;developer&amp;#34;, 177.2, 72.9) } 위처럼 모든 정보를 입력하지 않아도 될때도 있고, 가독성도 좋지않으며 parameter의 순서도 맞춰주어야한다.또 객체에 새로운 정보가 추가된다면 NewPerson()을 계속 수정해주어야 한다.</description>
    </item>
    
    <item>
      <title>[Go언어] VSCode에서 gopls 에러가 날때</title>
      <link>https://icecat471.github.io/devlog/post/golang/gopls_error/</link>
      <pubDate>Fri, 16 Apr 2021 10:12:06 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/gopls_error/</guid>
      <description>vscode에서 아래와 같은 에러 발생시
 gopls requires a module at the root of your workspace. You can work with multiple modules by opening each one as a workspace folder.
 settings.json 파일에 아래와 같이 추가하고 vscode를 재실행한다.
&amp;#34;gopls&amp;#34;: { &amp;#34;experimentalWorkspaceModule&amp;#34;: true, }, </description>
    </item>
    
    <item>
      <title>Go언어 log.SetPrefix()</title>
      <link>https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/</link>
      <pubDate>Thu, 15 Apr 2021 15:04:43 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; ) func init() { log.SetPrefix(&amp;#34;Blockchain: &amp;#34;) } func main() { fmt.Println(&amp;#34;test&amp;#34;) log.Println(&amp;#34;test&amp;#34;) } 실행시켜보면
test Blockchain: 2021/04/15 15:04:03 test </description>
    </item>
    
    <item>
      <title>Go언어 defer와 panic</title>
      <link>https://icecat471.github.io/devlog/post/golang/defer_and_panic/</link>
      <pubDate>Tue, 13 Apr 2021 22:13:26 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/defer_and_panic/</guid>
      <description>출처: 예제로 배우는 Go 프로그래밍
1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.
package main import &amp;#34;os&amp;#34; func main() { f, err := os.Open(&amp;#34;1.txt&amp;#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } 2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.이것은 콜스택을 따라 상위함수에도 모두 적용.</description>
    </item>
    
    <item>
      <title>Go언어 flag 패키지를 통한 command-line flag 파싱</title>
      <link>https://icecat471.github.io/devlog/post/golang/flag/</link>
      <pubDate>Mon, 12 Apr 2021 23:18:41 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/flag/</guid>
      <description>golang flag package
command-line flag를 파싱해주는 패키지.
// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(&amp;#34;max&amp;#34;, 10, &amp;#34;Defines maximum value&amp;#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(&amp;amp;minValue, &amp;#34;min&amp;#34;, 0, &amp;#34;Defines minimum value&amp;#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() </description>
    </item>
    
    <item>
      <title>Go언어 프로젝트 외부의 모듈 import하기</title>
      <link>https://icecat471.github.io/devlog/post/golang/external_module/</link>
      <pubDate>Mon, 12 Apr 2021 22:14:23 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/golang/external_module/</guid>
      <description>go.mod 파일에서
require ( &amp;lt;모듈명&amp;gt; v0.0.0 ) replace &amp;lt;모듈명&amp;gt; v0.0.0 =&amp;gt; ../module // 이런 형태로 경로를 지정해줌 </description>
    </item>
    
  </channel>
</rss>
