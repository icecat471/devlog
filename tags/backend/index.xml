<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>backend on icecat471&#39;s Devlog</title>
    <link>https://icecat471.github.io/devlog/tags/backend/</link>
    <description>Recent content in backend on icecat471&#39;s Devlog</description>
    <image>
      <url>https://icecat471.github.io/devlog/papermod-cover.png</url>
      <link>https://icecat471.github.io/devlog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 03 May 2021 01:45:13 +0900</lastBuildDate><atom:link href="https://icecat471.github.io/devlog/tags/backend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[NestJS] (공식문서 번역) Modules</title>
      <link>https://icecat471.github.io/devlog/post/nestjs/modules/</link>
      <pubDate>Mon, 03 May 2021 01:45:13 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/nestjs/modules/</guid>
      <description>NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/providers
Modules Modules module class는 @Module 데코레이터로 선언된다. @Module 데코레이터는 Nest가 애플리케이션 구조를 조직하기 위해 사용하는 메타데이터를 붙여준다.
각각의 애플리케이션은 적어도 root module이라고 불리는 하나의 module을 갖는다. root module은 Nest가 애플리케이션그래프(Nest가 module과 provider의 관계들과 의존성을 결정하는데 사용하는 내부 데이터 구조)를 빌드하기 위해 사용하는 시작점이다. 보통 매우 작은 규모의 애플리케이션은 root module 단 하나만 갖는 경우도 있지만, 이러한 경우는 일반적이지는 않다.</description>
    </item>
    
    <item>
      <title>[NestJS] (공식문서 번역) Providers</title>
      <link>https://icecat471.github.io/devlog/post/nestjs/providers/</link>
      <pubDate>Sun, 02 May 2021 15:36:48 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/nestjs/providers/</guid>
      <description>NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/providers
Providers Providers provider는 Nest에서 가장 근본적인 개념이다. 대부분의 기본 Nest class는 provider로 취급된다(예를 들어, service, repository, factory, helper 등등). provider는 의존성을 주입할 수 있다. 이것은 오브젝트간의 서로 다양한 관계들을 만들 수 있음을 뜻한다.
앞선 챕터에서, 우리는 CatsController를 만들었고, controller는 HTTP request를 핸들링하고 복잡한 일을 provider에게 맡긴다.
Services 간단한 CatsService를 만들어보자. 이 service는 데이터를 저장하고 불러오는 역할을 담당할 것이며, CatsController가 이를 시용할 것이다.</description>
    </item>
    
    <item>
      <title>[NestJS] (공식문서 번역) Controllers</title>
      <link>https://icecat471.github.io/devlog/post/nestjs/controllers/</link>
      <pubDate>Sat, 01 May 2021 20:48:45 +0900</pubDate>
      
      <guid>https://icecat471.github.io/devlog/post/nestjs/controllers/</guid>
      <description>NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/controllers
Controllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.
routing mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다.</description>
    </item>
    
  </channel>
</rss>
