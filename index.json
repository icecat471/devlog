[{"content":"gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.\nHTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.\nHTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling   \n      gRPC의 장점 1. 다양한 언어와 플랫폼 지원 ProtoBuf의 IDL을 활용한 서비스 정의 한개로 다양한 언어와 플랫폼에서 동작.\n공식지원하는 언어 및 플랫폼 목록\n2. HTTP/2 기반  양방향 스트리밍.\n 높은 메시지 압축률과 성능.\n  3. MSA(microservice architecture)에 적합  gRPC를 활용하면 비지니스 로직에 집중하여 빠른 서비스 개발이 가능. MSA의 다양한 기술 스택의 공존으로 인한 중복 발생의 단점 보완 및 수많은 서비스간의 API 호출로 인한 성능저하 개선. ProtoBuf에 의한 높은 메시지 압축률은 시스템 전체의 네트워크 트래픽을 획기적으로 줄여줌.  [출처]\n1. Microsoft Docs 2. 네이버 클라우드 플랫폼 기술 블로그\n","permalink":"https://icecat471.github.io/devlog/post/network/grpc/","summary":"gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.\nHTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.\nHTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling","title":"gRPC란?"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func init() { log.SetPrefix(\u0026#34;Blockchain: \u0026#34;) } func main() { fmt.Println(\u0026#34;test\u0026#34;) log.Println(\u0026#34;test\u0026#34;) } 실행시켜보면\ntest Blockchain: 2021/04/15 15:04:03 test ","permalink":"https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/","summary":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func init() { log.SetPrefix(\u0026#34;Blockchain: \u0026#34;) } func main() { fmt.Println(\u0026#34;test\u0026#34;) log.Println(\u0026#34;test\u0026#34;) } 실행시켜보면\ntest Blockchain: 2021/04/15 15:04:03 test ","title":"Go언어 log.SetPrefix()"},{"content":"\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;800\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; let canvas = document.querySelector(\u0026#39;#myCanvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = \u0026#39;이미지 경로\u0026#39;; context.drawImage(dragon, x좌표, y좌표, width, height); \nsetInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.\n// 1초마다 새로 그림 setInterval(()=\u0026gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms ","permalink":"https://icecat471.github.io/devlog/post/html/draw_image_on_canvas/","summary":"\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;800\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; let canvas = document.querySelector(\u0026#39;#myCanvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = \u0026#39;이미지 경로\u0026#39;; context.drawImage(dragon, x좌표, y좌표, width, height); \nsetInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.\n// 1초마다 새로 그림 setInterval(()=\u0026gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms ","title":"html 캔버스에 이미지 그리기"},{"content":"출처: 예제로 배우는 Go 프로그래밍\n1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.\npackage main import \u0026#34;os\u0026#34; func main() { f, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } \n2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.\n이것은 콜스택을 따라 상위함수에도 모두 적용.\n마지막에는 프로그램이 에러를 내고 종료된다.\npackage main import \u0026#34;os\u0026#34; func main() { // 잘못된 파일명을 넣음  openFile(\u0026#34;Invalid.txt\u0026#34;) // openFile() 안에서 panic이 실행되면  // 아래 println 문장은 실행 안됨  println(\u0026#34;Done\u0026#34;) } func openFile(fn string) { f, err := os.Open(fn) if err != nil { panic(err) } defer f.Close() } \n3. recover panic 상태를 다시 정상으로 돌리는 함수.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 잘못된 파일명을 넣음  openFile(\u0026#34;Invalid.txt\u0026#34;) // recover에 의해  // 이 문장 실행됨  println(\u0026#34;Done\u0026#34;) } func openFile(fn string) { // defer 함수. panic 호출시 실행됨  defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;OPEN ERROR\u0026#34;, r) } }() f, err := os.Open(fn) if err != nil { panic(err) } defer f.Close() } ","permalink":"https://icecat471.github.io/devlog/post/golang/defer_and_panic/","summary":"출처: 예제로 배우는 Go 프로그래밍\n1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.\npackage main import \u0026#34;os\u0026#34; func main() { f, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } \n2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.\n이것은 콜스택을 따라 상위함수에도 모두 적용.","title":"Go언어 defer와 panic"},{"content":"golang flag package\ncommand-line flag를 파싱해주는 패키지.\n// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(\u0026#34;max\u0026#34;, 10, \u0026#34;Defines maximum value\u0026#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(\u0026amp;minValue, \u0026#34;min\u0026#34;, 0, \u0026#34;Defines minimum value\u0026#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() \nBoolean flag는 0, 1, t, f, T, F, true, false, TRUE, FALSE, True, False 등으로 넘겨줄 수 있음. ","permalink":"https://icecat471.github.io/devlog/post/golang/flag/","summary":"golang flag package\ncommand-line flag를 파싱해주는 패키지.\n// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(\u0026#34;max\u0026#34;, 10, \u0026#34;Defines maximum value\u0026#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(\u0026amp;minValue, \u0026#34;min\u0026#34;, 0, \u0026#34;Defines minimum value\u0026#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() \nBoolean flag는 0, 1, t, f, T, F, true, false, TRUE, FALSE, True, False 등으로 넘겨줄 수 있음.","title":"Go언어 flag 패키지를 통한 command-line flag 파싱"},{"content":"go.mod 파일에서\nrequire ( \u0026lt;모듈명\u0026gt; v0.0.0 ) replace \u0026lt;모듈명\u0026gt; v0.0.0 =\u0026gt; ../module // 이런 형태로 경로를 지정해줌 ","permalink":"https://icecat471.github.io/devlog/post/golang/external_module/","summary":"go.mod 파일에서\nrequire ( \u0026lt;모듈명\u0026gt; v0.0.0 ) replace \u0026lt;모듈명\u0026gt; v0.0.0 =\u0026gt; ../module // 이런 형태로 경로를 지정해줌 ","title":"Go언어 프로젝트 외부의 모듈 import하기"},{"content":"참고: Unity Document WebGL\nbuild시 생성되는 unityInstance에 메세지를 보내서 호출.\nunityInstace.SendMessage(\u0026#39;오브젝트명\u0026#39;, \u0026#39;함수명\u0026#39;); ","permalink":"https://icecat471.github.io/devlog/post/unity/call_unity_func_in_js/","summary":"참고: Unity Document WebGL\nbuild시 생성되는 unityInstance에 메세지를 보내서 호출.\nunityInstace.SendMessage(\u0026#39;오브젝트명\u0026#39;, \u0026#39;함수명\u0026#39;); ","title":"브라우저에서 유니티 함수 호출하기"},{"content":"참고: Unity Document WebGL\nAssets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다\n// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(\u0026#34;Hello, world!\u0026#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i \u0026lt; size; i++) console.log(HEAPF32[(array \u0026gt;\u0026gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = \u0026#34;bla\u0026#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.bindTexture(GLctx.TEXTURE_2D, GL.textures[texture]); }, }); \n그 후 C#에서 JS함수 호출 가능. using UnityEngine; using System.Runtime.InteropServices; public class NewBehaviourScript : MonoBehaviour { [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void Hello(); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void HelloString(string str); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void PrintFloatArray(float[] array, int size); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern int AddNumbers(int x, int y); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern string StringReturnValueFunction(); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void BindWebGLTexture(int texture); void Start() { Hello(); HelloString(\u0026#34;This is a string.\u0026#34;); float[] myArray = new float[10]; PrintFloatArray(myArray, myArray.Length); int result = AddNumbers(5, 7); Debug.Log(result); Debug.Log(StringReturnValueFunction()); var texture = new Texture2D(0, 0, TextureFormat.ARGB32, false); BindWebGLTexture(texture.GetNativeTextureID()); } } \n웹브라우저상에서만 호출하고 싶을때는 조건을 걸어준다. if(Application.platform == RuntimePlatform.WebGLPlayer) { Hello(); } ","permalink":"https://icecat471.github.io/devlog/post/unity/call_javascript/","summary":"참고: Unity Document WebGL\nAssets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다\n// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(\u0026#34;Hello, world!\u0026#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i \u0026lt; size; i++) console.log(HEAPF32[(array \u0026gt;\u0026gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = \u0026#34;bla\u0026#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.","title":"유니티 WebGL 자바스크립트 함수 호출"},{"content":"아래처럼 나올 때\nzsh: command not found: dotnet dotnet package를 설치했다면\n/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인.\n/usr/local/bin 경로에 링크를 만들어주면 된다.\nln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow\n","permalink":"https://icecat471.github.io/devlog/post/unity/command_not_found_dotnet/","summary":"아래처럼 나올 때\nzsh: command not found: dotnet dotnet package를 설치했다면\n/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인.\n/usr/local/bin 경로에 링크를 만들어주면 된다.\nln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow","title":"터미널에서 command not found: dotnet 에러"},{"content":"webGL \u0026ldquo;build and run\u0026rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림\n로컬에서 서버를 열어서 실행해볼 수 있다.\nhttp-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.\n","permalink":"https://icecat471.github.io/devlog/post/unity/local_server/","summary":"webGL \u0026ldquo;build and run\u0026rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림\n로컬에서 서버를 열어서 실행해볼 수 있다.\nhttp-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.","title":"유니티 webGL 프로젝트 로컬서버에서 실행하기"},{"content":"// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 \u0026lt;image name\u0026gt; // stat 확인 docker stats \u0026lt;container id\u0026gt; ","permalink":"https://icecat471.github.io/devlog/post/docker/docker_memory_limit/","summary":"// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 \u0026lt;image name\u0026gt; // stat 확인 docker stats \u0026lt;container id\u0026gt; ","title":"Docker 컨테이너 메모리 및 CPU 제한하기"},{"content":"출처: IALY\u0026rsquo;s BLOG\n1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown \n2. Hugo Project 생성 hugo new site \u0026lt;프로젝트명\u0026gt; \n3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.\n원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운\n$ git clone \u0026lt;테마 깃허브 주소\u0026gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.)\nconfig 파일 예시는 각 테마 깃허브에서 확인 가능.\n# config.yml baseURL: \u0026#34;https://\u0026lt;userid.github.io\u0026gt;/\u0026lt;repo name\u0026gt;/\u0026#34; title: \u0026#34;블로그 타이틀\u0026#34; theme: \u0026#34;테마명\u0026#34; # /themes 폴더에 다운 받은 테마폴더명 \n4. 포스팅 하기 프로젝트 내에서\n$ hugo new \u0026lt;파일이름\u0026gt; ex) hugo new post/test.md 라고 입력하면\ncontent 폴더내부에 content/post/test.md 경로로 파일 생성.\n5. 로컬서버에서 블로그 확인 $ hugo server -D -D 옵션을 주면 draft: true인 글도 확인가능하다.\n기본적으로 http://localhost:1313/ 로 확인 가능. 6. build 및 push hugo project를 push할 repo와 빌드한 public 파일을 push할 repo를 따로 만든다.\n프로젝트 루트에서\n$ git init $ git remote add origin \u0026lt;첫번째 repo\u0026gt; // 두번째 repo를 첫번째 repo의 submodule로 지정 $ git submodule add -b master \u0026lt;두번째 repo\u0026gt; public // build $ hugo // push $ cd public $ git add . $ git commit -m \u0026#34;\u0026lt;커밋 메세지\u0026gt;\u0026#34; $ git push origin master $ cd .. $ git add . $ git commit -m \u0026#34;\u0026lt;커밋 메세지\u0026gt;\u0026#34; $ git push origin master ","permalink":"https://icecat471.github.io/devlog/post/hugo/start_hugo/","summary":"출처: IALY\u0026rsquo;s BLOG\n1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown \n2. Hugo Project 생성 hugo new site \u0026lt;프로젝트명\u0026gt; \n3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.\n원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운\n$ git clone \u0026lt;테마 깃허브 주소\u0026gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.","title":"Hugo로 블로그 시작하기"}]