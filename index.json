[{"content":"pull \u0026amp; run\n$ docker run -p 5432:5432 --name postgres \\  -e POSTGRES_PASSWORD=password \\  -d postgres 컨테이너 접속 및 사용자 생성\n# 접속 $ docker exec -it postgres /bin/bash # postgres 접속 $ psql - U postgres # 사용자 생성 $ CREATE USER username PASSWORD \u0026#39;password\u0026#39; SUPERUSER; CREATE ROLE $ CREATE DATABASE test OWNER username CREATE DATABASE ","permalink":"https://icecat471.github.io/devlog/post/docker/install_postgres/","summary":"pull \u0026amp; run\n$ docker run -p 5432:5432 --name postgres \\  -e POSTGRES_PASSWORD=password \\  -d postgres 컨테이너 접속 및 사용자 생성\n# 접속 $ docker exec -it postgres /bin/bash # postgres 접속 $ psql - U postgres # 사용자 생성 $ CREATE USER username PASSWORD \u0026#39;password\u0026#39; SUPERUSER; CREATE ROLE $ CREATE DATABASE test OWNER username CREATE DATABASE ","title":"[Docker] PostgresSQL 설치"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/controllers\nControllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.\nrouting mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다. 이 경우, @Controller(\u0026lsquo;customers\u0026rsquo;) 데코레이터를 사용하여 쉽게 그룹화 가능하다.\n// cats.controller.ts  import { Controller, Get } from \u0026#39;@nestjs/common\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Get() findAll(): string { return \u0026#39;This action returns all cats\u0026#39;; } } @Get() HTTP request method 데코레이터는 Nest에게 HTTP request의 특정 엔드포인트에 대한 핸들러를 만들도록 한다. 엔드포인트는 HTTP request method(위 예제에서는 GET), route path에 일치하는 경로로 라우팅 된다. route path란, controller에 선언된 prefix와 request decorator에 의해 특정된 path의 결합이다.\n예제에서 모든 route에 대한 prefix(cats)를 선언하였고, decorator에는 path 정보를 추가하지 않았으므로, Nest는 GET /cats에 대한 request를 해당 핸들러에 매핑할 것이다.\n만약, path prefix가 customers 이고, decorator가 @Get(\u0026lsquo;profile\u0026rsquo;)인 경우는 GET /customers/profile 경로로 매핑될 것이다.\n위의 예제에서, 해당 엔드포인트에서 GET request가 만들어지면, Nest는 request를 findAll() method에 라우팅 할 것이다. method명은 임의로 지어진 것이다. 우리는 route에 bind될 method를 선언해야하지만, Nest는 method의 이름은 신경쓰지 않는다.\n이 method는 200이라는 status code와 string을 response로 반환할 것이다. 이것에 대해 설명하려면, response를 다루기 위해 Nest에서 제공하는 2가지 옵션에 대해 알아야 한다.\n         Standard(recommended) request handler가 Javascript object 또는 array를 반환할 때 자동으로 JSON 형태로 직렬화 된다. 그러나, Javascript 원시타입(string, number, boolean 등)을 반환할 때에는 직렬화 없이 값을 반환한다. 이것은 response handling을 간단하게 만들어 준다.또한, response의 status code는 항상 기본값이 200이며, POST의 경우는 201을 사용한다. 이것은 @HttpCode() 데코레이터를 추가하여 간단하게 변경 가능하다.   Library-specific @Res() 데코레이터를 사용하여 library-specific response object(예를 들어, Express)를 사용할 수도 있다(예를 들어, findAll(@Res() response)). 이러한 접근법으로 native response handling method들을 사용 가능하다. 예를 들어, Express를 사용한다면 아래의 코드처럼 사용 가능하다.response.status(200).send()     Warningibrary-specific option을 사용하기 위해 @Res()와 @Next()를 모두 사용하면 Nest는 이를 감지하여 standard는 자동으로 disabled 된다. 두 접근법을 동시에 사용하기 위해서는 passthrough option을 true로 사용해야 한다. @Res({ passthrough: true })\n Request object Handler는 가끔 request 세부사항에 접근해야 하는 경우가 있다. Nest는 platform(default는 Express)에 종속된 request object를 제공한다. @Req() 데코레이터를 사용하여 request object를 injection하여 접근 가능하다.\n// cats.controller.ts  import { Controller, Get, Req } from \u0026#39;@nestjs/common\u0026#39;; import { Request } from \u0026#39;express\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Get() findAll(@Req() request: Request): string { return \u0026#39;This action returns all cats\u0026#39;; } }  위 예제처럼 request: Request 로 typing을 하기 위해서는 @types/express 패키지를 설치하면 된다.\n request object는 query string, parameter, HTTP header, body 등의 속성값을 가진 HTTP request이다. 대부분의 경우, 속성들을 수동으로 가져올 필요 없이 @Body(), @Query()와 같은 데코레이터를 사용하면 된다. 아래는 platform-specifit object의 데코레이터 목록이다.\n         @Request(), @Req() req   @Response(), @Res() res   @Next() next   @Session() req.session   @Param(key?: string) req.params / req.params[key]   @Body(key?: string) req.body / req.body[key]   @Query(key?: string) req.query / req.query[key]   @Headers(name?: string) req.headers / req.headers[name]   @Ip() req.ip   @HostParam() req.hosts    HTTP platform(Express와 Fastify) 기반의 typing을 위해 Nest는 @Res(), @Response() 데코레이터를 제공한다. 이 데코레이터는 native platform의 response 오브젝트를 노출한다. 이것을 사용할 때, 기반 라이브러리를 import 해주어야 한다(예를 들어, @types/express). @Res(), @Response() 데코레이터를 사용하면, Nest에게 핸들러에 대해 Library-specific mode로 설정하게 하고, response를 관리할 수 있게 된다. 이를 통해, res.json()이나 res.send() 같은 response object의 method를 사용할 수 있다.\nResources 앞서, cats resource(GET route)를 fetch하기 위한 엔드포인트를 정의했다. 일반적으로 새로운 레코드를 만드는 엔드포인트도 제공하고 싶을것이다. 이를 위해, POST 핸들러를 사용한다.\n// cats.controller.ts  import { Controller, Get, Post } from \u0026#39;@nestjs/common\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Post() create(): string { return \u0026#39;This action adds a new cat\u0026#39;; } @Get() findAll(): string { return \u0026#39;This action returns all cats\u0026#39;; } } Nest는 모든 standart HTTP method에 대한 데코레이터를 제공한다: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(). 또한 @All() 을 사용하면 모든 요청에 대한 엔드포인트를 정의한다.\nRoute wildcards wildcard로 별표(*)를 사용한 패턴도 제공한다.\n@Get(\u0026#39;ab*cd\u0026#39;) findAll() { return \u0026#39;This route uses a wildcard\u0026#39;; } 'ab*cd' route path는 abcd, ab_cd, abecd등과 match된다. ?, +, *, () 같은 문자도 정규식의 부분으로 route path에 사용가능하다. '-', '.'은 string기반 path에 의해 문자 그대로 번역된다.\nStatus code 앞서 이야기했듯이, response status code는 기본값이 200이다(POST request의 경우 201). 이것은 @HttpCode() 데코레이터를 통해 핸들러 수준에서 쉽게 변경 가능하다.\n@Post() @HttpCode(204) create() { return \u0026#39;This action adds a new cat\u0026#39;; } 종종 status code는 static하지 않고 여러가지 변수에 의존한다. 이런 경우, @Res() 데코레이터를 통해 library-specific response를 사용할 수 있다.\nHeaders custom response header를 특정하기 위해, @Header() 데코레이터 또는 library-specific response object에서 res.header()를 호출할 수 있다.\n@Post() @Header(\u0026#39;Cache-Control\u0026#39;, \u0026#39;none\u0026#39;) create() { return \u0026#39;This action adds a new cat\u0026#39;; } Redirection response를 특정 URL로 redirection하기 위해, @Redirect() 데코레이터 또는 library-specific response object를 통해 res.redirect()를 호출할 수 있다. @Redirect()는 url과 statusCode를 인자로 받으며 둘 모두 optional이다. statusCode의 기본값은 302 이다.\n@Get() @Redirect(\u0026#39;https://nestjs.com\u0026#39;, 301) 가끔, status code나 redirect URL을 동적으로 결정해야 할 때가 있다. route handler method로부터 object를 아래와 같은 형태로 반환하면 된다.\n{ \u0026#34;url\u0026#34;: string, \u0026#34;statusCode\u0026#34;: number } 반환된 값은 @Redirect() 데코레이터의 인자를 override 할 것이다.\n@Get(\u0026#39;docs\u0026#39;) @Redirect(\u0026#39;https://docs.nestjs.com\u0026#39;, 302) getDocs(@Query(\u0026#39;version\u0026#39;) version) { if (version \u0026amp;\u0026amp; version === \u0026#39;5\u0026#39;) { return { url: \u0026#39;https://docs.nestjs.com/v5/\u0026#39; }; } } Route parameters 정적 경로를 가진 route는 request의 일부로 dynamic data에 접근해야 할 경우에는 사용할 수 없다. parameter를 갖는 route를 정의하기 위해 route parameter token을 path에 추가하면 된다. 아래는 @Get() 데코레이터에 사용한 route parameter token에 대한 예제이다. 이렇게 선언된 route parameter는 @Param() 데코레이터를 통해 접근할 수 있다.\n@Get(\u0026#39;:id\u0026#39;) findOne(@Param() params): string { console.log(params.id); return `This action returns a #${params.id}cat`; } 위 예제에서 @Param()을 통해 id에 접근하려면 params.id로 접근할 수 있다. 또는 특정 parameter token을 데코레이터에서 접근 가능하다.\n@Get(\u0026#39;:id\u0026#39;) findOne(@Param(\u0026#39;id\u0026#39;) id: string): string { return `This action returns a #${id}cat`; } Sub-Domain Routing @Controller() 데코레이터는 host option을 받을 수 있다. HTTP host는 들어오는 request와 특정 값을 matching하기 위해 사용된다.\n@Controller({ host: \u0026#39;admin.example.com\u0026#39; }) export class AdminController { @Get() index(): string { return \u0026#39;Admin page\u0026#39;; } }  Fastify는 nested router에 대한 지원을 하지 않으므로, sub-domain routing을 사용할 떄에는, Express adpater를 사용해야 한다.(기본값으로 설정되어 있음)\n route path와 마찬가지로, host option의 host name의 token도 동적값으로 사용가능하다. 이 방식으로 선언된 host parameter는 @HostParam() 데코레이터를 통해 사용 할 수 있다.\n@Controller({ host: \u0026#39;:account.example.com\u0026#39; }) export class AccountController { @Get() getInfo(@HostParam(\u0026#39;account\u0026#39;) account: string) { return account; } } Scopes Nest에서는 들어오는 request를 통해 거의 모든것이 공유된다. database에 대한 connection pool, global state에서의 singleton service 등을 갖고 있다. Node.js는 request/response Multi-Threaded Stateless Model을 따르지 않고, 각각의 request에 대해 분리된 thread에서 진행된다. 따라서, singleton instance를 사용하는 것이 우리의 애플리케이션에 안전한 방식이다.\nAsynchronicity data extraction은 대부분 비동기로 일어난다. 따라서 Nest에서는 async fuction을 지원한다. 모든 비동기 함수는 Promise를 반환한다.\n// cats.controller.ts  @Get() async findAll(): Promise\u0026lt;any[]\u0026gt; { return []; } 또한, Nest route handler는 RxJS observable stream을 반환할 수 있다. Nest는 자동으로 아래의 source를 subscribe하여 마지막으로 방출된 값을 가져올 수 있다.(stream이 끝날 때)\n@Get() findAll(): Observable\u0026lt;any[]\u0026gt; { return of([]); } 두 방식 모두 유효하며, 원하는 방식대로 사용하면 된다.\nRequest payloads @Body() 데코레이터를 사용하여 POST route handler에서도 클라이언트로부터 parameter를 받아올 수 있다. 그러나 먼저 DTO(Data Transfer Object) 스키마를 정의해야 한다. DTO는 네트워크를 통해 데이터를 어떤 형식으로 주고받을지 정의하는 오브젝트이다. DTO는 TypeScript interface 또는 class로 정의할 수 있다. 하지만 class를 추천하는데, class는 JS ES6 standard한 문법이며, 따라서 컴파일된 JS에서도 real entity로 보존된다. 반면, TypeScript interface는 transpilation 도중 제거되기 때문에 Nest는 그것을 런타임에 호출할 수 없다. 이것은 Pipe와 같은 feature가 런타임에 변수의 메타타입에 접근하는 경우 중요하다.\n// create-cat.dto.ts  export class CreateCatDto { name: string; age: number; breed: string; } // cat.controller.ts  @Post() async create(@Body() createCatDto: CreateCatDto) { return \u0026#39;This action adds a new cat\u0026#39;; } Handling errors 따로 분리된 에러 핸들링 페이지에서 볼 수 있다.\nFull resource sample // cat.controller.ts  import { Controller, Get, Query, Post, Body, Put, Param, Delete } from \u0026#39;@nestjs/common\u0026#39;; import { CreateCatDto, UpdateCatDto, ListAllEntities } from \u0026#39;./dto\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Post() create(@Body() createCatDto: CreateCatDto) { return \u0026#39;This action adds a new cat\u0026#39;; } @Get() findAll(@Query() query: ListAllEntities) { return `This action returns all cats (limit: ${query.limit}items)`; } @Get(\u0026#39;:id\u0026#39;) findOne(@Param(\u0026#39;id\u0026#39;) id: string) { return `This action returns a #${id}cat`; } @Put(\u0026#39;:id\u0026#39;) update(@Param(\u0026#39;id\u0026#39;) id: string, @Body() updateCatDto: UpdateCatDto) { return `This action updates a #${id}cat`; } @Delete(\u0026#39;:id\u0026#39;) remove(@Param(\u0026#39;id\u0026#39;) id: string) { return `This action removes a #${id}cat`; } } Getting up and running 위처럼 풀소스코드가 정의되어 있어도, Nest는 CatsController가 존재하는지 알지 못하기 때문에, 해당 클래스의 인스턴스를 생성하지 못한다. Controller는 항상 module에 속해있어야 하며, @Module() 데코레이터를 통해 포함시킨다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats/cats.controller\u0026#39;; @Module({ controllers: [CatsController], }) export class AppModule {} module class에 @Module() 데코레이터를 통해 포함시키면, Nest는 해당 controller를 찾아 mount한다.\nLibrary-specific approach library-specific response object를 injection하기 위해 @Res() 또는 @Response() 데코레이터를 사용한다.\n// cat.controller.ts  import { Controller, Get, Post, Res, HttpStatus } from \u0026#39;@nestjs/common\u0026#39;; import { Response } from \u0026#39;express\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Post() create(@Res() res: Response) { res.status(HttpStatus.CREATED).send(); } @Get() findAll(@Res() res: Response) { res.status(HttpStatus.OK).json([]); } } 이 방식을 통해, response object를 더 유연한 방식으로 컨트롤 할 수 있다. 일반적으로 이러한 접근 방식은 덜 clear하며, disadvantage를 가져올 수 있으므로 조심해서 다루어야 한다. 가장 주요한 disadvantage는 코드가 platform 의존적(기반 플랫폼들은 response object에 대해 서로 다른 API를 갖고 있다.)이 되며 테스트하기가 힘들어진다는 것이다. 또한, 위의 예제와 같이, Nest standard로 제공하는 response 핸들링 기능들을 사용할 수 없다(예를 들어, @HttpCode() / @Header() 데코레이터 등). 이것을 해결하기 위해 passthrough 옵션을 사용할 수 있다.\n@Get() findAll(@Res({ passthrough: true }) res: Response) { res.status(HttpStatus.OK); return []; } ","permalink":"https://icecat471.github.io/devlog/post/nestjs/controllers/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/controllers\nControllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.\nrouting mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다.","title":"[NestJS] (공식문서 번역) Controllers"},{"content":"톰캣 홈페이지\nhttp://tomcat.apache.org/\n받은 파일의 압축을 푼다 (다운로드 폴더 기준, apache-tomcat-9.0.45)\n# 폴더를 /usr/local 경로로 이동 $ sudo mv ~/Downloads/apache-tomcat-9.0.45 /usr/local/ # 기존에 존재하는 /Library/Tomcat 경로를 지우고 이동한 폴더를 링크함  $ sudo rm -f /Library/Tomcat $ sudo ln -s /usr/local/apache-tomcat-9.0.45/ /Library/Tomcat # 소유자를 본인으로 변경 $ sudo chown -R \u0026lt;userName\u0026gt; /Library/Tomcat # 실행권한 추가 $ sudo chmod +x /Library/Tomcat/bin/*.sh # Tomcat 실행 $ /Library/Tomcat/bin/startup.sh # Tomcat 종료 $ /Library/Tomcat/bin/shutdown.sh 톰캣 실행 확인\nhttp://localhost:8080\n","permalink":"https://icecat471.github.io/devlog/post/spring/install_apache_tomcat/","summary":"톰캣 홈페이지\nhttp://tomcat.apache.org/\n받은 파일의 압축을 푼다 (다운로드 폴더 기준, apache-tomcat-9.0.45)\n# 폴더를 /usr/local 경로로 이동 $ sudo mv ~/Downloads/apache-tomcat-9.0.45 /usr/local/ # 기존에 존재하는 /Library/Tomcat 경로를 지우고 이동한 폴더를 링크함  $ sudo rm -f /Library/Tomcat $ sudo ln -s /usr/local/apache-tomcat-9.0.45/ /Library/Tomcat # 소유자를 본인으로 변경 $ sudo chown -R \u0026lt;userName\u0026gt; /Library/Tomcat # 실행권한 추가 $ sudo chmod +x /Library/Tomcat/bin/*.sh # Tomcat 실행 $ /Library/Tomcat/bin/startup.sh # Tomcat 종료 $ /Library/Tomcat/bin/shutdown.sh 톰캣 실행 확인","title":"맥북 Tomcat9 설치"},{"content":"docker로 mongoDB 설치 pull # 최신버전 받아오기 $ docker pull mongo run $ docker run -d \\ # background 실행 --name mongo_db \\ # container name -v /Users/docker/mongodb/data/db:/data/db \\ # volume 설정 -p 27017:27017 \\ # port 설정 mongo -auth 컨테이너 접속 $ docker exec -it mongo_db /bin/bash mongo db # mongo db 접속. 권한이 없는 상태라 바로 접속 됨. $ mongo # admin db 선택 \u0026gt; use admin # admin 계정 생성 \u0026gt; db.createUser({ user: \u0026#34;admin\u0026#34;, # admin name pwd: \u0026#34;password\u0026#34;, # admin password roles: [ {role: \u0026#34;userAdminAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;}, {role: \u0026#34;dbAdminAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;}, {role: \u0026#34;readWriteAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;} ] # admin role }) # admin 계정 접속 $ mongo -u \u0026#34;admin\u0026#34; -p --authenticationDatabase \u0026#34;admin\u0026#34; (password 입력) user 추가 # 유저 생성 \u0026gt; db.createUser({ user: \u0026#39;username\u0026#39;, pwd: \u0026#39;password\u0026#39;, roles: [{role: \u0026#39;readWrite\u0026#39;, db: \u0026#39;test\u0026#39;}, {role: \u0026#39;read\u0026#39;, db: \u0026#39;reporting\u0026#39;}] }) # 로그인 db.auth(\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;); ","permalink":"https://icecat471.github.io/devlog/post/docker/install_mongo_db/","summary":"docker로 mongoDB 설치 pull # 최신버전 받아오기 $ docker pull mongo run $ docker run -d \\ # background 실행 --name mongo_db \\ # container name -v /Users/docker/mongodb/data/db:/data/db \\ # volume 설정 -p 27017:27017 \\ # port 설정 mongo -auth 컨테이너 접속 $ docker exec -it mongo_db /bin/bash mongo db # mongo db 접속. 권한이 없는 상태라 바로 접속 됨. $ mongo # admin db 선택 \u0026gt; use admin # admin 계정 생성 \u0026gt; db.","title":"[Docker] 몽고db 컨테이너 설치"},{"content":"대략적인 구성 잡아보기\nfront vue.js + axios(api 서버 연동)\n(HTML 기본 canvas를 이용할지 유니티 WebGL을 이용할지 고민중..)\nback typescript(nest.js) - API server\ngolang(gorilla/websocket) - Web Socket Server\nmongoDB\nredis - session 관리 CI/CD Terraform(AWS) - IaC\nJenkins\nKubernetes + Docekr\n","permalink":"https://icecat471.github.io/devlog/post/project/project1_01/","summary":"대략적인 구성 잡아보기\nfront vue.js + axios(api 서버 연동)\n(HTML 기본 canvas를 이용할지 유니티 WebGL을 이용할지 고민중..)\nback typescript(nest.js) - API server\ngolang(gorilla/websocket) - Web Socket Server\nmongoDB\nredis - session 관리 CI/CD Terraform(AWS) - IaC\nJenkins\nKubernetes + Docekr","title":"[프로젝트1] 웹 캐치마인드 만들기 1"},{"content":"ECDSA (Elliptic Curve Digital Signature Algorithm) 타원곡선암호(ECC)를 전자서명에 접목시킨 암호 알고리즘.타원곡선의 정의 일반적으로 타원 곡선 방정식은 아래와 같다.\n y2+ b1xy + b2y = x3+ a1x2+ a2x + a3 그러나, 실수상의 타원 곡선은 아래와 같은 특별한 타원 곡선을 사용한다.\n y2= x3+ ax + b\n 타원곡선의 특징은 x축을 중심으로 대칭되며, 비 수직선에 대해 최대 3개 지점에서 곡선과 교차.\n타원곡선상의 연산 타원곡선상의 점 P와 Q의 덧셈연산은 P와 Q를 지나는 직선이 타원과 만나는 교점(-R)을 x축으로 대칭시킨 점 R에 대해\nP + Q = R로 정의한다.타원곡선 암호화 원리 및 키생성 타원곡선에은 임의의 정수 a, b에 대해 정의된 다음과 같은 방정식의 해 (X, Y)의 집합이다.\n Y2= X3+ aX + b (mod p)\n 점 p=(x, y)가 타원곡선상에 있다는 것은 위의 방정식을 만족시킨다는 의미이다.또한, 두 점 P, Q와 임의의 정수 x에 대해 다음과 같은 방정식을 정의할 수 있다.\n Q = xG\n 타원곡선 이산대수 문제는 위와 같은 상황에서 해 x를 구하는 것이다.이로부터 타원곡선 암호에서 사용하는 키 쌍은 다음과 같이 정의할 수 있다.\n G: 생성자. 임의의 시작포인트\nx: 개인키. p보다 적은 소수(prime)로, 난수 생성기로 생성.\nQ: 공개키. 개인키로부터 연산.\n 이 때, 공개키 Q는 Q = xG = G+G+G+\u0026hellip;+G(x번 덧셈) 한 값이다.\nQ = xG 수식에서 x와 G를 이용해 Q를 구하기는 쉽지만, G와 Q를 이용해 x를 구하기는 힘들다.\nG는 타원곡선상 임의의 점이며, xG는 G를 타원곡선상에서 x번 덧셈 연산한 것을 의미한다.\n2G=G+G 는 점 G에서 점 G에서의 접선이 타원곡선과 만나는 제 3의 점을 x축으로 대칭시킨 점이다.4G=2G+2G 는 2G의 점에서 마찬가지로 접선을 그어 타원곡선과 만나는 점을 x축으로 대칭시킨 점이다.G의 상수배 연산은 이를 반복적으로 수행하여 표현한다.\n블록체인에서의 타원곡선 암호(ECDSA) 블록체인 기반 기술에서는 키 쌍 생성시 타원곡선 알고리즘을 사용하며, 키 길이는 256비트 이상을 사용한다.비트코인의 경우 미국국립표준기술원(NIST)에서 개발한 secp256k1 표준에 정의된 타원곡선을 사용한다.secp256k1은 표준으로 제정된 elliptic curve를 만들기 위한 상수 집합이다.참고로 NIST에서는 secp256r1을 추천하고 있다.비트코인에서 secp256r1 대신 secp256k1을 사용한 이유는 여러가지 추측이 있지만, 속도 때문이라는 이유가 타당하다고 여겨진다.secp256k1이란 이름은, sec(Standard for Efficient Cryptography) + p(Paramter p over Fp) + 256(Field size p의 bit수) + k(Koblitz curve 변형) + 1(sequence number) 로 구성.r은 Random parameter를 의미한다.secp256k1의 경우, a와 b의 값이 a=0, b=7로 정해져 있어\n y2mod p = (x3+ 7) mod p\n 의 타원곡선 수식을 사용한다.\nReference   해시넷 - 타원곡선 디지털서명 알고리즘\n  아이리포 - ECC 알고리즘\n  APE코리아네트 블로그 - 비트코인에서 사용하는 타원곡선암호기술(ECC)\n  ","permalink":"https://icecat471.github.io/devlog/post/encryption/ecdsa/","summary":"ECDSA (Elliptic Curve Digital Signature Algorithm) 타원곡선암호(ECC)를 전자서명에 접목시킨 암호 알고리즘.타원곡선의 정의 일반적으로 타원 곡선 방정식은 아래와 같다.\n y2+ b1xy + b2y = x3+ a1x2+ a2x + a3 그러나, 실수상의 타원 곡선은 아래와 같은 특별한 타원 곡선을 사용한다.\n y2= x3+ ax + b\n 타원곡선의 특징은 x축을 중심으로 대칭되며, 비 수직선에 대해 최대 3개 지점에서 곡선과 교차.\n타원곡선상의 연산 타원곡선상의 점 P와 Q의 덧셈연산은 P와 Q를 지나는 직선이 타원과 만나는 교점(-R)을 x축으로 대칭시킨 점 R에 대해","title":"ECDSA 알고리즘"},{"content":"Decorator Pattern 출처: https://golangbyexample.com/decorator-pattern-golang/\n개요 개체를 변경하지 않고 기능을 추가할 수 있음.\n=\u0026gt; 이미 테스트가 끝난 코드를 수정하면 안됨 (Open-Closed Principle에 위배됨) 두가지 피자가 존재한다고 가정해보자.\n vegge mania pizza peppy tofu pizza  UML 다이어그램 코드 pizza.go\npackage main type pizza interface { getPrice() int } peppyPaneer.go\npackage main type peppyPaneer struct { } func (p *peppyPaneer) getPrice() int { return 20 } veggeMania.go\npackage main type veggeMania struct { } func (p *veggeMania) getPrice() int { return 15 } 토핑을 추가하기 위해 위쪽에 만들어진 구조체들은 더 이상 수정하면 안됨.\ncheeseTopping.go\npackage main type cheeseTopping struct { pizza pizza } func (c *cheeseTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 10 } tomatoTopping.go\npackage main type tomatoTopping struct { pizza pizza } func (c *tomatoTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 7 } main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { veggiePizza := \u0026amp;veggeMania{} //Add cheese topping  veggiePizzaWithCheese := \u0026amp;cheeseTopping{ pizza: veggiePizza, } //Add tomato topping  veggiePizzaWithCheeseAndTomato := \u0026amp;tomatoTopping{ pizza: veggiePizzaWithCheese, } fmt.Printf(\u0026#34;Price of veggieMania pizza with tomato and cheese topping is %d\\n\u0026#34;, veggiePizzaWithCheeseAndTomato.getPrice()) peppyPaneerPizza := \u0026amp;peppyPaneer{} //Add cheese topping  peppyPaneerPizzaWithCheese := \u0026amp;cheeseTopping{ pizza: peppyPaneerPizza, } fmt.Printf(\u0026#34;Price of peppyPaneer with tomato and cheese topping is %d\\n\u0026#34;, peppyPaneerPizzaWithCheese.getPrice()) } 실행 결과\nPrice of veggieMania pizza with tomato and cheese topping is 32 Price of peppyPaneer with tomato and cheese topping is 30 ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/decorator/","summary":"Decorator Pattern 출처: https://golangbyexample.com/decorator-pattern-golang/\n개요 개체를 변경하지 않고 기능을 추가할 수 있음.\n=\u0026gt; 이미 테스트가 끝난 코드를 수정하면 안됨 (Open-Closed Principle에 위배됨) 두가지 피자가 존재한다고 가정해보자.\n vegge mania pizza peppy tofu pizza  UML 다이어그램 코드 pizza.go\npackage main type pizza interface { getPrice() int } peppyPaneer.go\npackage main type peppyPaneer struct { } func (p *peppyPaneer) getPrice() int { return 20 } veggeMania.go\npackage main type veggeMania struct { } func (p *veggeMania) getPrice() int { return 15 } 토핑을 추가하기 위해 위쪽에 만들어진 구조체들은 더 이상 수정하면 안됨.","title":"[디자인패턴] Decorator 패턴"},{"content":"Composite Pattern 출처: https://golangbyexample.com/composite-design-pattern-golang/\n개요 \u0026lsquo;composite\u0026rsquo;라고 불리는 개체그룹이 단일개체와 유사한 방식으로 처리되기를 원할때 사용.\n트리구조로 객체들을 엮는다. UML 다이어그램 OS의 파일시스템에는 폴더와 파일 두가지 유형의 개체가 있는데, 폴더와 파일은 동일하게 취급받는 경우가 있다.\nMapping          Component interface component.go   Composite folder.go   Leaf file.go   client main.go    코드 component.go\npackage main type component interface { search(string) } folder.go\npackage main import \u0026#34;fmt\u0026#34; type folder struct { components []component name string } func (f *folder) search(keyword string) { fmt.Printf(\u0026#34;Serching recursively for keyword %s in folder %s\\n\u0026#34;, keyword, f.name) for _, composite := range f.components { composite.search(keyword) } } func (f *folder) add(c component) { f.components = append(f.components, c) } file.go\npackage main import \u0026#34;fmt\u0026#34; type file struct { name string } func (f *file) search(keyword string) { fmt.Printf(\u0026#34;Searching for keyword %s in file %s\\n\u0026#34;, keyword, f.name) } func (f *file) getName() string { return f.name } main.go\npackage main func main() { file1 := \u0026amp;file{name: \u0026#34;File1\u0026#34;} file2 := \u0026amp;file{name: \u0026#34;File2\u0026#34;} file3 := \u0026amp;file{name: \u0026#34;File3\u0026#34;} folder1 := \u0026amp;folder{ name: \u0026#34;Folder1\u0026#34;, } folder1.add(file1) folder2 := \u0026amp;folder{ name: \u0026#34;Folder2\u0026#34;, } folder2.add(file2) folder2.add(file3) folder2.add(folder1) folder2.search(\u0026#34;rose\u0026#34;) } 실행 결과\nSerching recursively for keyword rose in folder Folder2 Searching for keyword rose in file File2 Searching for keyword rose in file File3 Serching recursively for keyword rose in folder Folder1 Searching for keyword rose in file File1 ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/composite/","summary":"Composite Pattern 출처: https://golangbyexample.com/composite-design-pattern-golang/\n개요 \u0026lsquo;composite\u0026rsquo;라고 불리는 개체그룹이 단일개체와 유사한 방식으로 처리되기를 원할때 사용.\n트리구조로 객체들을 엮는다. UML 다이어그램 OS의 파일시스템에는 폴더와 파일 두가지 유형의 개체가 있는데, 폴더와 파일은 동일하게 취급받는 경우가 있다.\nMapping          Component interface component.go   Composite folder.go   Leaf file.go   client main.go    코드 component.go\npackage main type component interface { search(string) } folder.","title":"[디자인패턴] Composite 패턴"},{"content":"Bridge Pattern 출처: https://golangbyexample.com/bridge-design-pattern-in-go/\n개요 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.이 패턴은 큰 클래스를 두개의 개별 계층으로 나누는것을 제안한다.\n Abstraction: interface. Implementation에 대한 참조가 포함됨.\nAbstraction의 자식을 Refined Abstraction 이라고 부름. Implementation: interface.\nImplementation의 자식을 Concrete Implementation 이라고 부름.  UML 다이어그램 2가지 유형의 컴퓨터 Mac과 Windows가 있다고 가정. 2가지 유형의 프린터 epson과 hp가 있다고 가정. 2*2의 조합의 4개의 구조체를 만드는 대신 2개의 계층을 만든다.\n코드 computer.go\npackage main type computer interface { print() setPrinter(printer) } mac.go\npackage main import \u0026#34;fmt\u0026#34; type mac struct { printer printer } func (m *mac) print() { fmt.Println(\u0026#34;Print request for mac\u0026#34;) m.printer.printFile() } func (m *mac) setPrinter(p printer) { m.printer = p } windows.go\npackage main import \u0026#34;fmt\u0026#34; type windows struct { printer printer } func (w *windows) print() { fmt.Println(\u0026#34;Print request for windows\u0026#34;) w.printer.printFile() } func (w *windows) setPrinter(p printer) { w.printer = p } printer.go\npackage main type printer interface { printFile() } epson.go\npackage main import \u0026#34;fmt\u0026#34; type epson struct { } func (p *epson) printFile() { fmt.Println(\u0026#34;Printing by a EPSON Printer\u0026#34;) } hp.go\npackage main import \u0026#34;fmt\u0026#34; type hp struct { } func (p *hp) printFile() { fmt.Println(\u0026#34;Printing by a HP Printer\u0026#34;) } main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { hpPrinter := \u0026amp;hp{} epsonPrinter := \u0026amp;epson{} macComputer := \u0026amp;mac{} macComputer.setPrinter(hpPrinter) macComputer.print() fmt.Println() macComputer.setPrinter(epsonPrinter) macComputer.print() fmt.Println() winComputer := \u0026amp;windows{} winComputer.setPrinter(hpPrinter) winComputer.print() fmt.Println() winComputer.setPrinter(epsonPrinter) winComputer.print() fmt.Println() } 실행 결과\nPrint request for mac Printing by a HP Printer Print request for mac Printing by a EPSON Printer Print request for windows Printing by a HP Printer Print request for windows Printing by a EPSON Printer ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/bridge/","summary":"Bridge Pattern 출처: https://golangbyexample.com/bridge-design-pattern-in-go/\n개요 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.이 패턴은 큰 클래스를 두개의 개별 계층으로 나누는것을 제안한다.\n Abstraction: interface. Implementation에 대한 참조가 포함됨.\nAbstraction의 자식을 Refined Abstraction 이라고 부름. Implementation: interface.\nImplementation의 자식을 Concrete Implementation 이라고 부름.  UML 다이어그램 2가지 유형의 컴퓨터 Mac과 Windows가 있다고 가정. 2가지 유형의 프린터 epson과 hp가 있다고 가정. 2*2의 조합의 4개의 구조체를 만드는 대신 2개의 계층을 만든다.","title":"[디자인패턴] Bridge 패턴"},{"content":"Adapter Pattern 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.코드 출처: https://refactoring.guru/design-patterns/adapter/go/example 윈도우에는 USB, 맥북에는 thunderbolt 포트가 있다.윈도우 PC에 thunderbolt포트를 연결하기 위해 adapter가 필요하다client.go\npackage main import \u0026#34;fmt\u0026#34; type client struct { } func (c *client) insertLightningConnectorIntoComputer(com computer) { fmt.Println(\u0026#34;Client inserts Lightning connector into computer.\u0026#34;) com.insertIntoLightningPort() } computer.go\npackage main type computer interface { insertIntoLightningPort() } mac.go\npackage main import \u0026#34;fmt\u0026#34; type mac struct { } func (m *mac) insertIntoLightningPort() { fmt.Println(\u0026#34;Lightning connector is plugged into mac machine.\u0026#34;) } window.go\npackage main import \u0026#34;fmt\u0026#34; type windows struct{} func (w *windows) insertIntoUSBPort() { fmt.Println(\u0026#34;USB connector is plugged into windows machine.\u0026#34;) } windowAdapter.go\npackage main import \u0026#34;fmt\u0026#34; type windowsAdapter struct { windowMachine *windows } func (w *windowsAdapter) insertIntoLightningPort() { fmt.Println(\u0026#34;Adapter converts Lightning signal to USB.\u0026#34;) w.windowMachine.insertIntoUSBPort() } main.go\npackage main func main() { client := \u0026amp;client{} mac := \u0026amp;mac{} client.insertLightningConnectorIntoComputer(mac) windowsMachine := \u0026amp;windows{} windowsMachineAdapter := \u0026amp;windowsAdapter{ windowMachine: windowsMachine, } client.insertLightningConnectorIntoComputer(windowsMachineAdapter) } 실행 결과\nClient inserts Lightning connector into computer. Lightning connector is plugged into mac machine. Client inserts Lightning connector into computer. Adapter converts Lightning signal to USB. USB connector is plugged into windows machine. ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/adapter/","summary":"Adapter Pattern 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.코드 출처: https://refactoring.guru/design-patterns/adapter/go/example 윈도우에는 USB, 맥북에는 thunderbolt 포트가 있다.윈도우 PC에 thunderbolt포트를 연결하기 위해 adapter가 필요하다client.go\npackage main import \u0026#34;fmt\u0026#34; type client struct { } func (c *client) insertLightningConnectorIntoComputer(com computer) { fmt.Println(\u0026#34;Client inserts Lightning connector into computer.\u0026#34;) com.insertIntoLightningPort() } computer.go\npackage main type computer interface { insertIntoLightningPort() } mac.","title":"[디자인패턴] Adapter 패턴"},{"content":"Singleton 패턴 하나의 클래스에 대해 하나의 인스턴스만 존재하는 패턴go에서는 sync.Once를 통해 구현 가능하다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type User struct { uid int name string level int } type userDatabase struct { users map[int]*User } var once sync.Once var instance *userDatabase func (d *userDatabase) GetUser(uid int) (*User, bool) { user, ok := d.users[uid] return user, ok } func GetUserDatabase() *userDatabase { // sync.Once.Do()는 딱 한번만 실행  once.Do(func() { db := \u0026amp;userDatabase{ map[int]*User{ 1: {1, \u0026#34;zz\u0026#34;, 2}, 2: {2, \u0026#34;지존도적z\u0026#34;, 32}, 3: {3, \u0026#34;\u0026#34;, 21}, 4: {4, \u0026#34;zz\u0026#34;, 27}, }, } instance = db }) return instance } func main() { db := GetUserDatabase() user2, _ := db.GetUser(2) fmt.Println(user2) } 실행결과\n\u0026amp;{2 지존도적z 32} singleton에서 테스트 코드 작성시 문제점 전체 유저의 레벨의 합을 구하는 함수가 필요하다고 해보자.\nfunc GetUserTotalLevel(uids []int) int { total := 0 for _, uid := range uids { total += GetUserDatabase().users[uid].level } return total } 실제 라이브 db는 수치가 변경될 수 있기때문에 dummy db를 만들어서 테스트를 수행해야 한다.하지만 위 코드에서\n total += GetUserDatabase().users[uid].level\n 부분은 userDatabase에 종속적이므로 테스트를 작성하기 쉽지 않다. (종속성 반전 원칙에 위배됨)해결방법 인터페이스를 통해 단계를 추상화하여 종속성 반전을 통해 해결한다.\n// interface type Database interface { GetUser(int) (*User, bool) } type DummyDatabase struct { users map[int]*User } func (d *DummyDatabase) GetUser(uid int) (*User, bool) { if len(d.users) == 0 { d.users = map[int]*User{ 1: {1, \u0026#34;zz\u0026#34;, 2}, 2: {2, \u0026#34;지존도적z\u0026#34;, 32}, 3: {3, \u0026#34;\u0026#34;, 21}, 4: {4, \u0026#34;zz\u0026#34;, 27}, } } user, ok := d.users[uid] return user, ok } // GetUserTotalLevel() 함수 수정 func GetUserTotalLevel(db Database, uids []int) int { total := 0 for _, uid := range uids { user, _ := db.GetUser(uid) total += user.level } return total } func main() { liveDb := GetUserDatabase() liveTotalLevel := GetUserTotalLevel(liveDb, []int{1, 3, 4}) fmt.Println(liveTotalLevel == 50) // test code  db := \u0026amp;DummyDatabase{} totalLevel := GetUserTotalLevel(db, []int{1, 3, 4}) fmt.Println(totalLevel == 50) } 실행결과\ntrue true ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/singleton/","summary":"Singleton 패턴 하나의 클래스에 대해 하나의 인스턴스만 존재하는 패턴go에서는 sync.Once를 통해 구현 가능하다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type User struct { uid int name string level int } type userDatabase struct { users map[int]*User } var once sync.Once var instance *userDatabase func (d *userDatabase) GetUser(uid int) (*User, bool) { user, ok := d.users[uid] return user, ok } func GetUserDatabase() *userDatabase { // sync.Once.Do()는 딱 한번만 실행  once.","title":"[디자인패턴] Singleton 패턴"},{"content":"프로토타입 패턴 프로토타입 패턴(prototype pattern)은 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.얕은 복사(shallow copy) vs 깊은 복사(deep copy) 얕은 복사 객체를 복사할때 참조값을 가진 멤버는 참조값만 복사 됨.\ntype Status struct { str int dex int wis int } type Monster struct { Name string Status *Status } func main() { slime := Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1,1,1}, } goblin := slime goblin.Name = \u0026#34;goblin\u0026#34; goblin.Status.str = 3 fmt.Println(slime, slime.Status) fmt.Println(goblin, goblin.Status) } 실행결과\n{slime 0xc0000141a0} \u0026amp;{3 1 1} {goblin 0xc0000141a0} \u0026amp;{3 1 1} =\u0026gt; Status의 참조값만 복사되었기때문에 고블린의 스탯을 변경하면 슬라임의 스탯도 같이 변경된다.\n깊은 복사 type Status struct { Str int Dex int Wis int } type Monster struct { Name string Status *Status } func (m *Monster) DeepCopy() *Monster { return \u0026amp;Monster{ m.Name, \u0026amp;Status{ m.Status.Str, m.Status.Dex, m.Status.Wis, }, } } func main() { slime := \u0026amp;Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1, 1, 1}, } goblin := slime.DeepCopy() goblin.Name = \u0026#34;goblin\u0026#34; goblin.Status.Str = 3 fmt.Println(slime, slime.Status) fmt.Println(goblin, goblin.Status) } 실행결과\n{slime 0xc0000141a0} \u0026amp;{1 1 1} {goblin 0xc0000141a0} \u0026amp;{3 1 1} =\u0026gt; Status의 참조값이 아닌 참조된 객체의 내용을 복사했기때문에 고블린의 Status를 변경해도 슬라임의 Status에는 영향이 없음.\n직렬화(serialization)를 통한 깊은 복사 type Status struct { Str int Dex int Wis int } type Monster struct { Name string Status *Status } func (m *Monster) DeepCopy() *Monster { b := bytes.Buffer{} e := gob.NewEncoder(\u0026amp;b) _ = e.Encode(m) d := gob.NewDecoder(\u0026amp;b) monster := Monster{} _ = d.Decode(\u0026amp;monster) return \u0026amp;monster } func main() { slime := \u0026amp;Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1, 1, 1}, } goblin := slime.DeepCopy() goblin.Name = \u0026#34;goblin\u0026#34; goblin.Status.Str = 3 fmt.Println(slime, slime.Status) fmt.Println(goblin, goblin.Status) } 실행 결과\n\u0026amp;{slime 0xc0000141c0} \u0026amp;{1 1 1} \u0026amp;{goblin 0xc000014460} \u0026amp;{3 1 1} prototype factory  현재 아래코드에서 스킬 배열이 복사가 안됨 =\u0026gt; 원인파악중  package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/gob\u0026#34; \u0026#34;fmt\u0026#34; ) type Status struct { Str int Dex int Wis int } type Monster struct { Name string Status *Status Skills []string } func (m *Monster) DeepCopy() *Monster { b := bytes.Buffer{} e := gob.NewEncoder(\u0026amp;b) _ = e.Encode(m) d := gob.NewDecoder(\u0026amp;b) monster := Monster{} _ = d.Decode(\u0026amp;monster) return \u0026amp;monster } // prototype var ( slime = Monster{\u0026#34;slime\u0026#34;, \u0026amp;Status{1, 1, 1}, []string{}} goblin = Monster{\u0026#34;goblin\u0026#34;, \u0026amp;Status{3, 1, 1}, []string{}} ) func NewMonster(proto *Monster, name string, skills []string) *Monster { monster := proto.DeepCopy() monster.Name = name copy(monster.Skills, skills) return monster } func main() { normalSlime := NewMonster(\u0026amp;slime, \u0026#34;평범한 슬라임\u0026#34;, []string{}) normalGoblin := NewMonster(\u0026amp;goblin, \u0026#34;평범한 고블린\u0026#34;, []string{}) fireGoblin := NewMonster(\u0026amp;goblin, \u0026#34;화염 고블린\u0026#34;, []string{\u0026#34;파이어볼\u0026#34;}) fmt.Println(normalSlime, normalSlime.Status) fmt.Println(normalGoblin, normalGoblin.Status) fmt.Println(fireGoblin, fireGoblin.Status) } ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/prototype_pattern/","summary":"프로토타입 패턴 프로토타입 패턴(prototype pattern)은 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.얕은 복사(shallow copy) vs 깊은 복사(deep copy) 얕은 복사 객체를 복사할때 참조값을 가진 멤버는 참조값만 복사 됨.\ntype Status struct { str int dex int wis int } type Monster struct { Name string Status *Status } func main() { slime := Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1,1,1}, } goblin := slime goblin.Name = \u0026#34;goblin\u0026#34; goblin.","title":"[디자인패턴] Prototype 패턴"},{"content":"Factory Pattern 1. factory method pattern 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type Character interface { Attack() } const ( warrior = iota mage ) type Warrior struct { } func (w *Warrior) Attack() { fmt.Println(\u0026#34;sword attack\u0026#34;) } type Mage struct { } func (m *Mage) Attack() { fmt.Println(\u0026#34;magic attack\u0026#34;) }  Factory struct  type CharacterFactory struct { } func (f *CharacterFactory) Create(job int) (Character, error) { switch job { case warrior: return \u0026amp;Warrior{}, nil case mage: return \u0026amp;Mage{}, nil default: return nil, errors.New(\u0026#34;unsupported character type\u0026#34;) } } func main() { cf := \u0026amp;CharacterFactory{} c1, _ := cf.Create(warrior) c2, _ := cf.Create(mage) c1.Attack() c2.Attack() }  Function  func NewCharacter(job int) (Character, error) { switch job { case warrior: return \u0026amp;Warrior{}, nil case mage: return \u0026amp;Mage{}, nil default: return nil, errors.New(\u0026#34;unsupported character type\u0026#34;) } } func main() { c1, _ := NewCharacter(warrior) c2, _ := NewCharacter(mage) c1.Attack() c2.Attack() } 실행결과\nsword attack magic attack 2. factory generator 1) functional type Clothes struct { kind, color string price int } func NewClothesFactory(kind string, price int) func(color string) *Clothes { return func(color string) *Clothes { return \u0026amp;Clothes{kind, color, price} } } func main() { jeanFactory := NewClothesFactory(\u0026#34;jean\u0026#34;, 25000) skirtFactory := NewClothesFactory(\u0026#34;skirt\u0026#34;, 18000) jean := jeanFactory(\u0026#34;blue\u0026#34;) skirt := skirtFactory(\u0026#34;black\u0026#34;) skirt2 := skirtFactory(\u0026#34;white\u0026#34;) fmt.Println(jean) fmt.Println(skirt) fmt.Println(skirt2) } 2) struct type Clothes struct { kind, color string price int } type ClothesFactory struct { kind string price int } func (f *ClothesFactory) Create(color string) *Clothes { return \u0026amp;Clothes{f.kind, color, f.price} } func NewClothesFactory(kind string, price int) *ClothesFactory { return \u0026amp;ClothesFactory{kind, price} } func main() { jeanFactory := NewClothesFactory(\u0026#34;jean\u0026#34;, 25000) skirtFactory := NewClothesFactory(\u0026#34;skirt\u0026#34;, 18000) jean := jeanFactory.Create(\u0026#34;blue\u0026#34;) skirt := skirtFactory.Create(\u0026#34;black\u0026#34;) skirt2 := skirtFactory.Create(\u0026#34;white\u0026#34;) fmt.Println(jean) fmt.Println(skirt) fmt.Println(skirt2) } 실행결과\n\u0026amp;{jean blue 25000} \u0026amp;{skirt black 18000} \u0026amp;{skirt white 18000} ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/factory/","summary":"Factory Pattern 1. factory method pattern 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type Character interface { Attack() } const ( warrior = iota mage ) type Warrior struct { } func (w *Warrior) Attack() { fmt.Println(\u0026#34;sword attack\u0026#34;) } type Mage struct { } func (m *Mage) Attack() { fmt.Println(\u0026#34;magic attack\u0026#34;) }  Factory struct  type CharacterFactory struct { } func (f *CharacterFactory) Create(job int) (Character, error) { switch job { case warrior: return \u0026amp;Warrior{}, nil case mage: return \u0026amp;Mage{}, nil default: return nil, errors.","title":"[디자인패턴] Factory 패턴"},{"content":"1. Builder Pattern Person 객체를 예로 들어보자\ntype Person struct { name string age int job string height float32 weight float32 } func NewPerson(name string, age int, job string, height float32, weight float32) *Person { return \u0026amp;Person{ name, age, job, height, weight, } } func main() { p := NewPerson(\u0026#34;홍길동\u0026#34;, 22, \u0026#34;developer\u0026#34;, 177.2, 72.9) } 위처럼 모든 정보를 입력하지 않아도 될때도 있고, 가독성도 좋지않으며 parameter의 순서도 맞춰주어야한다.또 객체에 새로운 정보가 추가된다면 NewPerson()을 계속 수정해주어야 한다.이를 해결하기 위해 Builder를 이용해보자.\ntype Person struct { name string age int job string height float32 weight float32 } type PersonBuilder struct { person *Person } func NewPersonBuilder() *PersonBuilder { return \u0026amp;PersonBuilder{\u0026amp;Person{}} } func (b *PersonBuilder) Name(name string) *PersonBuilder { b.name = name return b } func (b *PersonBuilder) Age(age int) *PersonBuilder { b.age = age return b } func (b *PersonBuilder) Job(job string) *PersonBuilder { b.job = job return b } func (b *PersonBuilder) Height(height float32) *PersonBuilder { b.height = height return b } func (b *PersonBuilder) Weight(weight float32) *PersonBuilder { b.weight = weight return b } func (b *PersonBuilder) Build() *Person { return b.person } func main() { pb := NewPersonBuilder(). Age(22). Height(177.2). Weight(72.9). Name(\u0026#34;홍길동\u0026#34;). Job(\u0026#34;developer\u0026#34;) p := pb.Build() } 순서를 맞추지 않아도 되고 가독성도 좋아졌다.\n2. 함수형으로 Builder Pattern 사용 type Person struct { name string age int job string height float32 weight float32 } type modPerson func(*Person) type PersonBuilder struct { actions []modPerson } func (b *PersonBuilder) Name(name string) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.name = name }) return b } func (b *PersonBuilder) Age(age int) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.age = age }) return b } func (b *PersonBuilder) Job(job string) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.job = job }) return b } func (b *PersonBuilder) Height(height float32) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.height = height }) return b } func (b *PersonBuilder) Weight(weight float32) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.weight = weight }) return b } func (b *PersonBuilder) Build() *Person { p := \u0026amp;Person{} for _, action := range b.actions { action(p) } return p } func NewPersonBuilder() *PersonBuilder { return \u0026amp;PersonBuilder{} } func main() { pb := NewPersonBuilder(). Age(22). Height(177.2). Weight(72.9). Name(\u0026#34;홍길동\u0026#34;). Job(\u0026#34;developer\u0026#34;) p := pb.Build() } ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/bulilder/","summary":"1. Builder Pattern Person 객체를 예로 들어보자\ntype Person struct { name string age int job string height float32 weight float32 } func NewPerson(name string, age int, job string, height float32, weight float32) *Person { return \u0026amp;Person{ name, age, job, height, weight, } } func main() { p := NewPerson(\u0026#34;홍길동\u0026#34;, 22, \u0026#34;developer\u0026#34;, 177.2, 72.9) } 위처럼 모든 정보를 입력하지 않아도 될때도 있고, 가독성도 좋지않으며 parameter의 순서도 맞춰주어야한다.또 객체에 새로운 정보가 추가된다면 NewPerson()을 계속 수정해주어야 한다.","title":"[디자인패턴] Builder 패턴"},{"content":"vscode에서 아래와 같은 에러 발생시\n gopls requires a module at the root of your workspace. You can work with multiple modules by opening each one as a workspace folder.\n settings.json 파일에 아래와 같이 추가하고 vscode를 재실행한다.\n\u0026#34;gopls\u0026#34;: { \u0026#34;experimentalWorkspaceModule\u0026#34;: true, }, ","permalink":"https://icecat471.github.io/devlog/post/golang/gopls_error/","summary":"vscode에서 아래와 같은 에러 발생시\n gopls requires a module at the root of your workspace. You can work with multiple modules by opening each one as a workspace folder.\n settings.json 파일에 아래와 같이 추가하고 vscode를 재실행한다.\n\u0026#34;gopls\u0026#34;: { \u0026#34;experimentalWorkspaceModule\u0026#34;: true, }, ","title":"[Go언어] VSCode에서 gopls 에러가 날때"},{"content":"1. 원하는 테마 찾기 highlightjs.org에서 원하는 테마를 찾는다.2. css 찾기 highlightjs github에서 원하는 테마의 css파일 내용을 복사한다.3. 테마 변경 config.yml에 아래의 내용을 추가한다.pygmentsUseClasses:true(Hugo PaperMod 테마 기준)/themes/PaperMod/assests/css/hljs/an-old-hope.min.css 의 내용을 복사한 내용으로 바꾼다.=\u0026gt; 임시적으로 설정한것으로 theme overriding으로 변경 가능한지 찾아봐야 함.","permalink":"https://icecat471.github.io/devlog/post/hugo/syntax_highlight/","summary":"1. 원하는 테마 찾기 highlightjs.org에서 원하는 테마를 찾는다.2. css 찾기 highlightjs github에서 원하는 테마의 css파일 내용을 복사한다.3. 테마 변경 config.yml에 아래의 내용을 추가한다.pygmentsUseClasses:true(Hugo PaperMod 테마 기준)/themes/PaperMod/assests/css/hljs/an-old-hope.min.css 의 내용을 복사한 내용으로 바꾼다.=\u0026gt; 임시적으로 설정한것으로 theme overriding으로 변경 가능한지 찾아봐야 함.","title":"Hugo syntax highlight 변경"},{"content":"1. 세팅하기 이곳을 클릭 하여 utterances 사이트로 이동한다.configuration 부분을 따라 utterances app을 설치하고 repository설정을 한다.그 외 Blog Post \u0026lt;=\u0026gt; Issue Mapping, Theme 설정등을 한다.설정을 끝내면 Enalble Utterances 부분에 코드가 생성된다\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;(account)/(repo)\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-dark\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 2. hugo에 적용하기 테마마다 설정 방법이 다른데 내가 사용중인 PaperMod 기준 설정방법이다.ParperMod 깃허브 에서도 확인 가능하다./layouts/partials/comments.html 파일을 만들고 위에서 생성된 코드를 붙여넣기한다.그 후 config.yml 파일에 아래부분을 추가해준다.\nparams:comments:true","permalink":"https://icecat471.github.io/devlog/post/hugo/comment/","summary":"1. 세팅하기 이곳을 클릭 하여 utterances 사이트로 이동한다.configuration 부분을 따라 utterances app을 설치하고 repository설정을 한다.그 외 Blog Post \u0026lt;=\u0026gt; Issue Mapping, Theme 설정등을 한다.설정을 끝내면 Enalble Utterances 부분에 코드가 생성된다\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;(account)/(repo)\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-dark\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 2. hugo에 적용하기 테마마다 설정 방법이 다른데 내가 사용중인 PaperMod 기준 설정방법이다.ParperMod 깃허브 에서도 확인 가능하다./layouts/partials/comments.html 파일을 만들고 위에서 생성된 코드를 붙여넣기한다.그 후 config.yml 파일에 아래부분을 추가해준다.","title":"Hugo 블로그 댓글 기능 추가하기"},{"content":"gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.HTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.HTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling         gRPC의 장점 1. 다양한 언어와 플랫폼 지원 ProtoBuf의 IDL을 활용한 서비스 정의 한개로 다양한 언어와 플랫폼에서 동작.공식지원하는 언어 및 플랫폼 목록2. HTTP/2 기반  양방향 스트리밍. 높은 메시지 압축률과 성능.  3. MSA(microservice architecture)에 적합  gRPC를 활용하면 비지니스 로직에 집중하여 빠른 서비스 개발이 가능. MSA의 다양한 기술 스택의 공존으로 인한 중복 발생의 단점 보완 및 수많은 서비스간의 API 호출로 인한 성능저하 개선. ProtoBuf에 의한 높은 메시지 압축률은 시스템 전체의 네트워크 트래픽을 획기적으로 줄여줌.  출처 1. Microsoft Docs 2. 네이버 클라우드 플랫폼 기술 블로그\n","permalink":"https://icecat471.github.io/devlog/post/network/grpc/","summary":"gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.HTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.HTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling         gRPC의 장점 1.","title":"gRPC란?"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func init() { log.SetPrefix(\u0026#34;Blockchain: \u0026#34;) } func main() { fmt.Println(\u0026#34;test\u0026#34;) log.Println(\u0026#34;test\u0026#34;) } 실행시켜보면\ntest Blockchain: 2021/04/15 15:04:03 test ","permalink":"https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/","summary":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func init() { log.SetPrefix(\u0026#34;Blockchain: \u0026#34;) } func main() { fmt.Println(\u0026#34;test\u0026#34;) log.Println(\u0026#34;test\u0026#34;) } 실행시켜보면\ntest Blockchain: 2021/04/15 15:04:03 test ","title":"Go언어 log.SetPrefix()"},{"content":"\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;800\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; let canvas = document.querySelector(\u0026#39;#myCanvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = \u0026#39;이미지 경로\u0026#39;; context.drawImage(dragon, x좌표, y좌표, width, height); setInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.\n// 1초마다 새로 그림 setInterval(()=\u0026gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms ","permalink":"https://icecat471.github.io/devlog/post/html/draw_image_on_canvas/","summary":"\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;800\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; let canvas = document.querySelector(\u0026#39;#myCanvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = \u0026#39;이미지 경로\u0026#39;; context.drawImage(dragon, x좌표, y좌표, width, height); setInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.\n// 1초마다 새로 그림 setInterval(()=\u0026gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms ","title":"html 캔버스에 이미지 그리기"},{"content":"출처: 예제로 배우는 Go 프로그래밍\n1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.\npackage main import \u0026#34;os\u0026#34; func main() { f, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } 2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.이것은 콜스택을 따라 상위함수에도 모두 적용.마지막에는 프로그램이 에러를 내고 종료된다.\npackage main import \u0026#34;os\u0026#34; func main() { // 잘못된 파일명을 넣음  openFile(\u0026#34;Invalid.txt\u0026#34;) // openFile() 안에서 panic이 실행되면  // 아래 println 문장은 실행 안됨  println(\u0026#34;Done\u0026#34;) } func openFile(fn string) { f, err := os.Open(fn) if err != nil { panic(err) } defer f.Close() } 3. recover panic 상태를 다시 정상으로 돌리는 함수.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 잘못된 파일명을 넣음  openFile(\u0026#34;Invalid.txt\u0026#34;) // recover에 의해  // 이 문장 실행됨  println(\u0026#34;Done\u0026#34;) } func openFile(fn string) { // defer 함수. panic 호출시 실행됨  defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;OPEN ERROR\u0026#34;, r) } }() f, err := os.Open(fn) if err != nil { panic(err) } defer f.Close() } ","permalink":"https://icecat471.github.io/devlog/post/golang/defer_and_panic/","summary":"출처: 예제로 배우는 Go 프로그래밍\n1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.\npackage main import \u0026#34;os\u0026#34; func main() { f, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } 2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.이것은 콜스택을 따라 상위함수에도 모두 적용.","title":"Go언어 defer와 panic"},{"content":"golang flag package\ncommand-line flag를 파싱해주는 패키지.\n// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(\u0026#34;max\u0026#34;, 10, \u0026#34;Defines maximum value\u0026#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(\u0026amp;minValue, \u0026#34;min\u0026#34;, 0, \u0026#34;Defines minimum value\u0026#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() ","permalink":"https://icecat471.github.io/devlog/post/golang/flag/","summary":"golang flag package\ncommand-line flag를 파싱해주는 패키지.\n// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(\u0026#34;max\u0026#34;, 10, \u0026#34;Defines maximum value\u0026#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(\u0026amp;minValue, \u0026#34;min\u0026#34;, 0, \u0026#34;Defines minimum value\u0026#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() ","title":"Go언어 flag 패키지를 통한 command-line flag 파싱"},{"content":"go.mod 파일에서\nrequire ( \u0026lt;모듈명\u0026gt; v0.0.0 ) replace \u0026lt;모듈명\u0026gt; v0.0.0 =\u0026gt; ../module // 이런 형태로 경로를 지정해줌 ","permalink":"https://icecat471.github.io/devlog/post/golang/external_module/","summary":"go.mod 파일에서\nrequire ( \u0026lt;모듈명\u0026gt; v0.0.0 ) replace \u0026lt;모듈명\u0026gt; v0.0.0 =\u0026gt; ../module // 이런 형태로 경로를 지정해줌 ","title":"Go언어 프로젝트 외부의 모듈 import하기"},{"content":"참고: Unity Document WebGL\nbuild시 생성되는 unityInstance에 메세지를 보내서 호출.\nunityInstace.SendMessage(\u0026#39;오브젝트명\u0026#39;, \u0026#39;함수명\u0026#39;); ","permalink":"https://icecat471.github.io/devlog/post/unity/call_unity_func_in_js/","summary":"참고: Unity Document WebGL\nbuild시 생성되는 unityInstance에 메세지를 보내서 호출.\nunityInstace.SendMessage(\u0026#39;오브젝트명\u0026#39;, \u0026#39;함수명\u0026#39;); ","title":"브라우저에서 유니티 함수 호출하기"},{"content":"참고: Unity Document WebGL\nAssets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다\n// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(\u0026#34;Hello, world!\u0026#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i \u0026lt; size; i++) console.log(HEAPF32[(array \u0026gt;\u0026gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = \u0026#34;bla\u0026#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.bindTexture(GLctx.TEXTURE_2D, GL.textures[texture]); }, }); using UnityEngine; using System.Runtime.InteropServices; public class NewBehaviourScript : MonoBehaviour { [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void Hello(); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void HelloString(string str); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void PrintFloatArray(float[] array, int size); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern int AddNumbers(int x, int y); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern string StringReturnValueFunction(); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void BindWebGLTexture(int texture); void Start() { Hello(); HelloString(\u0026#34;This is a string.\u0026#34;); float[] myArray = new float[10]; PrintFloatArray(myArray, myArray.Length); int result = AddNumbers(5, 7); Debug.Log(result); Debug.Log(StringReturnValueFunction()); var texture = new Texture2D(0, 0, TextureFormat.ARGB32, false); BindWebGLTexture(texture.GetNativeTextureID()); } } if(Application.platform == RuntimePlatform.WebGLPlayer) { Hello(); } ","permalink":"https://icecat471.github.io/devlog/post/unity/call_javascript/","summary":"참고: Unity Document WebGL\nAssets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다\n// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(\u0026#34;Hello, world!\u0026#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i \u0026lt; size; i++) console.log(HEAPF32[(array \u0026gt;\u0026gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = \u0026#34;bla\u0026#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.","title":"유니티 WebGL 자바스크립트 함수 호출"},{"content":"아래처럼 나올 때\nzsh: command not found: dotnet dotnet package를 설치했다면/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인./usr/local/bin 경로에 링크를 만들어주면 된다.ln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow\n","permalink":"https://icecat471.github.io/devlog/post/unity/command_not_found_dotnet/","summary":"아래처럼 나올 때\nzsh: command not found: dotnet dotnet package를 설치했다면/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인./usr/local/bin 경로에 링크를 만들어주면 된다.ln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow","title":"터미널에서 command not found: dotnet 에러"},{"content":"webGL \u0026ldquo;build and run\u0026rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림로컬에서 서버를 열어서 실행해볼 수 있다.\nhttp-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.\n","permalink":"https://icecat471.github.io/devlog/post/unity/local_server/","summary":"webGL \u0026ldquo;build and run\u0026rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림로컬에서 서버를 열어서 실행해볼 수 있다.\nhttp-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.","title":"유니티 webGL 프로젝트 로컬서버에서 실행하기"},{"content":"// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 \u0026lt;image name\u0026gt; // stat 확인 docker stats \u0026lt;container id\u0026gt; ","permalink":"https://icecat471.github.io/devlog/post/docker/docker_memory_limit/","summary":"// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 \u0026lt;image name\u0026gt; // stat 확인 docker stats \u0026lt;container id\u0026gt; ","title":"Docker 컨테이너 메모리 및 CPU 제한하기"},{"content":"출처: IALY\u0026rsquo;s BLOG\n1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown 2. Hugo Project 생성 hugo new site \u0026lt;프로젝트명\u0026gt; 3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.\n원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운\n$ git clone \u0026lt;테마 깃허브 주소\u0026gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.)config 파일 예시는 각 테마 깃허브에서 확인 가능.\n# config.ymlbaseURL:\u0026#34;https://\u0026lt;userid.github.io\u0026gt;/\u0026lt;repo name\u0026gt;/\u0026#34;title:\u0026#34;블로그 타이틀\u0026#34;theme:\u0026#34;테마명\u0026#34;# /themes 폴더에 다운 받은 테마폴더명4. 포스팅 하기 프로젝트 내에서\n$ hugo new \u0026lt;파일이름\u0026gt; ex) hugo new post/test.md 라고 입력하면content 폴더내부에 content/post/test.md 경로로 파일 생성.5. 로컬서버에서 블로그 확인 $ hugo server -D -D 옵션을 주면 draft: true인 글도 확인가능하다.기본적으로 http://localhost:1313/ 로 확인 가능. 6. build 및 push hugo project를 push할 repo와 빌드한 public 파일을 push할 repo를 따로 만든다.프로젝트 루트에서$ git init $ git remote add origin \u0026lt;첫번째 repo\u0026gt; // 두번째 repo를 첫번째 repo의 submodule로 지정 $ git submodule add -b master \u0026lt;두번째 repo\u0026gt; public // build $ hugo // push $ cd public $ git add . $ git commit -m \u0026#34;\u0026lt;커밋 메세지\u0026gt;\u0026#34; $ git push origin master $ cd .. $ git add . $ git commit -m \u0026#34;\u0026lt;커밋 메세지\u0026gt;\u0026#34; $ git push origin master ","permalink":"https://icecat471.github.io/devlog/post/hugo/start_hugo/","summary":"출처: IALY\u0026rsquo;s BLOG\n1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown 2. Hugo Project 생성 hugo new site \u0026lt;프로젝트명\u0026gt; 3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.\n원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운\n$ git clone \u0026lt;테마 깃허브 주소\u0026gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.)config 파일 예시는 각 테마 깃허브에서 확인 가능.","title":"Hugo로 블로그 시작하기"}]