[{"content":"클로저(closure) 함수를 일급객체로 취급하는 함수형 프로그래밍 언어(Erlang, Scala, Haskell 등)에서 사용되는 중요한 특성이다.클로저에 대해 MDN은 아래와 같이 정의하고 있다.\n “A closure is the combination of a function and the lexical environment within which that function was declared.”\n\u0026ldquo;클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.\u0026rdquo;\n 아래의 예제를 먼저 확인해 보자\npackage main func outerFunc() func() { x := 10 innerFunc := func() { fmt.Println(x) } return innerFunc } func main() { f := outerFunc() f() // output:  // 10 } scope는 함수를 호출할 때가 아니라 어디에 선언하였는지에 따라 결정된다. 이를 Lexical scoping 이라고 한다. 위 예제에서 함수 innerFunc는 함수 OuterFunc 내부에서 선언되었기 때문에 함수 innerFunc의 상위 스코프는 outerFunc이다. innerFunc가 전역에 선언되었다면 innerFunc의 상위 스코프는 전역 스코프가 된다.Go언어에서의 클로저 아래 예제에서 nextValue() 함수는 int를 리턴하는 익명함수를 리턴하는 함수이다. go언어에서 함수는 일급함수로서 다른 함수로부터 리턴되는 리턴값으로 사용될 수 있다.\npackage main func nextValue() func() int { i := 0 return func() int { i++ return i } } func main() { next := nextValue() println(next()) // 1  println(next()) // 2  println(next()) // 3  anotherNext := nextValue() println(anotherNext()) // 1 다시 시작  println(anotherNext()) // 2 } 여기서 익명함수가 그 함수 바깥에 있는 변수 i를 참조하고 있다. 익명함수 자체가 로컬 변수로 i를 갖는 것이 아니기때문에 외부 변수 i가 계속 상태를 유지하고 있어 값을 하나씩 증가하는 기능을 하게 된다.(익명함수 자체가 로컬변수로 i를 갖는다면 함수 호출시 i는 항상 0으로 설정된다.)\nreference  https://poiemaweb.com/js-closure http://golang.site/go/article/11-Go-%ED%81%B4%EB%A1%9C%EC%A0%80  ","permalink":"https://icecat471.github.io/devlog/post/golang/closure/","summary":"클로저(closure) 함수를 일급객체로 취급하는 함수형 프로그래밍 언어(Erlang, Scala, Haskell 등)에서 사용되는 중요한 특성이다.클로저에 대해 MDN은 아래와 같이 정의하고 있다.\n “A closure is the combination of a function and the lexical environment within which that function was declared.”\n\u0026ldquo;클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.\u0026rdquo;\n 아래의 예제를 먼저 확인해 보자\npackage main func outerFunc() func() { x := 10 innerFunc := func() { fmt.Println(x) } return innerFunc } func main() { f := outerFunc() f() // output:  // 10 } scope는 함수를 호출할 때가 아니라 어디에 선언하였는지에 따라 결정된다.","title":"[Go언어] Closure"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/fundamentals/async-providers\nAsynchronous providers 때떄로, 애플리케이션은 하나 또는 그 이상의 비동기 작업이 끝날때까지 시작이 지연되어야한다. 예를 들어, 데이터베이스에 연결이 될때까지는 request를 받고싶지 않을 것이다. asynchronous provider를 사용하여 이를 해결할 수 있다.이것을 위한 문법은 useFactory와 함께 async/await를 사용하는 것이다. factory는 Promise를 리턴하며, await를 사용해 비동기 작업을 대기할 수 있다. Nest는 이러한 provider에 의존하는 클래스가 인스턴스화 될때까지 대기한다.\n{ provide: \u0026#39;ASYNC_CONNECTION\u0026#39;, useFactory: async () =\u0026gt; { const connection = await createConnection(options); return connection; }, }  [hint]\ncustom provider 문법에 대해 더 알고 싶으면 여기를 클릭.\n Injection asynchronous provider는 다른 provider와 마찬가지로 토큰을 통해 다른 컴포넌트에 주입될 수 있다. 위의 예제에서는 @Inject(\u0026lsquo;ASYNC_CONNECTION\u0026rsquo;)을 사용하면 된다.\nExample TypeORM 챕터에 비동기 provider에 대한 더 많은 예제가 있다.\n","permalink":"https://icecat471.github.io/devlog/post/nestjs/asynchronous_providers/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/fundamentals/async-providers\nAsynchronous providers 때떄로, 애플리케이션은 하나 또는 그 이상의 비동기 작업이 끝날때까지 시작이 지연되어야한다. 예를 들어, 데이터베이스에 연결이 될때까지는 request를 받고싶지 않을 것이다. asynchronous provider를 사용하여 이를 해결할 수 있다.이것을 위한 문법은 useFactory와 함께 async/await를 사용하는 것이다. factory는 Promise를 리턴하며, await를 사용해 비동기 작업을 대기할 수 있다. Nest는 이러한 provider에 의존하는 클래스가 인스턴스화 될때까지 대기한다.\n{ provide: \u0026#39;ASYNC_CONNECTION\u0026#39;, useFactory: async () =\u0026gt; { const connection = await createConnection(options); return connection; }, }  [hint]","title":"[NestJS] (공식문서 번역) Asynchronous providers"},{"content":"순서가 중요한 경우 package main import \u0026#34;fmt\u0026#34; func remove(slice []int, s int) []int { return append(slice[:s], slice[s+1:]...) } func main() { var Slice1 = []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1: %v\\n\u0026#34;, Slice1) Slice2 := remove(Slice1, 2) fmt.Printf(\u0026#34;slice2: %v\\n\u0026#34;, Slice2) } 실행 결과\nslice1: [1 2 3 4 5] slice2: [1 2 4 5] 순서가 중요하지 않은 경우 package main import \u0026#34;fmt\u0026#34; func remove(s []int, i int) []int { s[i] = s[len(s)-1] return s[:len(s)-1] } func main() { var Slice1 = []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1: %v\\n\u0026#34;, Slice1) Slice2 := remove(Slice1, 2) fmt.Printf(\u0026#34;slice2: %v\\n\u0026#34;, Slice2) } 실행결과\nslice1: [1 2 3 4 5] slice2: [1 2 5 4] 설명 속도는 후자가 더 빠르기 때문에, 순서가 중요한 경우 전자를 사용하고 순서보다 속도가 중요할 때에는 후자를 사용하면 된다.\n출처 https://www.delftstack.com/ko/howto/go/how-to-delete-an-element-from-a-slice-in-golang/\n","permalink":"https://icecat471.github.io/devlog/post/golang/delete_item_from_slice/","summary":"순서가 중요한 경우 package main import \u0026#34;fmt\u0026#34; func remove(slice []int, s int) []int { return append(slice[:s], slice[s+1:]...) } func main() { var Slice1 = []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1: %v\\n\u0026#34;, Slice1) Slice2 := remove(Slice1, 2) fmt.Printf(\u0026#34;slice2: %v\\n\u0026#34;, Slice2) } 실행 결과\nslice1: [1 2 3 4 5] slice2: [1 2 4 5] 순서가 중요하지 않은 경우 package main import \u0026#34;fmt\u0026#34; func remove(s []int, i int) []int { s[i] = s[len(s)-1] return s[:len(s)-1] } func main() { var Slice1 = []int{1, 2, 3, 4, 5} fmt.","title":"[Go언어] 슬라이스에서 요소 삭제"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/fundamentals/custom-providers\nCustom providers 앞선 챕터들에서, 다양한 측면의 의존성 주입(DI)를 어떻게 Nest에서 사용하는지 알아보았다. 하나의 예는 생성자 기반 의존성 주입이다. Nest 코어에서 기본적으로 빌드되는 의존성 주입과 한가지 메인 패턴만을 살펴보았다. 애플레케이션이 더 복잡해질수록 DI 시스템의 모든 특성들을 필요로 하게 될 것이다. 좀 더 자세히 알아보자.\nDI fundamentals 의존성 주입은 직접 코드로 작성하는 대신, 의존성의 인스턴스화를 IoC 컨테이너(여기서는 NestJS runtime system)에게 맡기는 inversion of control(IoC) 테크닉이다. Providers 챕터에서 보았던 아래의 예제를 살펴보자.첫번째로, 우리는 provider를 정의하였다. @Injectable() 데코레이터는 CatsService 클래스를 provider로 마크해준다.\n// cats.service.ts  import { Injectable } from \u0026#39;@nestjs/common\u0026#39;; import { Cat } from \u0026#39;./interfaces/cat.interface\u0026#39;; @Injectable() export class CatsService { private readonly cats: Cat[] = []; findAll(): Cat[] { return this.cats; } } 그 후 우리는 Nest에 controller 클래스에 provider를 주입해달라고 요청한다.\n// cats.controller.ts  import { Controller, Get } from \u0026#39;@nestjs/common\u0026#39;; import { CatsService } from \u0026#39;./cats.service\u0026#39;; import { Cat } from \u0026#39;./interfaces/cat.interface\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { constructor(private catsService: CatsService) {} @Get() async findAll(): Promise\u0026lt;Cat[]\u0026gt; { return this.catsService.findAll(); } } 마지막으로, provider를 Nest IoC container에 등록한다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats/cats.controller\u0026#39;; import { CatsService } from \u0026#39;./cats/cats.service\u0026#39;; @Module({ controllers: [CatsController], providers: [CatsService], }) export class AppModule {} 이러한 일을 위해 정확히 어떤 일이 일어나는 것일까? 프로세스는 3가지 주요 스텝으로 나누어진다.\n  cats.service.ts 에서 @Injectable() 데코레이터가 CatsService 클래스를 Nest IoC container에게 관리되는 클래스로 선언한다.\n  cats.controllerts 에서 CatsController는 생성자 주입을 통해 CatsService에 대한 의존성을 선언한다.\n  app.module.ts 에서 CatsService 토큰을 cats.service.ts의 CatsService와 연관 짓는다. 아래에서 정확히 이러한 관련짓기(registration이라고도 부른다)가 어떻게 일어나는지 알아볼 것이다.\n  Nest IoC container가 CatsController를 인스턴스화 할 때, 의존성이 있는지를 확인한다. CatsService 의존성을 찾아서 CatsService 클래스를 리턴한다. 싱글톤(기본값이 싱글톤이다)이라고 가정해보자. Nest는 그 후 CatsService 인스턴스를 만들고, 캐싱을 하고, 그것을 리턴할 것이다 또는 이미 캐싱되어있는 경우 존재하는 인스턴스를 리턴할 것이다.이 설명은 요점을 설명하기 위해 조금 간단하게 한것이다. 중요한 점은 이러한 의존성 관련 코드를 분석하는 것이 매우 정교하며, 애플리케이션이 실행될 때 일어난다는 것이다. 한가지 중요한 특성은 의존성 분석(또는 의존성 그래프를 만드는 것)은 transitive 라는 것이다. 위의 예제에서, CatsService 스스로가 의존성을 가진다면, 이러한 점도 해결될 것이다. 의존성 그래프는 의존성이 올바른 순서(기본적으로 bottom-up)로 resolve 됨을 보장한다. 이러한 메커니즘은 개발자들이 복잡한 의존성 그래프를 직접 다루지 않아도 되게 해준다.\nStandard providers @Module() 데코레이터를 더 자세히 살펴보자. app.module 에서\n@Module({ controllers: [CatsController], providers: [CatsService], }) providers 프로퍼티는 provider 배열(class명)을 받는다. 사실, providers: [CatsService] 는 좀 더 복잡한 문법을 간단하게 작성한 것이다.\nproviders: [ { provide: CatsService, useClass: CatsService, }, ]; 더 명확한 위의 구조를 보았으므로, registration 프로세스에 대해 이해할 수 있다. CatsService 토큰과 CatsService 클래스를 관계짓고 있다. 단축문법이 토큰과 클래스의이름이 같은 경우에 더 편리하다.\nCustom providers standard providers에 제공하는 것 이외에 요구사항은 어떤식으로 처리될까? 여기에 일부의 예시가 있다.\n Nest 인스턴스화(또는 캐싱된 인스턴스의 리턴) 대신 커스텀 인스턴스를 만들고 싶을 때. second dependency를 통해 존재하는 클래스를 재사용 하고 싶을 때. 테스트를 위해 클래스를 mock 버전으로 오버라이드 하고 싶을 때.  Nest는 위와 같은 상황을 처리할 수 있도록 custom provider를 정의할 수 있게 해준다.\nValue providers: useValue useValue 문법은 외부 라이브러리로부터 Nest container로 상수값을 주입하거나, mock object로 실제 구현을 대체할 때 유용하다. Nest에게 테스트를 위해 mock CatsService를 사용하게 해보자.\nimport { CatsService } from \u0026#39;./cats.service\u0026#39;; const mockCatsService = { /* mock implementation ... */ }; @Module({ imports: [CatsModule], providers: [ { provide: CatsService, useValue: mockCatsService, }, ], }) export class AppModule {} 위의 예제에서, CatsService 토큰은 mockCatsService mock object로 resolve 한다. useValue는 이 경우, CatsService 클래스를 대체하기 위해 같은 인터페이스를 가진 리터럴 오브젝트를 필요로 한다. 타입스크립트의 structural typing을 통해 호환되는 인터페이스를 가진 오브젝트(리터럴 오브젝트나 new를 통한 클래스 인스턴스화)를 사용할 수 있다.\nNon-class-based provider tokens 지금까지 클래스명을 provider 토큰으로 사용하였다. 이것은 constructor based injection을 사용한 표준 패턴이다. 때때로, 문자열이나 심볼을 DI 토큰으로 사용하고 싶을 것이다.\nimport { connection } from \u0026#39;./connection\u0026#39;; @Module({ providers: [ { provide: \u0026#39;CONNECTION\u0026#39;, useValue: connection, }, ], }) export class AppModule {} 위의 예제에서, \u0026lsquo;CONNECTION\u0026rsquo;이라는 문자열을 외부 파일로부터 import한 이미 존재하는 connection 오브젝트와 관련짓기 위해 사용하였다.\n [notice]\n토큰 값으로 문자열 외에도 자바스크립트 symbol이나 타입스크립트 enum을 사용할 수 있다.\n standard constructor based injection 패턴으로 provide를 주입하는 방법에 대해서는 이미 보았다. 이 패턴은 의존성이 클래스명으로 선언되어야 한다. \u0026lsquo;CONNECTION\u0026rsquo; custom provider는 string-value 토큰을 사용한다. 어떻게 이러한 provider를 주입하는지 알아보자. @Inject() 데코레이터를 사용하여 인자로 token을 받는다.\n@Injectable() export class CatsRepository { constructor(@Inject(\u0026#39;CONNECTION\u0026#39;) connection: Connection) {} } 위 예제에서 설명의 목적으로 직접 \u0026lsquo;CONNECTION\u0026rsquo;이라는 문자열을 사용했지만, 더 클린한 코드 구조를 위해서는 토큰을 분리된 파일(예를 들어, constants.ts)에 정의하는 것이 좋다. symbol이나 enum으로 정의하고 필요한 곳에 import 하여 사용하면 된다.\nClass providers: useClass useClass 문법은 토큰이 resolve되어야 할 곳에 동적으로 클래스가 결정되게 해준다. 예를 들어, ConfigService 클래스가 있다고 가정하자. 현재의 환경에 따라, Nest가 다른 configuration service를 구현하기를 원한다.\nconst configServiceProvider = { provide: ConfigService, useClass: process.env.NODE_ENV === \u0026#39;development\u0026#39; ? DevelopmentConfigService : ProductionConfigService, }; @Module({ providers: [configServiceProvider], }) export class AppModule {} 위 코드를 자세히 살펴보자. 우리는 configServiceProvider를 literal object로 먼저 선언하고, 이 것을 module 데코레이터의 providers 프로퍼티에 넣어주었다. 코드 구조적으로는 조금 다르지만, 기능적으로는 이 챕터에서 위에서 봤던 예제들과 같다.또한, ConfigService 클래스명을 토큰으로 사용했다. ConfigService에 의존하는 클래스라면, Nest는 제공된 클래스(DevelopmentConfigService 또는 ProductionConfigService)의 인스턴스를 주입할 것이다.\nFactory providers: useFactory useFactory 문법은 provider를 동적으로 만들 수 있게 해준다. 실제 provider는 factory 함수에 의해 리턴되는 값이다. factory 함수는 필요에 따라 간단하거나 복잡해질 수 있다. 간단한 factory는 다른 provider에 의존하지 않을 것이며, 복잡한 factory는 자신을 다른 provider에 주입할 수도 있다. 후자의 경우, factory provider 문법은 한쌍의 관련된 메커니즘을 갖는다.\n factory 함수는 (optional) argument를 수용할 수 있다. (optional) inject property는 Nest가 인스턴스화 프로세스중 전달할 argument나 provider의 배열을 수용할 수 있다. 두 리스트는 서로 연관되어 있다. Nest는 inject list를 factory 함수의 인자로 같은 순서로 전달한다.  const connectionFactory = { provide: \u0026#39;CONNECTION\u0026#39;, useFactory: (optionsProvider: OptionsProvider) =\u0026gt; { const options = optionsProvider.get(); return new DatabaseConnection(options); }, inject: [OptionsProvider], }; @Module({ providers: [connectionFactory], }) export class AppModule {} Alias providers: useExisting useExisting 문법은 존재하는 provider에 가명을 만들 수 있게 해준다. 이것은 같은 provider에 접근 방법을 두가지로 만들어준다. 아래의 예제에서, 문자열 토큰 \u0026lsquo;AliasedLoggerService\u0026rsquo;는 LoggerService의 가명이다. 두가지 다른 의존성을 가지고 있다고 가정할 수 있다. 두 의존성이 singleton scope라면, 같은 인스턴스로 resolve 될 것이다.\n@Injectable() class LoggerService { /* implementation details */ } const loggerAliasProvider = { provide: \u0026#39;AliasedLoggerService\u0026#39;, useExisting: LoggerService, }; @Module({ providers: [LoggerService, loggerAliasProvider], }) export class AppModule {} Non-service based providers provider가 종종 service를 지원하는 반면, 사용법에 제한은 없다. provider는 어떠한 값도 지원한다. 예를 들어, provider는 현재 환경에 의존하는 configuration object의 배열일수도 있다.\nconst configFactory = { provide: \u0026#39;CONFIG\u0026#39;, useFactory: () =\u0026gt; { return process.env.NODE_ENV === \u0026#39;development\u0026#39; ? devConfig : prodConfig; }, }; @Module({ providers: [configFactory], }) export class AppModule {} Export custom provider 다른 provider와 마찬가지로 custom provider의 scope도 provider가 선언된 module에 의존한다. 이를 다른 module에서 사용하려면 export되어야 한다. custom provider를 export하기 위해서는 provider object나 토큰을 사용하면 된다.\nconst connectionFactory = { provide: \u0026#39;CONNECTION\u0026#39;, useFactory: (optionsProvider: OptionsProvider) =\u0026gt; { const options = optionsProvider.get(); return new DatabaseConnection(options); }, inject: [OptionsProvider], }; @Module({ providers: [connectionFactory], exports: [\u0026#39;CONNECTION\u0026#39;], }) export class AppModule {} const connectionFactory = { provide: \u0026#39;CONNECTION\u0026#39;, useFactory: (optionsProvider: OptionsProvider) =\u0026gt; { const options = optionsProvider.get(); return new DatabaseConnection(options); }, inject: [OptionsProvider], }; @Module({ providers: [connectionFactory], exports: [connectionFactory], }) export class AppModule {} ","permalink":"https://icecat471.github.io/devlog/post/nestjs/custom_providers/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/fundamentals/custom-providers\nCustom providers 앞선 챕터들에서, 다양한 측면의 의존성 주입(DI)를 어떻게 Nest에서 사용하는지 알아보았다. 하나의 예는 생성자 기반 의존성 주입이다. Nest 코어에서 기본적으로 빌드되는 의존성 주입과 한가지 메인 패턴만을 살펴보았다. 애플레케이션이 더 복잡해질수록 DI 시스템의 모든 특성들을 필요로 하게 될 것이다. 좀 더 자세히 알아보자.\nDI fundamentals 의존성 주입은 직접 코드로 작성하는 대신, 의존성의 인스턴스화를 IoC 컨테이너(여기서는 NestJS runtime system)에게 맡기는 inversion of control(IoC) 테크닉이다.","title":"[NestJS] (공식문서 번역) Custom Providers"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/custom-decorators\nCustom decorators Custom router decorators Nest는 데코레이터라는 특성을 중심으로 만들어졌다. 데코레이터는 많은 프로그래밍 언어에서 알려진 개념이지만, 자바스크립트 세계에서는 상대적으로 새로운 편이다. 데코레이터가 어떻게 작동하는지 더 잘 이해하기 위해서는, 이 글을 읽어보는 것을 추천한다. 아래는 간단한 정의이다.\n ES2016 데코레이터는 함수를 반환하고, 인자로 target, name, property, description을 받을 수 있는 expression이다. decorate하려고하는 것 맨 위에 @를 접두어로 붙인 데코레이터를 위치함으로써 데코레이터를 적용할 수 있다. 데코레이터는 class, method, property에 대해 정의 할 수 있다.\n Param decorator Nest는 HTTP route handler와 함께 사용할 수 있는 유용한 param decorator들을 제공한다. 아래는 제공되는 데코레이터들과 그들이 나타내는 express(또는 fastify) 오브젝트이다.\n         @Request(), @Req() req   @Response(), @Res() res   @Next() next   @Session req.session   @Param(param?: string) req.params / req.params[param]   @Body(param?: string req.body / req.body[param]   @Query(param?: string req.query / req.query[param]   @Headers(param?: string) req.headers / req.headers[params]   @Ip() req.ip   @HostParam() req.hosts        node.js에서 request 오브젝트에 프로퍼티를 추가하는 것은 일반적이다. 그리고 각각의 route handler에서 아래와 같이 추가된 프로퍼티를 추출해 사용할 수 있다.\nconst user = req.user; 코드를 더욱 가독성있고 투명하게 만들기 위해, @User() 데코레이터를 만들고 재사용하는 방법을 사용할 수 있다.\n// user.decorator.ts  import { createParamDecorator, ExecutionContext } from \u0026#39;@nestjs/common\u0026#39;; export const User = createParamDecorator( (data: unknown, ctx: ExecutionContext) =\u0026gt; { const request = ctx.switchToHttp().getRequest(); return request.user; }, ); 그 후, 필요한 곳 어디든 간단하게 사용할 수 있다.\n@Get() async findOne(@User() user: UserEntity) { console.log(user); } Passing data 데코레이터가 특정 조건에 의존하여 작동한다면, data 파라미터를 데코레이터의 팩토리 함수에 넘겨줄 수 있다. 하나의 사례는 request 오브젝트로부터 프로퍼티를 추출하는 데코레이터이다. 예를 들어, 우리의 authentication layer가 request를 validation하고 user entity를 request 오브젝트에 추가하였다고 가정해보자. user entity는 아래와 같은 형태이다.\n{ \u0026#34;id\u0026#34;: 101, \u0026#34;firstName\u0026#34;: \u0026#34;Alan\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Turing\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alan@email.com\u0026#34;, \u0026#34;roles\u0026#34;: [\u0026#34;admin\u0026#34;] } 프로퍼티명을 key값으로 받아서 값이 존재한다면 리턴해주는 데코레이터를 정의해보자(user object가 만들어지지 않았거나 해당 프로퍼티가 존재하지 않으면 undefined를 리턴할 것이다).\n// user.decorator.ts  import { createParamDecorator, ExecutionContext } from \u0026#39;@nestjs/common\u0026#39;; export const User = createParamDecorator( (data: string, ctx: ExecutionContext) =\u0026gt; { const request = ctx.switchToHttp().getRequest(); const user = request.user; return data ? user?.[data] : user; }, ); 그리고 controller에서 @User() 데코레이터를 통해 아래와 같이 특정 프로퍼티에 접근 가능하다.\n@Get() async findOne(@User(\u0026#39;firstName\u0026#39;) firstName: string) { console.log(`Hello ${firstName}`); } 다른 key값을 사용하여 다른 프로퍼티에도 접근 가능하다. user 오브젝트가 deep하거나 복잡한 경우 이 방식이 좀 더 가독성 있는 request handler 구현을 도와줄 것이다.\n [hint]\n타입스크립트 사용자를 위해, createParamDecorator()는 제네릭임을 주의하라. 이것은 type safety를 강화할 수 있음을 의미한다(예를 들어, createParamDecorator((data, ctx) =\u0026gt; \u0026hellip;)). 또는 팩토리 함수에 특정 파라미터의 타입을 지정할 수도 있다(createParamDecorator((data: string, ctx) =\u0026gt; \u0026hellip;)). 만약 둘 다 생략한다면, data의 타입은 any 이다.\n Working with pipes Nest는 @Body(), @Query(), @Param() 처럼 내장된 데코레이터들과 같은 방식으로 custom param decorator를 취급한다. 이것은 custom annotated parameter에도 pipe가 작동한다는 것을 의미한다. 또한, pipe를 직접 custom decorator에 적용할 수도 있다.\n@Get() async findOne( @User(new ValidationPipe({ validateCustomDecorators: true })) user: UserEntity, ) { console.log(user); }  [hint]\nvalidateCustomDecorators 옵션이 true임에 주목하자. ValidationPipe는 기본적으로 커스텀 데코레이터로 주석된 인자는 validation하지 않는다.\n Decorator composition Nest는 multiple decorator의 구성을 도와주는 helper method를 제공한다. 예를 들어, authentication에 관련된 모든 데코레이터를 하나의 데코레이터로 합치고 싶다고 가정해보자. 이것은 아래의 예제처럼 구성할 수 있다.\n// auth.decorator.ts  import { applyDecorators } from \u0026#39;@nestjs/common\u0026#39;; export function Auth(...roles: Role[]) { return applyDecorators( SetMetadata(\u0026#39;roles\u0026#39;, roles), UseGuards(AuthGuard, RolesGuard), ApiBearerAuth(), ApiUnauthorizedResponse({ description: \u0026#39;Unauthorized\u0026#39; }), ); } 그리고 이 커스텀 @Auth() 데코레이터를 사용하면 된다.\n@Get(\u0026#39;users\u0026#39;) @Auth(\u0026#39;admin\u0026#39;) findAllUsers() {} 하나의 데코레이터 선언으로 4개의 데코레이터가 적용되었다.\n [warning]\n@nestjs/swagger 패키지에서 제공되는 @ApiHideProperty() 데코레이터는 applyDecorators() method에서 작동하지 않으며, 하나로 묶을 수 없다.\n ","permalink":"https://icecat471.github.io/devlog/post/nestjs/custom_decorators/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/custom-decorators\nCustom decorators Custom router decorators Nest는 데코레이터라는 특성을 중심으로 만들어졌다. 데코레이터는 많은 프로그래밍 언어에서 알려진 개념이지만, 자바스크립트 세계에서는 상대적으로 새로운 편이다. 데코레이터가 어떻게 작동하는지 더 잘 이해하기 위해서는, 이 글을 읽어보는 것을 추천한다. 아래는 간단한 정의이다.\n ES2016 데코레이터는 함수를 반환하고, 인자로 target, name, property, description을 받을 수 있는 expression이다. decorate하려고하는 것 맨 위에 @를 접두어로 붙인 데코레이터를 위치함으로써 데코레이터를 적용할 수 있다.","title":"[NestJS] (공식문서 번역) Custom decorators"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/interceptors\nInterceptors Interceptors interceptor는 @Injectable() 데코레이터로 주석된 클래스이다. interceptor는 NestInterceptor 인터페이스를 구현해야 한다.\ninterceptor는 Aspect Oriented Programming(AOP)에서 영감을 받은 여러가지 기능을 갖고 있다.\n method 수행 전/후 추가 로직을 bind 함수로부터 반환된 값을 변형 함수로부터 throw된 예외를 변형 기본 함수를 확장 특정 조건들에 따라 함수를 완전히 override(e.g, 캐싱)  Basics 각각의 interceptor는 intercept() method를 구현해야하며, 이 함수는 2개의 argument를 받는다. 첫번째는 ExecutionContext 인스턴스(guards에서 받는것과 같음)이다. ExecutionContext는 ArgumentsHost를 상속받았다. ArgumentsHost는 exception filter 챕터에서 이미 보았으며, 거기서 ArgumentsHost는 original handler로 가는 인자들의 wrapper이며, 애플리케이션 타입에 따라 다른 종류의 인자 배열을 포함하고 있음을 보았다. 좀 더 자세한 내용은 exception filters 챕터에서 볼 수 있다.\nExecution context ExecutionContext는 ArgumentsHost를 상속받아 몇개의 helper method를 추가하였다. 이 helper method는 현재 실행중인 프로세스에 몇가지 추가 세부사항을 제공한다. 이 세부사항들은 controller, method, execution context를 가로질러 작동할 수 있는 제네릭 interceptor를 구축하는데 도움을 준다. ExecutionContext에 대해 더 알고 싶으면 여기에서 확인하자.\nCall handler 두번째 인자는 CallHandler이다. CallHandler 인터페이스는 handle() method를 구현한다. handle() method는 특정 시점에서 route handler method를 실행하기 위해 사용된다. 만약 intercept() mehotd에서 handle() method를 호출하지 않으면 route handler method도 실행되지 않는다.이러한 접근법은 intercept() method가 효과적으로 request/response 스트림을 래핑하게 한다. 결과적으로, 최종 route handler 앞/뒤로 custom logic을 구현할 수 있다. intercept() method 내에서 handle()을 호출하기전에 코드를 작성 할 수 있지만, 그 후에는 어떻게 영향을 줄 수 있을까? handle() method는 Observable을 리턴하기때문에, 우리는 RxJS 오퍼레이터를 사용하여 추후에도 response를 가공할 수 있다. AOP 용어를 사용하면, handle()을 호출하여 route handler를 실행하는 것은 Pointcut이라고 부르며, 이것은 우리의 추가 로직이 삽입되는 지점을 가리킨다.예를 들어, POST /cats로 들어오는 request를 생각해보자. 이 request는 CatsController에 정의된 create() handler를 목적지로 지정하고 있다. 도중에 handle() method를 호출하지 않는 interceptor가 호출되었다면, create() method는 실행되지 않을 것이다. handle() method가 호출되면 create() handler는 실행될 것이다. 그리고 response 스트림을 Observable로 받아, 추가적인 오퍼레이션을 수행하고 최종 결과를 caller에게 리턴할 수 있다.\nAspect interception 첫번째 이용사례는 사용자 상호작용을 로깅하기 위해 interceptor를 사용한 것이다.\n// logging.interceptor.ts  import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from \u0026#39;@nestjs/common\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { tap } from \u0026#39;rxjs/operators\u0026#39;; @Injectable() export class LoggingInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u0026lt;any\u0026gt; { console.log(\u0026#39;Before...\u0026#39;); const now = Date.now(); return next .handle() .pipe( tap(() =\u0026gt; console.log(`After... ${Date.now() - now}ms`)), ); } }  [hint]\nNestInterceptor\u0026lt;T, R\u0026gt; 의 T는 Observable의 타입, R은 Observable에 의해 래핑된 값의 타입을 가리킨다.\n  [Notice]\ninterceptor도 controller, provider, guard 등과 마찬가지로, 생성자를 통해 의존성을 주입할 수 있다.\n handle()이 RxJS Observable을 리턴하기 때문에, 스트림을 가공하기 위해 어떠한 오퍼레이터를 사용할지에 대해 많은 선택지를 갖고있다. 위의 예제에서는, tap() 오퍼레이터를 사용하여 observable stream의 정상적 혹은 예외적인 종료시 익명 logging 함수를 실행하였다. 그렇지 않은 경우 response cycle에 방해가 된다.\nBinding interceptors interceptor를 세팅하기 위해서는 @UseInterceptors() 데코리어터를 사용한다. pipe, gaurd와 마찬가지로 interceptor도 controller-scope, method-scope, global-scope 일 수 있다.\n// cats.controller.ts  @UseInterceptors(LoggingInterceptor) export class CatsController {} 위의 예제에서 CatsController에 정의된 각각의 route handler는 LoggingInterceptor를 사용한다. 누군가 GET /cats 엔드포인트를 호출하면, standard ouput에서 아래의 output을 보게 될것이다.\nBefore... After... 1ms LoggingInterceptor 인스턴스가 아닌, LoggingInterceptor 타입을 전달하여 프레임워크가 의존성 주입을 하도록 하였는데, pipe, guard, exception filter와 마찬가지로 인스턴스를 직접 전달할 수도 있다.\n// cats.controllers.ts  @UseInterceptors(new LoggingInterceptor()) export class CatsController {} 앞서 말했듯, 위의 구조에서 해당 controller에 정의된 모든 handler에 interceptor가 붙는다. 단일 method로 interceptor를 제한하고 싶다면 데코레이터를 method level로 적용하면 된다.global interceptor를 사용하기 위해서는 useGlobalInterceptors() method를 사용한다.\nconst app = await NestFactory.create(AppModule); app.useGlobalInterceptors(new LoggingInterceptor()); global interceptor는 애플리케이션 전체를 통해 모든 controller와 route handler에 사용된다. 이 경우 의존성 주입을 통한 것은 아니기때문에, 이를 해결하기 위해서는 module에 직접 interceptor를 세팅한다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { APP_INTERCEPTOR } from \u0026#39;@nestjs/core\u0026#39;; @Module({ providers: [ { provide: APP_INTERCEPTOR, useClass: LoggingInterceptor, }, ], }) export class AppModule {} Response mapping 우리는 이미 handle() method가 Observable을 리턴하는것을 알고 있다. 이 스트림은 route handler로부터 반환된 값을 포함하고 있어서, RxJS map() 오퍼레이터를 사용해 쉽게 변형 가능하다.\n [warning]\nresponse mapping 특성은 library-specific strategy에서는 동작하지 않는다.\n TransformInterceptor를 만들어보자. 이는 각각의 response를 가볍게 수정하여 프로세스를 보여준다. 이것은 RxJS의 map() 오퍼레이터를 사용하여 response 오브젝트를 새로운 오브젝트의 data 프로퍼티에 할당하고, 그 새로운 오브젝트를 클라이언트에 리턴한다.\n// transform.interceptor.ts  import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from \u0026#39;@nestjs/common\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { map } from \u0026#39;rxjs/operators\u0026#39;; export interface Response\u0026lt;T\u0026gt; { data: T; } @Injectable() export class TransformInterceptor\u0026lt;T\u0026gt; implements NestInterceptor\u0026lt;T, Response\u0026lt;T\u0026gt;\u0026gt; { intercept(context: ExecutionContext, next: CallHandler): Observable\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; { return next.handle().pipe(map(data =\u0026gt; ({ data }))); } }  [hint]\nintercept() method는 동기 혹은 비동기일 수 있다.\n 위의 구조에서 GET /cats 엔드포인트가 호출되면, response는 아래와 같은 형태가 될 것이다.\n{ \u0026#34;data\u0026#34;: [] } interceptor는 애플리케이션 전체에 걸쳐 요구사항에 대한 재사용 가능한 해결책을 만들수 있다는 것에서 큰 가치를 가진다. 예를 들어, null 값에 대해 항상 \u0026lsquo;'(빈 string 값)으로 변환하고 싶다고 생각해보자. 우리는 단 한줄의 코드를 전역 interceptor에 사용하여 각각의 handler에 적용할 수 있다.\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from \u0026#39;@nestjs/common\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { map } from \u0026#39;rxjs/operators\u0026#39;; @Injectable() export class ExcludeNullInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u0026lt;any\u0026gt; { return next .handle() .pipe(map(value =\u0026gt; value === null ? \u0026#39;\u0026#39; : value )); } } Exception mapping 또 다른 흥미로운 사용사례는 RxJS의 catchError() 오퍼레이터를 사용한 예외를 override 하는 것이다.\n// errors.interceptor.ts  import { Injectable, NestInterceptor, ExecutionContext, BadGatewayException, CallHandler, } from \u0026#39;@nestjs/common\u0026#39;; import { Observable, throwError } from \u0026#39;rxjs\u0026#39;; import { catchError } from \u0026#39;rxjs/operators\u0026#39;; @Injectable() export class ErrorsInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u0026lt;any\u0026gt; { return next .handle() .pipe( catchError(err =\u0026gt; throwError(new BadGatewayException())), ); } } Stream overriding 가끔 handler의 호출을 완전히 막고 대신해서 다른 값을 리턴해야 하는 경우가 있다. 하나의 명확한 예로 response time을 개선하기 위해 캐시를 구현하는 것이다. 캐시로부터 값을 리턴하는 간단한 cache interceptor를 살펴보자. 실제로는, TTL, cache invalidation, cache size 등등 여러가지 변수를 고려해야 하지만, 이번에는 무시하기로 한다.\n// cache.interceptor.ts  import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from \u0026#39;@nestjs/common\u0026#39;; import { Observable, of } from \u0026#39;rxjs\u0026#39;; @Injectable() export class CacheInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u0026lt;any\u0026gt; { const isCached = true; if (isCached) { return of([]); } return next.handle(); } } 위의 예에서는 isCahced와 리턴값 []를 하드코딩 하였다. 여기서 주요 포인트는 RxJS의 of() 오퍼레이터로 새로운 스트림이 리턴되고, route handler는 호출되지 않았다. 누군가 CacheInterceptor를 사용하는 엔드포인트를 호출하면 하드코딩된 빈 배열이 즉시 response 된다. 제네릭한 솔루션을 만들기 위해, Reflector를 사용하거나 커스텀 데코레이터를 만들 수 있다. Reflector는 Guards챕터에 잘 설명되어 있다.\nMore operators RxJS 오퍼레이터를 사용해 스트림을 조작할 수 있다는 것은 많은 기능을 가져온다. 또 다른 사용사례를 생각해보자. route request에 timeout을 설정하고 싶다고 생각해보자. 특정 시간동안 response를 반환하지 못하면, 대신 에러를 반환할 것이다.\n// timeout.interceptor.ts  import { Injectable, NestInterceptor, ExecutionContext, CallHandler, RequestTimeoutException } from \u0026#39;@nestjs/common\u0026#39;; import { Observable, throwError, TimeoutError } from \u0026#39;rxjs\u0026#39;; import { catchError, timeout } from \u0026#39;rxjs/operators\u0026#39;; @Injectable() export class TimeoutInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u0026lt;any\u0026gt; { return next.handle().pipe( timeout(5000), catchError(err =\u0026gt; { if (err instanceof TimeoutError) { return throwError(new RequestTimeoutException()); } return throwError(err); }), ); }; }; 5초가 지나면, request 프로세스는 종료된다. 또한 RequestTimeoutException을 throw 하기전 커스텀 로직을 추가할 수도 있다.\n","permalink":"https://icecat471.github.io/devlog/post/nestjs/interceptors/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/interceptors\nInterceptors Interceptors interceptor는 @Injectable() 데코레이터로 주석된 클래스이다. interceptor는 NestInterceptor 인터페이스를 구현해야 한다.\ninterceptor는 Aspect Oriented Programming(AOP)에서 영감을 받은 여러가지 기능을 갖고 있다.\n method 수행 전/후 추가 로직을 bind 함수로부터 반환된 값을 변형 함수로부터 throw된 예외를 변형 기본 함수를 확장 특정 조건들에 따라 함수를 완전히 override(e.g, 캐싱)  Basics 각각의 interceptor는 intercept() method를 구현해야하며, 이 함수는 2개의 argument를 받는다.","title":"[NestJS] (공식문서 번역) Interceptors"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/guards\nGuards Guards guard는 @Injectable() 데코레이터로 주석된 클래스이다. 모든 guard는 CanActivate 인터페이스를 구현해야 한다.\nguard는 단일 책임을 갖는다. guard는 런타임 시, 조건(권한, 역할, ACL 등)에 따라 request가 route handler에 의해 수행될지 아닐지를 결정한다. 이것은 종종 authorization을 가리킨다. 전통적인 express 애플리케이션에서 authorization(혹은 authentication)은 미들웨어에서 처리된다. 토큰의 유효성을 검사하고, request 오브젝트에 프로퍼티를 추가할 수 있기때문에 미들웨어에서 인증을 구현하는 것은 좋은 선택이다.그러나 미들웨어는 멍청하다. 미들웨어는 next() 함수의 호출로 어떤 handler가 수행될지 모른다. 반면, guard는 ExecutionContext 인스턴스에 접근해, 다음에 무엇이 수행될지 알 수 있다. exception filter, interceptor, pipe와 유사하게 디자인되어, request/response cycle에서 정확한 지점에 끼어들어 가공로직을 수행한다. 이것은 코드를 더욱 DRY하게 해줄것이다.\n [hint] guard는 각각의 미들웨어 다음에 실행되며, interceptor나 pipe 이전에 실행된다.\n Authorization guard 앞서 말했듯, 특정 router들은 충분한 권한을 가진자가 호출했을 때에만 작동해야 하므로, authorization은 guard의 매우 주요한 이용 사례이다. AuthGuard는 인증된 유저를 가려낸다(request header에 첨부된 토큰을 확인). 이것은 토큰의 유효성을 확인하고, request가 진행될지 아닐지를 결정할 것이다.\n// auth.guard.ts  import { Injectable, CanActivate, ExecutionContext } from \u0026#39;@nestjs/common\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; @Injectable() export class AuthGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise\u0026lt;boolean\u0026gt; | Observable\u0026lt;boolean\u0026gt; { const request = context.switchToHttp().getRequest(); return validateRequest(request); } }  [hint] 여러가지 authentication에 대한 구현 메커니즘에 대해 알고 싶으면 여기를 방문해라. 또한 authorization에 대한 예제들을 보고싶아면 여기를 방문해라.\n validationRequset() 내부의 로직은 간단하거나 필요에 따라 복잡할 수 있다. 이 예제의 주요 포인트는 guard가 request/response cycle에 얼마나 적합한지 보여주기 위함이다.모든 guard는 canActivate() 함수를 구현해야한다. 이 함수는 boolean 함수를 리턴하고, 이는 현재 request가 수락될지 아닐지를 가리킨다. 또한 동기/비동기로 작동할 수 있다. Nest는 리턴값을 다음 액션을 컨틀롤하기 위해 사용한다.\n true를 리턴하면, request는 계속 진행된다. false를 리턴하면, request를 거절한다.  Execution context canActivate() 함수는 ExecutionContext 인스턴스 하나를 argument로 받는다. ExecutionContext는 ArgumentsHost를 상속받는다. ArgumentsHost는 exception filter 챕터에서 보았다. request 오브젝트를 참조하기 위해, ArgumentsHost에 정의된 helper method들을 사용하고 있다.ExecutionContext는 현재 실행중인 프로세스에 대한 정보를 가져오기위해 몇개의 helper method가 추가되었다. 이러한 세부사항은 controller, methods, execution context를 걸쳐 제네릭 guard를 구축하는데 도움이 된다. ExecutionContext에 대해 더 알고싶다면 이곳을 참고하자.\nRole-based authentication 특정 role을 가진 사용자만 허용하는 gaurd를 만들어보자. 기본 guard template에서 시작하여, 이후의 섹션에서 내용을 추가할 것이다.\n// roles.guard.ts  import { Injectable, CanActivate, ExecutionContext } from \u0026#39;@nestjs/common\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; @Injectable() export class RolesGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise\u0026lt;boolean\u0026gt; | Observable\u0026lt;boolean\u0026gt; { return true; } } Binding guards exception filter, pipe처럼 guard도 controller-scope, method-scope, global-scope일 수 있다. 아래에서 @UseGaurd() 데코레이터를 사용하여, controller-scope guard를 세팅하였다. 이 데코레이터는 단일 또는 여러개의 인자를 받을 수 있다.\n@Controller(\u0026#39;cats\u0026#39;) @UseGuards(RolesGuard) export class CatsController {} 위에서 RolesGuard 클래스를 넘겨주었고, 프레임워크에서 이를 인스턴스화 한다. pipe나 exception filter와 마찬가지로 인스턴스를 바로 넘겨줄 수도 있다.\n@Controller(\u0026#39;cats\u0026#39;) @UseGuards(new RolesGuard()) export class CatsController {} 위와 같은 구성은 해당 controller의 모든 handler에 guard가 적용된다. 특정 method에만 적용하고 싶다면, method level에서 @UseGaurds() 데코레이터를 사용하면 된다.global guard를 세팅하기 위해서는, useGlobalGuards() method를 사용한다.\nconst app = await NestFactory.create(AppModule); app.useGlobalGuards(new RolesGuard());  하이브리드 앱에서는 useGlobalGuards() 메서드가 동작하지 않는다.\n global guard는 전체 애플리케이션에서 모든 controller와 모든 route handler에 적용된다. 이 경우 모듈 외부에서 등록되기 때문에 의존성 주입에 의한 것이 아니다. 이를 해결하기 위해서, 아래처럼 모듈에 직접 등록할 수도 있다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { APP_GUARD } from \u0026#39;@nestjs/core\u0026#39;; @Module({ providers: [ { provide: APP_GUARD, useClass: RolesGuard, }, ], }) export class AppModule {} Setting roles per handler RolesGuards가 작동은 하지만, 아직 그렇게 똑똑하지 않다. 아직 우리는 guard의 가장 중요한 특성인 execution context를 사용하지 않았다. CatsController에서 각각의 route는 서로 다른 permission scheme을 갖고 있다. 어떤것은 admin user에게만 유효하며, 또 어떤것은 모든 유저에게 유효하다. 어떻게 route마다 role을 매칭하고, 재사용가능하게 만들 수 있을까?바로 custom metadata가 필요한 때이다(자세한 내용은 이곳에서 확인). Nest는 @SetMetadata() 데코레이터를 통해 route handler에 custom metadata를 붙일 수 있다. 이 메타데이터는 guard에게 role을 제공하여 guard의 의사결정에 도움을 준다.\n@Post() @SetMetadata(\u0026#39;roles\u0026#39;, [\u0026#39;admin\u0026#39;]) async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } 위의 예제에서, create() method에 roles 메타데이터를 붙였다(roles는 key이며 [\u0026lsquo;admin\u0026rsquo;]은 value). 이것은 동작하지만, @SetMetadata()의 좋은 사용법은 아니다. 대신 custom decorator를 만드는 것이 좋다.\n// roles.decorator.ts  import { SetMetadata } from \u0026#39;@nestjs/common\u0026#39;; export const Roles = (...roles: string[]) =\u0026gt; SetMetadata(\u0026#39;roles\u0026#39;, roles); 위의 예제가 더욱 깔끔하고 가독성도 좋으며, 타입이 부여되어 있다. 이제 custom @Roles() 데코레이터를 create() method에 적용해보자.\n// cats.controller.ts  @Post() @Roles(\u0026#39;admin\u0026#39;) async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } Putting it all together 이제 우리의 RolesGuard로 돌아가보자. 지금은 모든 경우에 true를 반환할 것이다. 현재의 route에서 요구하는 role과 현재 유저에게 부여된 role을 비교하여 리턴값을 결정할 것이다. route에 부여된 role(custom metadata)에 접근하기 위해, Reflector helper class를 사용한다.\n// roles.guard.ts  import { Injectable, CanActivate, ExecutionContext } from \u0026#39;@nestjs/common\u0026#39;; import { Reflector } from \u0026#39;@nestjs/core\u0026#39;; @Injectable() export class RolesGuard implements CanActivate { constructor(private reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { const roles = this.reflector.get\u0026lt;string[]\u0026gt;(\u0026#39;roles\u0026#39;, context.getHandler()); if (!roles) { return true; } const request = context.switchToHttp().getRequest(); const user = request.user; return matchRoles(roles, user.roles); } } 더 자세한 정보는 Execution Context 챕터의 Reflection and metadata 섹션을 참고하라.권한을 만족하지 못하는 유저가 엔드포인트로 request를 보낼 경우, Nest는 자동으로 아래의 response를 보낼 것이다.\n{ \u0026#34;statusCode\u0026#34;: 403, \u0026#34;message\u0026#34;: \u0026#34;Forbidden resource\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;Forbidden\u0026#34; } guard는 false를 리턴하고, 프레임워크는 ForbiddenException을 throw 하였다. 만약 다른 response를 보내고 싶은 경우, 아래처럼 원하는 예외를 throw 하면 된다.\nthrow new UnauthorizedException(); guard에 의해 throw된 모든 예외는 exception layer에서 처리된다.\n","permalink":"https://icecat471.github.io/devlog/post/nestjs/guards/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/guards\nGuards Guards guard는 @Injectable() 데코레이터로 주석된 클래스이다. 모든 guard는 CanActivate 인터페이스를 구현해야 한다.\nguard는 단일 책임을 갖는다. guard는 런타임 시, 조건(권한, 역할, ACL 등)에 따라 request가 route handler에 의해 수행될지 아닐지를 결정한다. 이것은 종종 authorization을 가리킨다. 전통적인 express 애플리케이션에서 authorization(혹은 authentication)은 미들웨어에서 처리된다. 토큰의 유효성을 검사하고, request 오브젝트에 프로퍼티를 추가할 수 있기때문에 미들웨어에서 인증을 구현하는 것은 좋은 선택이다.","title":"[NestJS] (공식문서 번역) Guards"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/pipes\nPipe Pipe pipe는 @injectable() 데코레이터로 주석이 된 클래스이다. pipe는 PipeTransform 인터페이스를 구현해야 한다.\npipe는 두가지 사용방법이 있다.\n transformation: input 데이터를 원하는 형태로 변환(예를 들면, string에서 int로). validation: input 데이터가 유효한지 확인하고, 유효하지 않은 경우 예외 발생.  두가지 경우 모두 controller route handler의 argument에 동작한다. Nest는 method가 수행되기전에 끼어들어, pipe가 argument를 먼저 받게 한다. transform이나 validation은 이때 동작한다.Nest는 여러개의 내장 pipe를 갖고 있다. 또한, custom pipe를 만드는 것도 가능하다. 해당 챕터에서는, 내장 pipe에 대한 소개와, route handler에 pipe를 binding하는 방법에 대해 알아 볼 것이다. 그리고 custom pipe를 만드는 법에 대해서도 알아 볼 것이다.\n pipe는 exception zone에서 동작한다. 이것은, pipe가 예외를 throw하면 exception layer에서 처리된다는 뜻이다. 따라서 pipe에서 예외가 발생하면, 뒤에 연결된 method는 동작하지 않는다. 이것은 외부에서 애플리케이션으로 들어오는 데이터에 대해 시스템상으로 처리할 수 있는 가장 좋은 방법을 제공한다.\n Built-in pipes Nest는 6가지의 내장 pipe를 제공한다.\n ValidationPipe ParseIntPipe ParseBoolPipe ParseArrayPipe ParseUUIDPipe DefaultValuePipe  위 pipe들은 @nestjs/common 패키지에 의해 제공된다.ParseIntPipe를 통해 pipe에 대해 알아보자. 이것은 transformation의 예로, pipe는 method handler의 매개변수를 int로 변환해준다(변환 실패시 예외를 throw한다). 챕터 뒤에서, 간단한 custom ParseIntPipe를 볼 것이다. 아래에서 보게 될 예제는, 다른 내장 transformation pipe(ParseBoolPipe, ParseArrayPipe, ParseUUIDPipe)에도 동일하게 적용 될 것이다.\nBinding pipes pipe를 사용하기 위해서는, pipe 인스턴스를 bind 해야 한다. ParseIntPipe 예제에서, pipe를 특정 route handler method와 연관시켜, method가 호출되기전에 작동하게 하고싶다. 아래와 같은 구조로, pipe를 parameter level에서 binding 할 수 있다.\n@Get(\u0026#39;:id\u0026#39;) async findOne(@Param(\u0026#39;id\u0026#39;, ParseIntPipe) id: number) { return this.catsService.findOne(id); } 이것은 다음 두 조건중 하나를 만족함을 보장해준다. findOne()의 파라미터는 number이거나, route handler가 호출되기 전에 예외가 발생한다.예를 들어, router가 아래와 같이 호출 되었다고 가정하면\nGET localhost:3000/abc Nest는 아래와 같은 예외를 throw 할 것이다.\n{ \u0026#34;statusCode\u0026#34;: 400, \u0026#34;message\u0026#34;: \u0026#34;Validation failed (numeric string is expected)\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;Bad Request\u0026#34; } 예외가 발생하면서, findOne()는 수행되지 않는다.위 예제에서, ParseIntPipe 클래스는 프레임워크에 의해 의존성 주입되어 인스턴스화 된다. 대신, 인스턴스를 직접 사용할수도 있다. pipe에 옵션을 추가하고 싶을 때 이러한 방식이 유용하다.\n@Get(\u0026#39;:id\u0026#39;) async findOne( @Param(\u0026#39;id\u0026#39;, new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE })) id: number, ) { return this.catsService.findOne(id); } 다른 transformation pipe도 비슷한 방식으로 동작한다. 이 pipe들은 모두 validating route parameter, query string parameter, request body의 context에서 작동한다.query string paramter에 대한 예제이다.\n@Get() async findOne(@Query(\u0026#39;id\u0026#39;, ParseIntPipe) id: number) { return this.catsService.findOne(id); } 아래는 ParseUUIDPipte를 이용한 예제이다.\n@Get(\u0026#39;:uuid\u0026#39;) async findOne(@Param(\u0026#39;uuid\u0026#39;, new ParseUUIDPipe()) uuid: string) { return this.catsService.findOne(uuid); }  ParseUUIDPipe를 사용하여 uuid 3, 4, 5 버전을 파싱할 때, 특정 버전의 uuid만 요구하도록 옵션을 추가할 수 있다.\n 위에서 다양한 Parse* 내장 pipe(transformation pipe)의 binding을 보았다. validation pipe의 binding은 조금 다르다. 다음 섹션에서 해당 내용을 볼 것이다.\nCustom pipes 위에서 말했듯, custom pipe를 만들수 있다. validation pipe로 시작해보자. 간단하게, 항등함수처럼 input value를 받아 그대로 반환하게 만들었다.\n// validation.pipe.ts  import { PipeTransform, Injectable, ArgumentMetadata } from \u0026#39;@nestjs/common\u0026#39;; @Injectable() export class ValidationPipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { return value; } }  PipeTransform\u0026lt;T, R\u0026gt;은 pipe에서 항상 구현되어야하는 제네릭 인터페이스이다. T는 value의 타입, R은 transform()의 리턴타입이다.\n 모든 pipe는 PipeTransform 인터페이스를 충족하기 위해 transform() method를 구현해야 한다. 이 method는 두개의 매개변수를 받는다.\n value metadata  value는 현재 가공중인 method argument이고, metadata는 현재 가공중인 method argument의 metadata이다. meatadata 오브젝트는 아래와 같은 프로퍼티를 갖는다.\nexport interface ArgumentMetadata { type: \u0026#39;body\u0026#39; | \u0026#39;query\u0026#39; | \u0026#39;param\u0026#39; | \u0026#39;custom\u0026#39;; metatype?: Type\u0026lt;unknown\u0026gt;; data?: string; }          type argument가 body @Body(), query @Query(), param @Param, 또는 custom parameter중 어느 것인지를 가리킨다.   metatype argument의 메타타입을 제공한다(예를 들어, String). route handler method에 타입선언을 생략하거나, 바닐라 자바스크립트 사용시 value는 undefined 이다.   data 데코레이터에서 받은 string(예를 들어 @Body(\u0026lsquo;string\u0026rsquo;)). 데코레이터를 비워두면 undefined 이다.     타입스크립트 인터페이스는 transpilation 도중 사라진다. 따라서, method parameter의 타입이 클래스 대신 인터페이스로 선언되었다면, metadata의 value는 object가 된다.\n Scheme based validation validation pipe를 좀 더 유용하게 만들어보자.\n@Post() async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } body parameter인 createCatDto에 집중해보자. 이것의 타입은 CreateCatDto이다.\n// create-cat.dto.ts  export class CreateCatDto { name: string; age: number; breed: string; } 우리는 create()로 들어오는 어떠한 request도 유효한 body를 갖고있음을 보장하기를 원한다. 따라서 createCatDto 오브젝트는 3개의 멤버를 갖고 있는지 유효성을 검사해야한다. 이것을 route handler method 내부에서 할 수도 있지만, 이것은 SRP(단일 책임 원칙)을 어기는 것이 된다.다른 접근방법은 validator class를 만들어, 유효성 검사를 위임하는 것이다. 이것은 우리가 각 method의 시작부분에 이 validator를 호출해야한다는 단점이 있다.validation 미들웨어를 만드는 것은 어떨까? 동작은 하겠지만, 애플리케이션 내의 모든 context에 적용할 수 있는 제네릭 미들웨어를 만드는 것은 불가능하다.\nObject scheme validation DRY한 방법으로 깔끔하게 object validation을 하는 방법은 여러가지가 있다. 그 중 한가지 일반적인 방법은 scheme-based validation 이다. 이 방법을 사용해보자.joi 라이브러리는 스키마를 간단하게 생성하게 해준다. joi-based 스키마로 validation pipe를 만들어보자.먼저, 아래의 패키지를 설치해야한다.\n$ npm install --save joi $ npm install --save-dev @types/joi 아래의 예제에서, 생성자에서 간단한 스키마 클래스를 만들었다. scheme.validate() method를 통해, 들어오는 argument를 확인할 수 있다.위에서 얘기했듯, validation pipe는 값을 그대로 리턴하거나, 예외를 throw 한다.다음 섹션에서, @UsePipe() 데코레이트를 사용해 컨트롤러에 적절한 스키마를 적용하는 방법에 대해 알아볼 것이다. 그렇게 함으로써, validation pipe를 컨텐스트간 재사용 가능하게 만들것이다.\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from \u0026#39;@nestjs/common\u0026#39;; import { ObjectSchema } from \u0026#39;joi\u0026#39;; @Injectable() export class JoiValidationPipe implements PipeTransform { constructor(private schema: ObjectSchema) {} transform(value: any, metadata: ArgumentMetadata) { const { error } = this.schema.validate(value); if (error) { throw new BadRequestException(\u0026#39;Validation failed\u0026#39;); } return value; } } Binding validation pipes validation pipe를 binding하는 것은 매우 간단하다.method call level에서 pipe를 bind 하기를 원한다. 아래 예제에서, JoiValidationPipe를 사용할 것이다.\n JoiValidationPipe 인스턴스를 만든다. pipe의 생성자를 통해 context-specific joi 스키마를 보낸다. pipe를 method에 bind 한다.  아래처럼 @UsePipe() 데코레이터를 사용한다.\n@Post() @UsePipes(new JoiValidationPipe(createCatSchema)) async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } Class validator  이 섹션의 테크닉은 typescript에서만 유효하다. 바닐라 자바스크립트에서는 유효하지 않다.\n class-validator 라이브러리를 사용한 다른 validation 테크닉을 알아보자. 이 라이브러리는 데코레이터 기반 validation을 할 수 있게 해준다. Nest의 pipe는 metatype에 접근할 수 있기때문에, Nest와 결합되면 데코레이터 기반 validation은 매우 강력해진다. 시작하기전에 해당 패키지를 설치해야 한다.\n$ npm i --save class-validator class-transformer 해당 라이브러리를 설치하면, CreateCatDto에 몇몇 데코레이터를 붙일 수 있다. 이러한 방법의 여러가지 장점을 보게 될 것이다. CreateCatDto는 post body의 유효성 검사를 위한 단일 소스로 사용할 수 있다(여러개의 validation class를 만들지 않아도 된다).\n// create-cat.dto.ts  import { IsString, IsInt } from \u0026#39;class-validator\u0026#39;; export class CreateCatDto { @IsString() name: string; @IsInt() age: number; @IsString() breed: string; } 이제 우리는 ValidationPipe 클래스를 만들 수 있다.\n// validation.pipe.ts  import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from \u0026#39;@nestjs/common\u0026#39;; import { validate } from \u0026#39;class-validator\u0026#39;; import { plainToClass } from \u0026#39;class-transformer\u0026#39;; @Injectable() export class ValidationPipe implements PipeTransform\u0026lt;any\u0026gt; { async transform(value: any, { metatype }: ArgumentMetadata) { if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length \u0026gt; 0) { throw new BadRequestException(\u0026#39;Validation failed\u0026#39;); } return value; } private toValidate(metatype: Function): boolean { const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); } } 위 코드를 살펴보자. 첫쩨로, transform() method는 async이다. 이것은 Nest가 동기, 비동기 pipe를 모두 지원하기 때문에 가능하다. 일부 class validator는 비동기이기 때문에 비동기 방식을 사용할 것이다.(참고:utilize Promises)다음으로, ArgumentMetadata로부터 metatype 필드를 추출한다는 것이다. 이것은 ArgumentMetadata 전체에 대한 요약본이며, metatype 변수에 대한 추가적인 상태를 포함하고 있다.다음으로, class-transformer 함수인 plainToClass()를 사용하고 있다. 이는 자바스크립트 오브젝트에 타입을 부여하여 validation을 하기 위함이다. 또한 네트워크 request를 역직렬화하여 얻은 오브젝트는 타입에 대한 정보가 없기 때문이다. class-validator는 앞서 우리가 dto에 정의한 validation 데코레이터가 필요하다.마지막으로, 앞서 말했듯, validation pipe는 value를 변경하지 않고 그대로 리턴하거나, 예외를 throw 한다.마지막 스텝은 ValidationPipe를 bind 하는 것이다. pipe는 parameter-scope, method-scope, controller-scope 또는 global-scope이다. 앞서 본 joi-based validation pipe는 method level의\u0008에서 binding 된 pipe 였다. 아래의 예제처럼, validation pipe 인스턴스를 route hadler의 @Body() 데코레이터에 bind 할 수 있다.\n// cats.controller.ts  @Post() async create( @Body(new ValidationPipe()) createCatDto: CreateCatDto, ) { this.catsService.create(createCatDto); } parameter-scope pipe는 validation 로직이 하나의 파라미터와만 연관되어 있을 때 유용하다.\nGlobal scoped pipes ValidationPipe는 제네릭으로 만들수 있기때문에, global-scope로 만들어 모든 route handler에 적용할 수 있다.\n// main.ts  async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000); } bootstrap();  [주의] 하이브리드앱에서는 UseGlobalPipes()는 게이트웨이와 마이크로서비스 모두에 적용이 되지 않는다.\n 모듈 외부에서 useGlobalPipes()를 통해 등록된 global pipe는 의존성 주입이 아닌, 모듈 context 외부에서 bind 되어 있다. 이것을 해결하기 위해 global pipe를 모듈에 직접 bind 할 수도 있다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { APP_PIPE } from \u0026#39;@nestjs/core\u0026#39;; @Module({ providers: [ { provide: APP_PIPE, useClass: ValidationPipe, }, ], }) export class AppModule {}  [Hint] 이러한 접근 방식으로 의존성 주입을 한 pipe는 어떠한 모듈에서 생성이 되었듯 global이다.\n The built-in ValidationPipe 내장 ValidationPipe가 Nest에서 제공되기 때문에 제네릭 validation pipe를 직접 만들 필요는 없다. 내장 ValidationPipe는 이 챕터에서 본것보다 더 많은 옵션을 제공하지만, custom pipe의 메커니즘을 설명하기 위한 간단한 예제만 보여주었다. 더 상세한 내용과 예제는 여기에서 볼 수 있다.\nTransformation use case custom pipe는 validation의 경우에만 있는 것은 아니다. 챕터에 시작에서 말했듯, pipe는 input data를 원하는 포맷으로 가공할 수 있다고 하였다. 이것은 transform() 함수에서 리턴되는 값은 기존 argument 값을 덮어쓰기 때문에 가능하다.이것은 언제 유용할까? 종종 클라이언트로부터 받은 데이터는 router handler method에서 처리되기전에 가공될 필요가 있다(예를 들어, string에서 integer로 변환). 또한, 일부 필수 필드가 없는 경우 기본값을 제공해야 하는 경우도 있다. transformation pipe는 client request와 request handler 사이에서 이런 역할을 한다.아래는 string을 int로 바꿔주는 간단한 예제이다. (위에서 말했듯, Nest가 제공하는 내장 pipe가 더 세련되었지만, custom pipe의 간단한 예제를 보여주기 위해 포함하였다)\n// parse-int.pipe.ts  import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from \u0026#39;@nestjs/common\u0026#39;; @Injectable() export class ParseIntPipe implements PipeTransform\u0026lt;string, number\u0026gt; { transform(value: string, metadata: ArgumentMetadata): number { const val = parseInt(value, 10); if (isNaN(val)) { throw new BadRequestException(\u0026#39;Validation failed\u0026#39;); } return val; } } pipe는 아래와 같은 방법으로 특정 파라미터에 bind 할 수 있다.\n@Get(\u0026#39;:id\u0026#39;) async findOne(@Param(\u0026#39;id\u0026#39;, new ParseIntPipe()) id) { return this.catsService.findOne(id); } 또 다른 transformation의 좋은 예는, request에서 id를 받아 데이터베이스로부터 존재하는 사용자를 가져오는 경우이다.\n@Get(\u0026#39;:id\u0026#39;) findOne(@Param(\u0026#39;id\u0026#39;, UserByIdPipe) userEntity: UserEntity) { return userEntity; } 위와 같은 경우, input value로 id를 받지만 return value는 UserEntity 오브젝트 이다. 이것은 pipe를 통해 handler 외부에서 반복되는 코드를 줄여, 코드를 더욱 DRY하게 만드는 방법이다.\nProviding defaults Parse* pipe들은 파라미터가 정의되어 있기를 기대한다. null 또는 undefined를 받으면 예외를 throw 할 것이다. 생략된 query string value를 처리하기 위해서는, 미리 기본값을 주입해두어야 한다. DefaultValuePipe가 이러한 역할을 수행한다.\n@Get() async findAll( @Query(\u0026#39;activeOnly\u0026#39;, new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean, @Query(\u0026#39;page\u0026#39;, new DefaultValuePipe(0), ParseIntPipe) page: number, ) { return this.catsService.findAll({ activeOnly, page }); } ","permalink":"https://icecat471.github.io/devlog/post/nestjs/pipe/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/pipes\nPipe Pipe pipe는 @injectable() 데코레이터로 주석이 된 클래스이다. pipe는 PipeTransform 인터페이스를 구현해야 한다.\npipe는 두가지 사용방법이 있다.\n transformation: input 데이터를 원하는 형태로 변환(예를 들면, string에서 int로). validation: input 데이터가 유효한지 확인하고, 유효하지 않은 경우 예외 발생.  두가지 경우 모두 controller route handler의 argument에 동작한다. Nest는 method가 수행되기전에 끼어들어, pipe가 argument를 먼저 받게 한다. transform이나 validation은 이때 동작한다.","title":"[NestJS] (공식문서 번역) Pipe"},{"content":"참고: https://cli.vuejs.org/guide/mode-and-env.html\nmode vue-cli에서는 기본적으로 3가지 모드가 있다.\n development: vue-cli-service serve test: vue-cli-service test:unit production: vue-cli-service build 또는 vue-cli-service test:e2e   또는 \u0026ndash;mode 옵션을 전달하여 기본모드를 덮어 쓸 수 있다.\nvue-cli-service build --mode dev 환경변수 프로젝트 루트에 다음 파일을 추가하여 환경변수 지정 가능\n.env # loaded in all cases .env.local # loaded in all cases, ignored by git .env.[mode] # only loaded in specified mode .env.[mode].local # only loaded in specified mode, ignored by git  주의할점\nvue에서는 NODE_ENV, BASE_URL 또는 VUE_APP_ 으로 시작하는 변수만 불러올 수 있음.\n=\u0026gt; 그 외의 경우 불러오면 undefined로 나왔던 것\n ","permalink":"https://icecat471.github.io/devlog/post/vuejs/dotenv_undefined/","summary":"참고: https://cli.vuejs.org/guide/mode-and-env.html\nmode vue-cli에서는 기본적으로 3가지 모드가 있다.\n development: vue-cli-service serve test: vue-cli-service test:unit production: vue-cli-service build 또는 vue-cli-service test:e2e   또는 \u0026ndash;mode 옵션을 전달하여 기본모드를 덮어 쓸 수 있다.\nvue-cli-service build --mode dev 환경변수 프로젝트 루트에 다음 파일을 추가하여 환경변수 지정 가능\n.env # loaded in all cases .env.local # loaded in all cases, ignored by git .env.[mode] # only loaded in specified mode .env.[mode].local # only loaded in specified mode, ignored by git  주의할점","title":"[Vue] dotenv 환경변수를 undefined로 불러올 때"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/exception-filters\nException filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.\n특히, 이것은 \u0008HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.\n{ \u0026#34;statusCode\u0026#34;: 500, \u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34; } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다. 일반적인 HTTP REST/GraphQL API 기반의 애플리케이션에서 특정 에러가 발생했을 때, 표준 HTTP response object를 보내는 것이 좋은 방법이다.예를 들어, CatsController에 findAll() method를 정의하였다. 이 route handler가 어떠한 이유에 의해 예외를 throw 했다고 가정해보자.\n// cats.controller.ts  @Get() async findAll() { throw new HttpException(\u0026#39;Forbidden\u0026#39;, HttpStatus.FORBIDDEN); } 클라이언트가 이 엔드포인트를 호출하면, 아래와 같은 응답이 전송될 것이다.\n{ \u0026#34;statusCode\u0026#34;: 403, \u0026#34;message\u0026#34;: \u0026#34;Forbidden\u0026#34; } HttpException class의 생성자는 두 개의 인자를 필수로 받는다.\n JSON response body를 정의하는데 필요한, string 또는 object 타입. HTTP status code로 정의된 status.  기본적으로 JSON response body는 두개의 property로 구성된다.\n statusCode: 기본적으로 status 인자로 받은 HTTP status code 값. message: status에 따른 짧은 HTTP 에러에 대한 메세지  message만을 override 하기 위해서는 response 인자에 string 값을 전달하면 된다. 전체 JSON body를 override 하려면 response 인자로 object를 전달한다. Nest는 object를 직렬화하여 JSON body로 변환할 것이다.2번째 인자인 status는 유효한 HTTP status code 이어야 한다. 가장 좋은 방법은 HttpStatus enum을 사용하는 것이다.\n// cats.controller.ts  @Get() async findAll() { throw new HttpException({ status: HttpStatus.FORBIDDEN, error: \u0026#39;This is a custom message\u0026#39;, }, HttpStatus.FORBIDDEN); } 위의 예제는 아래와 같은 response를 전송할 것이다.\n{ \u0026#34;status\u0026#34;: 403, \u0026#34;error\u0026#34;: \u0026#34;This is a custom message\u0026#34; } Custom Exceptions 많은 경우, custom exception을 사용하는 대신, Nest HTTP exception을 사용하면 된다. 만약 custom exception이 필요한 경우 HttpException 클래스를 상속받아 exception hierarchy를 만드는 것이 좋다. 이러한 접근법을 사용하면 Nest는 custom exception을 인식하고 자동으로 관리해 줄 것이다.\n// forbidden.exception.ts  export class ForbiddenException extends HttpException { constructor() { super(\u0026#39;Forbidden\u0026#39;, HttpStatus.FORBIDDEN); } } 기본 HttpException을 상속했기때문에 내장 exception handler에 의해 같은 방식으로 동작한다.\n// cats.controller.ts  @Get() async findAll() { throw new ForbiddenException(); } Built-in HTTP Exceptions Nest는 HttpException class를 상속받은 standard exception 세트를 제공한다.\n BadRequestException UnauthorizedException NotFoundException ForbiddenException NotAcceptableException RequestTimeoutException ConflictException GoneException HttpVersionNotSupportedException PayloadTooLargeException UnsupportedMediaTypeException UnprocessableEntityException InternalServerErrorException NotImplementedException ImATeapotException MethodNotAllowedException BadGatewayException ServiceUnavailableException GatewayTimeoutException PreconditionFailedException  Exception filters 내장 exception filter에 의해 대부분의 예외가 자동으로 핸들링 되지만, exception layer를 컨트롤 하고 싶은 경우가 생긴다. 예를 들어, 로그를 추가하거나 기본 JSON 형태를 변경하고 싶은 경우이다. exception filter는 이러한 목적을 위해 디자인 되었다. 이것들은 올바른 흐름통제와 response의 콘텐츠를 제공해준다.HttpException class의 예외를 캐치하는 exception filter를 만들어보자. 이것을 위해 우리는 platform 기반의 request와 response object에 접근할 필요가 있다. 우리는 request object에 접근하여 original url을 사용하여 로그를 남길것이다. response object는 직접 컨트롤하여 response.json() method를 통해 전송할 것이다.\n// http-exception.filter.ts  import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from \u0026#39;@nestjs/common\u0026#39;; import { Request, Response } from \u0026#39;express\u0026#39;; @Catch(HttpException) export class HttpExceptionFilter implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse\u0026lt;Response\u0026gt;(); const request = ctx.getRequest\u0026lt;Request\u0026gt;(); const status = exception.getStatus(); response .status(status) .json({ statusCode: status, timestamp: new Date().toISOString(), path: request.url, }); } }  모든 exception filter는 ExceptionFilterinterface를 구현해야한다. 이를 통해 catch(exception: T, host: ArgumentsHost) method를 제공받는다.\n @Catch(HttpException) 데코레이터는 exception filter에 필요한 메타데이터를 bind하고 있어서 Nest에게 특정 filter가 HttpException임을 알려준다. @Catch() 데코레이터는 단일 혹은 콤마로 구분된 여러개의 인자를 받는다. 이를 통해 여러가지 예외를 필터에 적용할 수 있다.\nArguments host catch() method를 살펴보자. exception 파라미터는 현재 처리되고 있는 예외이다. host parameter는 ArgumentsHost obejct이다. ArgumentHost는 execution context 챕터에서 자세히 알아보자. 위의 예제에서는 request와 response object의 참조값을 얻기 위해 사용되었다.\nBinding filters 새로 만든 HttpExceptionFilter를 CatsController에 적용해보자.\n// cats.controller.ts  @Post() @UseFilters(new HttpExceptionFilter()) async create(@Body() createCatDto: CreateCatDto) { throw new ForbiddenException(); } @UseFilter() 데코레이터는 @Catch() 데코레이터와 유사하게, 단일 filter 인스턴스 또는 여러개의 filter 인스턴스 리스트를 받는다. 위의 예제에서는 새로운 HttpExceptionFilter 인스턴스를 만들어서 넣어주었다. 인스턴스 대신, 클래스를 넣어도 dependency injection에 의해 인스턴스화 된다.\n// cats.controller.ts  @Post() @UseFilters(HttpExceptionFilter) async create(@Body() createCatDto: CreateCatDto) { throw new ForbiddenException(); }  가능하면 인스턴스를 넣는것보다 클래스를 넣자. 그러면 Nest는 같은 클래스의 인스턴스를 다른 모듈에서 재사용하여 메모리낭비를 줄일 수 있다.\n 위 예제에서, HttpExceptionFilter는 method-scope로 하나의 create() route handler에만 적용되었다. Exception filter는 다른 scope로 적용가능하다(method-scope, controller-scope, global-scope 등). 예를 들어, filter를 controller-scope로 적용하고 싶다면 아래의 예제처럼 하면 된다.\n// cats.controller.ts  @UseFilters(new HttpExceptionFilter()) export class CatsController {} 이러한 구조는 \u0008HttpExceptionFilter를 CatsController 내의 모든 route handler에 정의해준다.global-scope로 적용하기 위해서는, 아래의 예제처럼 적용한다.\n// app.module.ts  async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000); } bootstrap();  useGlobalFilters() method는 gateway나 hybrid application에 적용되지 않는다.\n global-scope filter는 모든 controller와 route handler에 적용된다. module 외부에서 등록된 global filter(위의 예제처럼, useGlobalFilters()를 적용하는 경우)는 module context 외부에서 완료되기 때문에 dependency를 주입할 수 없다. 이것을 해결하기 위해, global-scope filter를 직접 module에 등록할 수 있다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { APP_FILTER } from \u0026#39;@nestjs/core\u0026#39;; @Module({ providers: [ { provide: APP_FILTER, useClass: HttpExceptionFilter, }, ], }) export class AppModule {}  DI를 위해 이러한 접근법을 사용하면, 어떠한 module에서 사용되었든 filter는 global이다.\n 위와 같은 방법으로 array 형태의 여러개의 filter를 등록가능하다.\nCatch everything 모든 예외를 핸들링하고 싶다면, @Catch() 데코레이터의 인자를 비워두면 된다.\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus, } from \u0026#39;@nestjs/common\u0026#39;; @Catch() export class AllExceptionsFilter implements ExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); const request = ctx.getRequest(); const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; response.status(status).json({ statusCode: status, timestamp: new Date().toISOString(), path: request.url, }); } } 위의 에제에서 filter는 예외의 타입에 관계없이 모든 예외를 처리한다.\nInheritance 일반적으로, 애플리케이션의 요구사항에 충족하는 완전히 커스터마이징 된 filter를 만들것이다. 그러나, 내장된 기본 global exception filter를 상속하여 일부분을 override하여 사용할 수도 있다.base filter를 이용하려면, BaseExceptionFilter를 상속받고, 상속받은 catch() method를 호출한다.\n// all-exception.filter.ts  import { Catch, ArgumentsHost } from \u0026#39;@nestjs/common\u0026#39;; import { BaseExceptionFilter } from \u0026#39;@nestjs/core\u0026#39;; @Catch() export class AllExceptionsFilter extends BaseExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { super.catch(exception, host); } }  BaseExceptionFilter를 상속받은 method-scope filter와 controller-scope filter는 new를 통해 인스턴스화 하면 안된다. 대신, 프레임워크가 자동으로 인스턴스화 할 것이다.\n global filter도 base filter를 상속받을 수 있다. 이것에는 두가지 방법이 있다.첫번째 방법은, custom global filter가 인스턴스화 될 때, http server에 injection 하는 방법이다.\nasync function bootstrap() { const app = await NestFactory.create(AppModule); const { httpAdapter } = app.get(HttpAdapterHost); app.useGlobalFilters(new AllExceptionsFilter(httpAdapter)); await app.listen(3000); } bootstrap(); 두번째 방법은, 여기에서 설명한 것처럼 APP_FILTER를 사용하는 것이다.\n","permalink":"https://icecat471.github.io/devlog/post/nestjs/exception_filters/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/exception-filters\nException filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.\n특히, 이것은 \u0008HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.\n{ \u0026#34;statusCode\u0026#34;: 500, \u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34; } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다.","title":"[NestJS] (공식문서 번역) Exception Filters"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/middleware\nMiddleware Middelware middleware는 route handler 이전에 호출되는 함수이다. middleware는 request와 response object에 접근할 수 있으며, 애플리케이션의 request-response cycle 내에서 next() 함수에도 접근할 수 있다.\nNest middleware는 기본적으로 express middleware와 같다. 아래는 express 공식문서에 나와있는 express middleware의 특징이다.\n 어떠한 코드도 실행한다. request와 response object를 변형한다. request-response cycle을 끝낸다. stack에서 다음 middleware를 호출한다. 현재 middleware가 request-reponse cycle을 끝내지 못하면, next() 함수를 통해 다음 middleware를 호출한다.   함수나 @Injectable() 데코레이터를 사용한 class로 Nest custom middleware를 구현할 수 있다. 함수는 특별한 요구사항이 없지만, class는 NestMiddleware interface를 implements 해야한다.\n// logger.middleware.ts  import { Injectable, NestMiddleware } from \u0026#39;@nestjs/common\u0026#39;; import { Request, Response, NextFunction } from \u0026#39;express\u0026#39;; @Injectable() export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log(\u0026#39;Request...\u0026#39;); next(); } } Dependency injection Nest middleware는 dependency injection을 지원한다. controller나 provider와 마찬가지로 생성자를 통해 의존성을 주입할 수 있다.\nApplying middleware @Module() 데코레이터 인자에는 middleware를 받는 부분이 없다. 대신, module class에 configure() method를 사용하여 적용한다. middleware를 포함하는 module은 NestModule interface를 implements해야 한다.\n// app.module.ts  import { Module, NestModule, MiddlewareConsumer } from \u0026#39;@nestjs/common\u0026#39;; import { LoggerMiddleware } from \u0026#39;./common/middleware/logger.middleware\u0026#39;; import { CatsModule } from \u0026#39;./cats/cats.module\u0026#39;; @Module({ imports: [CatsModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes(\u0026#39;cats\u0026#39;); } } 위 예제에서 LoggerMiddleware를 /cats route handler에 적용시켰다. 또한 path와 method를 가진 오브젝트를 forRoutes()의 인자로 받아 http method도 제한 가능히다. 아래의 예제처럼 RequestMethod enum을 사용하는 것을 추천한다.\n// app.module.ts  import { Module, NestModule, RequestMethod, MiddlewareConsumer } from \u0026#39;@nestjs/common\u0026#39;; import { LoggerMiddleware } from \u0026#39;./common/middleware/logger.middleware\u0026#39;; import { CatsModule } from \u0026#39;./cats/cats.module\u0026#39;; @Module({ imports: [CatsModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes({ path: \u0026#39;cats\u0026#39;, method: RequestMethod.GET }); } }  configure() method는 async/await를 사용해 비동기로 만들수 있다.\n Route wildcards wildcard로 별표(*)를 사용한 패턴도 제공한다.\n@Get(\u0026#39;ab*cd\u0026#39;) findAll() { return \u0026#39;This route uses a wildcard\u0026#39;; } 'ab*cd' route path는 abcd, ab_cd, abecd등과 match된다. ?, +, *, () 같은 문자도 정규식의 부분으로 route path에 사용가능하다. '-', '.'은 string기반 path에 의해 문자 그대로 번역된다.\n fastify는 최신버전의 path-to-regexp 패키지를 사용하는데, 이 패키지는 더이상 *을 와일드카드로 지원하지 않는다. 대신, parameter를 사용한다(e.g, (.*), :splat*).\n Middleware consumer middleware consumer는 helper class이다. 이것은 middleware를 관리하는 method들을 제공하며, fluent style chain으로 구성되어 있다. forRoutes() method는 단일 string, 여러개의 string, RouteInfo 오브젝트, 하나의 controller, 여러개의 controller 클래스를 인자로 받을 수 있다. 대부분의 경우 controller의 목록을 콤마(,)로 구분한다. 아래는 단일 controller의 예제이다.\n// app.module.ts  import { Module, NestModule, MiddlewareConsumer } from \u0026#39;@nestjs/common\u0026#39;; import { LoggerMiddleware } from \u0026#39;./common/middleware/logger.middleware\u0026#39;; import { CatsModule } from \u0026#39;./cats/cats.module\u0026#39;; import { CatsController } from \u0026#39;./cats/cats.controller.ts\u0026#39;; @Module({ imports: [CatsModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes(CatsController); } }  apply() method는 단일 middleware 또는 여러개의 middleware를 인자로 받을 수 있다. (multiple middleware)\n Excluding routes 특정 route만 middleware 적용에서 제외하고 싶은 경우가 있다. exclude() method를 사용해 특정 route를 제외할 수 있다. 해당 method는 단일 string, 여러개의 string, RouteInfo 오브젝트를 인자로 받을 수 있다.\nconsumer .apply(LoggerMiddleware) .exclude( { path: \u0026#39;cats\u0026#39;, method: RequestMethod.GET }, { path: \u0026#39;cats\u0026#39;, method: RequestMethod.POST }, \u0026#39;cats/(.*)\u0026#39;, ) .forRoutes(CatsController);  exclude() method는 path-to-regexp 패키지를 적용해, whildcard parameter를 지원한다.\n Functional middleware 위에서 본 LoggerMiddleware는 멤버변수, 추가 method, 의존성도 없이 심플하다. 이렇게 심플한 경우는 함수형 middleware로 정의 가능하다. LoggerMiddleware를 함수형으로 변경해보자.\n// logger.middleware.ts  import { Request, Response, NextFunction } from \u0026#39;express\u0026#39;; export function logger(req: Request, res: Response, next: NextFunction) { console.log(`Request...`); next(); }; Multiple middleware 위에서 언급했듯이, 여러개의 middleware를 bind하기 위해서는 apply() method에 콤마(,)로 구분하여 리스트로 제공할 수 있다.\nconsumer.apply(cors(), helmet(), logger).forRoutes(CatsController); Global middleware 모든 route에 한번에 middleware를 bind하고 싶을 때에는, \u0008INestApplication 인스턴스에서 제공하는 use() method를 통해 등록가능하다.\nconst app = await NestFactory.create(AppModule); app.use(logger); await app.listen(3000);  global middleware에서 DI container에 접근하는 것은 불가능히다. app.use()를 사용하는 대신 함수형 middleware를 사용할 수 있다. 또는 class middleware를 AppModule(또는 다른 module)에 .forRoutes('*')을 사용하여 등록할 수 있다.\n ","permalink":"https://icecat471.github.io/devlog/post/nestjs/middleware/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/middleware\nMiddleware Middelware middleware는 route handler 이전에 호출되는 함수이다. middleware는 request와 response object에 접근할 수 있으며, 애플리케이션의 request-response cycle 내에서 next() 함수에도 접근할 수 있다.\nNest middleware는 기본적으로 express middleware와 같다. 아래는 express 공식문서에 나와있는 express middleware의 특징이다.\n 어떠한 코드도 실행한다. request와 response object를 변형한다. request-response cycle을 끝낸다. stack에서 다음 middleware를 호출한다. 현재 middleware가 request-reponse cycle을 끝내지 못하면, next() 함수를 통해 다음 middleware를 호출한다.","title":"[NestJS] (공식문서 번역) Middleware"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/providers\nModules Modules module class는 @Module 데코레이터로 선언된다. @Module 데코레이터는 Nest가 애플리케이션 구조를 조직하기 위해 사용하는 메타데이터를 붙여준다.\n각각의 애플리케이션은 적어도 root module이라고 불리는 하나의 module을 갖는다. root module은 Nest가 애플리케이션그래프(Nest가 module과 provider의 관계들과 의존성을 결정하는데 사용하는 내부 데이터 구조)를 빌드하기 위해 사용하는 시작점이다. 보통 매우 작은 규모의 애플리케이션은 root module 단 하나만 갖는 경우도 있지만, 이러한 경우는 일반적이지는 않다. Nest에서는 component를 구성하는데 module을 사용할 것을 강력하게 권장한다. 따라서, 대부분의 애플리케이션은 여러개의 module을 갖는 구조이다.@Module() 데코레이터는 아래의 property들을 갖는 하나의 오브젝트를 인자로 받는다.         providers provider는 Nest injector에 의해 인스턴스화 되고, 최소한 이 module안에서 공유된다.   controllers 이 module에서 인스턴스화 될 controller의 set   imports 이 module에 필요한 provider들을 export하는 module의 리스트   exports 다른 module에서 사용할 수 있도록 이 module에서 제공하는 provider의 subset    module은 provider를 캡슐화한다. 이것은 현재 module의 part가 아니거나, import된 module에서 export되자 않은 provider는 injection 할 수 없다는 의미이다. 따라서 module에서 제공하는 public interface(또는 API)를 고려해야 한다.\nFeature modules CatsService와 CatsController는 같은 도메인에 속해있다. 이 둘은 크게 관련되어 있고 따라서 feature module로 옮기는 것이 타당하다. feature module은 특정한 특성을 가진 코드를 관련성에 의해 조직하고, 명확한 경계를 구축한다. 이는 우리가 SOLID 원칙에 따라 개발을 할 수 있게 도와준다.아래처럼 CatsModule을 만들었다.\n// cats/cats.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats.controller\u0026#39;; import { CatsService } from \u0026#39;./cats.service\u0026#39;; @Module({ controllers: [CatsController], providers: [CatsService], }) export class CatsModule {} 위처럼 cats.module.ts 파일에 CatsModule을 정의하고 관련된 파일들을 cats 디렉토리로 이동시켰다. 추가로 CatsModule을 root module에 등록한다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsModule } from \u0026#39;./cats/cats.module\u0026#39;; @Module({ imports: [CatsModule], }) export class AppModule {} 따라서 디렉토리 구조가 아래처럼 변경되었다.\nsrc | +-- cats | | | +-- dto | | | | | +-- create-cat.dto.ts | | | +-- interfaces | | | | | +-- cat.interface.ts | | | +-- cats.controller.ts | | | +-- cats.module.ts | | | +-- cats.service.ts | +-- app.module.ts | +-- main.ts Shared modules Nest에서 module은 기본적으로 singleton이다. 따라서 여러 module간 같은 provider 인스턴스를 공유하여 사용할 수 있다.\n모든 module은 자동으로 shared module이 된다. 한번 생성되면 다른 module들에 의해 재사용 된다. CatsService 인스턴스를 다른 여러개의 module간에 공유하고싶다고 해보자. 이것을 위해 먼저 module의 export 배열에 CatsService를 추가하여 export 해주어야 한다.\n// cats.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats.controller\u0026#39;; import { CatsService } from \u0026#39;./cats.service\u0026#39;; @Module({ controllers: [CatsController], providers: [CatsService], exports: [CatsService] }) export class CatsModule {} 이제 CatModule을 import하는 module에서는 CatsService에 접근하고 다른 module과 CatService 인스턴스를 공유하게 되었다.\nModule re-exporting 위에서 보았듯, module은 내부의 provider를 export 할 수 있다. 또한 외부에서 import한 module을 re-export 할 수 있다. 아래 예제처럼, CatsModule은 import 되고 export 되어 CoreModule을 import 하는 다른 module에서 사용할 수 있게 되었다.\n@Module({ imports: [CommonModule], exports: [CommonModule], }) export class CoreModule {} Dependency injection module class 역시 provider를 injection 받을 수 있다.\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats.controller\u0026#39;; import { CatsService } from \u0026#39;./cats.service\u0026#39;; @Module({ controllers: [CatsController], providers: [CatsService], }) export class CatsModule { constructor(private catsService: CatsService) {} } 그러나, module 클래스끼리 서로 provider로써 injection 될 수 없다. 이것은 circular dependency 때문이다.\nGlobal modules 같은 module set를 모든곳에 import 할 수 있지만, 이것은 좋은 방법은 아니다. Angular 에서는 provider는 전역으로 등록된다. Nest에서는 provider는 module scope로 캡슐화 된다. 따라서 module을 import 하지 않으면 module의 provider를 사용할 수 없다.모든곳에서 전역으로 module을 사용하고 싶으면 @Global() 데코레이터를 사용할 수 있다.\nimport { Module, Global } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats.controller\u0026#39;; import { CatsService } from \u0026#39;./cats.service\u0026#39;; @Global() @Module({ controllers: [CatsController], providers: [CatsService], exports: [CatsService], }) export class CatsModule {} @Global() 데코레이터는 module을 global-scope로 만들어준다. global module은 root module 또는 core module에 의해 단 한번만 등록되어야 한다. 위 예제의 CatsModule은 import하지 않고 어디에서나 injection 될 수 있다.\n 모든 module을 global로 만드는 것은 좋은 디자인이 아니다. global module은 반복되는 코드를 줄이기 위해 사용된다. 그러나 imports 배열을 만들어 API를 사용가능하게 만드는 것이 일반적이다.\n Dynamic modules Nest module system은 dynamic modules라는 강력한 특성을 갖고 있다. 이 특성은 provider를 동적으로 등록하고 설정할 수 있는 커스터마이징 가능한 module을 쉽게 만들 수 있게 해준다. dynamic modules에 관한 상세한 설명은 여기에서 볼 수 있다.아래는 dynamic module를 정의하는 예제이다.\nimport { Module, DynamicModule } from \u0026#39;@nestjs/common\u0026#39;; import { createDatabaseProviders } from \u0026#39;./database.providers\u0026#39;; import { Connection } from \u0026#39;./connection.provider\u0026#39;; @Module({ providers: [Connection], }) export class DatabaseModule { static forRoot(entities = [], options?): DynamicModule { const providers = createDatabaseProviders(options, entities); return { module: DatabaseModule, providers: providers, exports: providers, }; } }  forRoot() method는 dynamic module을 동기 혹은 비동기로 반환한다.\n 이 module은 Connection provider를 정의하고 있다. 그러나 추가로, forRoot() method를 통해 provider 콜렉션을 노출하고 있다(예를 들어 repository). dynamic module은 @Module() 데코레이터에 정의된 기본 module의 메타데이터를 확장하여 리턴된다.만약 dynamic module을 전역으로 사용하고 싶으면 global 프로퍼티를 true로 설정한다.\n{ global: true, module: DatabaseModule, providers: providers, exports: providers, } DatabaseModule은 아래와 같은 방법으로 설정하고 import 할 수 있다.\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { DatabaseModule } from \u0026#39;./database/database.module\u0026#39;; import { User } from \u0026#39;./users/entities/user.entity\u0026#39;; @Module({ imports: [DatabaseModule.forRoot([User])], }) export class AppModule {} dynamic module을 re-export 할 때에는 forRoot() method는 생략한다.\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { DatabaseModule } from \u0026#39;./database/database.module\u0026#39;; import { User } from \u0026#39;./users/entities/user.entity\u0026#39;; @Module({ imports: [DatabaseModule.forRoot([User])], exports: [DatabaseModule], }) export class AppModule {} ","permalink":"https://icecat471.github.io/devlog/post/nestjs/modules/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/providers\nModules Modules module class는 @Module 데코레이터로 선언된다. @Module 데코레이터는 Nest가 애플리케이션 구조를 조직하기 위해 사용하는 메타데이터를 붙여준다.\n각각의 애플리케이션은 적어도 root module이라고 불리는 하나의 module을 갖는다. root module은 Nest가 애플리케이션그래프(Nest가 module과 provider의 관계들과 의존성을 결정하는데 사용하는 내부 데이터 구조)를 빌드하기 위해 사용하는 시작점이다. 보통 매우 작은 규모의 애플리케이션은 root module 단 하나만 갖는 경우도 있지만, 이러한 경우는 일반적이지는 않다.","title":"[NestJS] (공식문서 번역) Modules"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/providers\nProviders Providers provider는 Nest에서 가장 근본적인 개념이다. 대부분의 기본 Nest class는 provider로 취급된다(예를 들어, service, repository, factory, helper 등등). provider는 의존성을 주입할 수 있다. 이것은 오브젝트간의 서로 다양한 관계들을 만들 수 있음을 뜻한다.\n앞선 챕터에서, 우리는 CatsController를 만들었고, controller는 HTTP request를 핸들링하고 복잡한 일을 provider에게 맡긴다.\nServices 간단한 CatsService를 만들어보자. 이 service는 데이터를 저장하고 불러오는 역할을 담당할 것이며, CatsController가 이를 시용할 것이다.\n// cats.service.ts  import { Injectable } from \u0026#39;@nestjs/common\u0026#39;; import { Cat } from \u0026#39;./interfaces/cat.interface\u0026#39;; @Injectable() export class CatsService { private readonly cats: Cat[] = []; create(cat: Cat) { this.cats.push(cat); } findAll(): Cat[] { return this.cats; } } @Injectable() 데코레이터는 CatService가 Nest IoC container에 의해 관리될 수 있게 메타데이터를 붙여준다. 또한 예제에서는 Cat interface를 사용중이다.\n// interfaces/cat.interface.ts  export interface Cat { name: string; age: number; breed: string; } 위에서 만든 service를 CatController에서 사용해보자.\n// cat.controller.ts  import { Controller, Get, Post, Body } from \u0026#39;@nestjs/common\u0026#39;; import { CreateCatDto } from \u0026#39;./dto/create-cat.dto\u0026#39;; import { CatsService } from \u0026#39;./cats.service\u0026#39;; import { Cat } from \u0026#39;./interfaces/cat.interface\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { constructor(private catsService: CatsService) {} @Post() async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } @Get() async findAll(): Promise\u0026lt;Cat[]\u0026gt; { return this.catsService.findAll(); } } CatService는 생성자를 통해 injection 되었다. private를 붙여줌으로써 선언과 초기화를 동시에 실행한다.\nDependency injection Nest는 Dependency Injection(DI)라고 알려진 디자인 패턴을 적용하고 있다. Angular 공식 문서에서 이러한 개념에 대해 읽어보기를 추천한다. Nest에서는 TypeScript를 사용하는 이점으로 타입을 통해 쉽게 의존성을 관리할 수 있다. 아래의 예제처럼 Nest는 CatsService의 인스턴스를 생성하고 반환함으로써 catsService를 의존성을 주입한다(대부분의 경우는 singleton으로 이미 다른곳에서 요청되었다면 이미 존재하는 인스턴스를 반환한다). 이러한 의존성은 controller의 생성자를 통해 주입된다.\nconstructor(private catsService: CatsService) {} Scopes provider는 일반적으로 애플리케이션의 lifecycle과 일치하는 lifecycle(\u0026ldquo;scopes\u0026rdquo;)를 갖는다. 애플리케이션이 동작하면, 의존성이 주입되고, 모든 provider가 인스턴스화 된다. 애플리케이션이 종료되면, 각각의 provider들은 파괴된다. 그러나, provider의 lifecycle을 requested-scope로 만들수도 있다. 이러한 방법에 대해서는 이 곳에서 읽어볼 수 있다.\nCustom providers Nest는 provider간의 관계를 관리하는 inversion of control(\u0026ldquo;IoC\u0026rdquo;) container를 갖고 있다. 이러한 특성은 위에서 설명한 dependency injection 특성에 기반하고 있다. provider를 정의하기 위한 여러가지 방법이 있다. plain value, class, asynchronous factory 또는 synchronous factory를 사용할 수 있다. 이에 대한 예제는 이 곳에서 볼 수 있다.\nOptional providers 가끔, 반드시 주입될 필요가 없는 의존성이 있을 수 있다. 예를 들어, configuration object에 의존하는 class의 경우, configuration obejct가 사용되지 않으면 기본값이 적용된다. 이러한 경우, 의존성은 optional하다. provider를 optional로 지정하기 위해서는 @Optional() 데코레이터를 생성자에 사용한다.\nimport { Injectable, Optional, Inject } from \u0026#39;@nestjs/common\u0026#39;; @Injectable() export class HttpService\u0026lt;T\u0026gt; { constructor(@Optional() @Inject(\u0026#39;HTTP_OPTIONS\u0026#39;) private httpClient: T) {} } 위의 예제는 HTTP_OPTION token을 포함한 custom provider를 사용하였다.\nProperty-based injection 지금까지 우리가 사용한 기술은 생성자를 통해 provider를 주입하기 때문에 constructor-based injection이라고 불린다. 일부의 경우, property-based injection이 유용하다. 예를 들어, 하나 이상의 provider에 의존성을 가진 최상위 class의 경우, sub class로부터 super()를 호출하여 이를 주입하는 것은 좋지 못한 방법이다. 대신 @Inject() 데코레이터를 property-level 에서 사용한다.\nimport { Injectable, Inject } from \u0026#39;@nestjs/common\u0026#39;; @Injectable() export class HttpService\u0026lt;T\u0026gt; { @Inject(\u0026#39;HTTP_OPTIONS\u0026#39;) private readonly httpClient: T; }  class가 다른 provider를 확장하고 있는 것이 아니라면, 항상 constructor-based injection을 사용하는 것이 좋다.\n Provider registration CatsService와 CatsController를 정의하였다. 이제 service가 injection 될 수 있도록 등록해주어야 한다. Module의 @Module() 데코레이터에 providers 배열에 추가함으로써 등록할 수 있다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats/cats.controller\u0026#39;; import { CatsService } from \u0026#39;./cats/cats.service\u0026#39;; @Module({ controllers: [CatsController], providers: [CatsService], }) export class AppModule {} Nest는 이제 CatController에 의존성을 주입할 수 있다.\n디렉토리 구조\nsrc | +-- cats | | | +-- dto | | | | | +-- create-cat.dto.ts | | | +-- interfaces | | | | | +-- cat.interface.ts | | | +-- cats.controller.ts | | | +-- cats.service.ts | +-- app.module.ts | +-- main.ts Manual instantiation 지금까지 어떤 방식으로 Nest에서 의존성을 자동으로 주입하는지에 대해 설명했다. 그러나 특정한 경우, DI system 외부에서 수동으로 의존성을 주입해야 하는 경우가 있다. 이미 존재하는 인스턴스를 가져오거나, provider를 동적으로 인스턴스화 하기 위해서는 Module reference를 사용한다. bootstrap() 함수에 포함된 provider를 가져오기 위해서는 Standalone applications 페이지를 참고하자.\n","permalink":"https://icecat471.github.io/devlog/post/nestjs/providers/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/providers\nProviders Providers provider는 Nest에서 가장 근본적인 개념이다. 대부분의 기본 Nest class는 provider로 취급된다(예를 들어, service, repository, factory, helper 등등). provider는 의존성을 주입할 수 있다. 이것은 오브젝트간의 서로 다양한 관계들을 만들 수 있음을 뜻한다.\n앞선 챕터에서, 우리는 CatsController를 만들었고, controller는 HTTP request를 핸들링하고 복잡한 일을 provider에게 맡긴다.\nServices 간단한 CatsService를 만들어보자. 이 service는 데이터를 저장하고 불러오는 역할을 담당할 것이며, CatsController가 이를 시용할 것이다.","title":"[NestJS] (공식문서 번역) Providers"},{"content":"pull \u0026amp; run\n$ docker run -p 5432:5432 --name postgres \\  -e POSTGRES_PASSWORD=password \\  -d postgres 컨테이너 접속 및 사용자 생성\n# 접속 $ docker exec -it postgres /bin/bash # postgres 접속 $ psql - U postgres # 사용자 생성 $ CREATE USER username PASSWORD \u0026#39;password\u0026#39; SUPERUSER; CREATE ROLE $ CREATE DATABASE test OWNER username CREATE DATABASE ","permalink":"https://icecat471.github.io/devlog/post/docker/install_postgres/","summary":"pull \u0026amp; run\n$ docker run -p 5432:5432 --name postgres \\  -e POSTGRES_PASSWORD=password \\  -d postgres 컨테이너 접속 및 사용자 생성\n# 접속 $ docker exec -it postgres /bin/bash # postgres 접속 $ psql - U postgres # 사용자 생성 $ CREATE USER username PASSWORD \u0026#39;password\u0026#39; SUPERUSER; CREATE ROLE $ CREATE DATABASE test OWNER username CREATE DATABASE ","title":"[Docker] PostgresSQL 설치"},{"content":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/controllers\nControllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.\nrouting mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다. 이 경우, @Controller(\u0026lsquo;customers\u0026rsquo;) 데코레이터를 사용하여 쉽게 그룹화 가능하다.\n// cats.controller.ts  import { Controller, Get } from \u0026#39;@nestjs/common\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Get() findAll(): string { return \u0026#39;This action returns all cats\u0026#39;; } } @Get() HTTP request method 데코레이터는 Nest에게 HTTP request의 특정 엔드포인트에 대한 핸들러를 만들도록 한다. 엔드포인트는 HTTP request method(위 예제에서는 GET), route path에 일치하는 경로로 라우팅 된다. route path란, controller에 선언된 prefix와 request decorator에 의해 특정된 path의 결합이다.\n예제에서 모든 route에 대한 prefix(cats)를 선언하였고, decorator에는 path 정보를 추가하지 않았으므로, Nest는 GET /cats에 대한 request를 해당 핸들러에 매핑할 것이다.\n만약, path prefix가 customers 이고, decorator가 @Get(\u0026lsquo;profile\u0026rsquo;)인 경우는 GET /customers/profile 경로로 매핑될 것이다.\n위의 예제에서, 해당 엔드포인트에서 GET request가 만들어지면, Nest는 request를 findAll() method에 라우팅 할 것이다. method명은 임의로 지어진 것이다. 우리는 route에 bind될 method를 선언해야하지만, Nest는 method의 이름은 신경쓰지 않는다.\n이 method는 200이라는 status code와 string을 response로 반환할 것이다. 이것에 대해 설명하려면, response를 다루기 위해 Nest에서 제공하는 2가지 옵션에 대해 알아야 한다.\n         Standard(recommended) request handler가 Javascript object 또는 array를 반환할 때 자동으로 JSON 형태로 직렬화 된다. 그러나, Javascript 원시타입(string, number, boolean 등)을 반환할 때에는 직렬화 없이 값을 반환한다. 이것은 response handling을 간단하게 만들어 준다.또한, response의 status code는 항상 기본값이 200이며, POST의 경우는 201을 사용한다. 이것은 @HttpCode() 데코레이터를 추가하여 간단하게 변경 가능하다.   Library-specific @Res() 데코레이터를 사용하여 library-specific response object(예를 들어, Express)를 사용할 수도 있다(예를 들어, findAll(@Res() response)). 이러한 접근법으로 native response handling method들을 사용 가능하다. 예를 들어, Express를 사용한다면 아래의 코드처럼 사용 가능하다.response.status(200).send()     Warningibrary-specific option을 사용하기 위해 @Res()와 @Next()를 모두 사용하면 Nest는 이를 감지하여 standard는 자동으로 disabled 된다. 두 접근법을 동시에 사용하기 위해서는 passthrough option을 true로 사용해야 한다. @Res({ passthrough: true })\n Request object Handler는 가끔 request 세부사항에 접근해야 하는 경우가 있다. Nest는 platform(default는 Express)에 종속된 request object를 제공한다. @Req() 데코레이터를 사용하여 request object를 injection하여 접근 가능하다.\n// cats.controller.ts  import { Controller, Get, Req } from \u0026#39;@nestjs/common\u0026#39;; import { Request } from \u0026#39;express\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Get() findAll(@Req() request: Request): string { return \u0026#39;This action returns all cats\u0026#39;; } }  위 예제처럼 request: Request 로 typing을 하기 위해서는 @types/express 패키지를 설치하면 된다.\n request object는 query string, parameter, HTTP header, body 등의 속성값을 가진 HTTP request이다. 대부분의 경우, 속성들을 수동으로 가져올 필요 없이 @Body(), @Query()와 같은 데코레이터를 사용하면 된다. 아래는 platform-specifit object의 데코레이터 목록이다.\n         @Request(), @Req() req   @Response(), @Res() res   @Next() next   @Session() req.session   @Param(key?: string) req.params / req.params[key]   @Body(key?: string) req.body / req.body[key]   @Query(key?: string) req.query / req.query[key]   @Headers(name?: string) req.headers / req.headers[name]   @Ip() req.ip   @HostParam() req.hosts    HTTP platform(Express와 Fastify) 기반의 typing을 위해 Nest는 @Res(), @Response() 데코레이터를 제공한다. 이 데코레이터는 native platform의 response 오브젝트를 노출한다. 이것을 사용할 때, 기반 라이브러리를 import 해주어야 한다(예를 들어, @types/express). @Res(), @Response() 데코레이터를 사용하면, Nest에게 핸들러에 대해 Library-specific mode로 설정하게 하고, response를 관리할 수 있게 된다. 이를 통해, res.json()이나 res.send() 같은 response object의 method를 사용할 수 있다.\nResources 앞서, cats resource(GET route)를 fetch하기 위한 엔드포인트를 정의했다. 일반적으로 새로운 레코드를 만드는 엔드포인트도 제공하고 싶을것이다. 이를 위해, POST 핸들러를 사용한다.\n// cats.controller.ts  import { Controller, Get, Post } from \u0026#39;@nestjs/common\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Post() create(): string { return \u0026#39;This action adds a new cat\u0026#39;; } @Get() findAll(): string { return \u0026#39;This action returns all cats\u0026#39;; } } Nest는 모든 standart HTTP method에 대한 데코레이터를 제공한다: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(). 또한 @All() 을 사용하면 모든 요청에 대한 엔드포인트를 정의한다.\nRoute wildcards wildcard로 별표(*)를 사용한 패턴도 제공한다.\n@Get(\u0026#39;ab*cd\u0026#39;) findAll() { return \u0026#39;This route uses a wildcard\u0026#39;; } 'ab*cd' route path는 abcd, ab_cd, abecd등과 match된다. ?, +, *, () 같은 문자도 정규식의 부분으로 route path에 사용가능하다. '-', '.'은 string기반 path에 의해 문자 그대로 번역된다.\nStatus code 앞서 이야기했듯이, response status code는 기본값이 200이다(POST request의 경우 201). 이것은 @HttpCode() 데코레이터를 통해 핸들러 수준에서 쉽게 변경 가능하다.\n@Post() @HttpCode(204) create() { return \u0026#39;This action adds a new cat\u0026#39;; } 종종 status code는 static하지 않고 여러가지 변수에 의존한다. 이런 경우, @Res() 데코레이터를 통해 library-specific response를 사용할 수 있다.\nHeaders custom response header를 특정하기 위해, @Header() 데코레이터 또는 library-specific response object에서 res.header()를 호출할 수 있다.\n@Post() @Header(\u0026#39;Cache-Control\u0026#39;, \u0026#39;none\u0026#39;) create() { return \u0026#39;This action adds a new cat\u0026#39;; } Redirection response를 특정 URL로 redirection하기 위해, @Redirect() 데코레이터 또는 library-specific response object를 통해 res.redirect()를 호출할 수 있다. @Redirect()는 url과 statusCode를 인자로 받으며 둘 모두 optional이다. statusCode의 기본값은 302 이다.\n@Get() @Redirect(\u0026#39;https://nestjs.com\u0026#39;, 301) 가끔, status code나 redirect URL을 동적으로 결정해야 할 때가 있다. route handler method로부터 object를 아래와 같은 형태로 반환하면 된다.\n{ \u0026#34;url\u0026#34;: string, \u0026#34;statusCode\u0026#34;: number } 반환된 값은 @Redirect() 데코레이터의 인자를 override 할 것이다.\n@Get(\u0026#39;docs\u0026#39;) @Redirect(\u0026#39;https://docs.nestjs.com\u0026#39;, 302) getDocs(@Query(\u0026#39;version\u0026#39;) version) { if (version \u0026amp;\u0026amp; version === \u0026#39;5\u0026#39;) { return { url: \u0026#39;https://docs.nestjs.com/v5/\u0026#39; }; } } Route parameters 정적 경로를 가진 route는 request의 일부로 dynamic data에 접근해야 할 경우에는 사용할 수 없다. parameter를 갖는 route를 정의하기 위해 route parameter token을 path에 추가하면 된다. 아래는 @Get() 데코레이터에 사용한 route parameter token에 대한 예제이다. 이렇게 선언된 route parameter는 @Param() 데코레이터를 통해 접근할 수 있다.\n@Get(\u0026#39;:id\u0026#39;) findOne(@Param() params): string { console.log(params.id); return `This action returns a #${params.id}cat`; } 위 예제에서 @Param()을 통해 id에 접근하려면 params.id로 접근할 수 있다. 또는 특정 parameter token을 데코레이터에서 접근 가능하다.\n@Get(\u0026#39;:id\u0026#39;) findOne(@Param(\u0026#39;id\u0026#39;) id: string): string { return `This action returns a #${id}cat`; } Sub-Domain Routing @Controller() 데코레이터는 host option을 받을 수 있다. HTTP host는 들어오는 request와 특정 값을 matching하기 위해 사용된다.\n@Controller({ host: \u0026#39;admin.example.com\u0026#39; }) export class AdminController { @Get() index(): string { return \u0026#39;Admin page\u0026#39;; } }  Fastify는 nested router에 대한 지원을 하지 않으므로, sub-domain routing을 사용할 떄에는, Express adpater를 사용해야 한다.(기본값으로 설정되어 있음)\n route path와 마찬가지로, host option의 host name의 token도 동적값으로 사용가능하다. 이 방식으로 선언된 host parameter는 @HostParam() 데코레이터를 통해 사용 할 수 있다.\n@Controller({ host: \u0026#39;:account.example.com\u0026#39; }) export class AccountController { @Get() getInfo(@HostParam(\u0026#39;account\u0026#39;) account: string) { return account; } } Scopes Nest에서는 들어오는 request를 통해 거의 모든것이 공유된다. database에 대한 connection pool, global state에서의 singleton service 등을 갖고 있다. Node.js는 request/response Multi-Threaded Stateless Model을 따르지 않고, 각각의 request에 대해 분리된 thread에서 진행된다. 따라서, singleton instance를 사용하는 것이 우리의 애플리케이션에 안전한 방식이다.\nAsynchronicity data extraction은 대부분 비동기로 일어난다. 따라서 Nest에서는 async fuction을 지원한다. 모든 비동기 함수는 Promise를 반환한다.\n// cats.controller.ts  @Get() async findAll(): Promise\u0026lt;any[]\u0026gt; { return []; } 또한, Nest route handler는 RxJS observable stream을 반환할 수 있다. Nest는 자동으로 아래의 source를 subscribe하여 마지막으로 방출된 값을 가져올 수 있다.(stream이 끝날 때)\n@Get() findAll(): Observable\u0026lt;any[]\u0026gt; { return of([]); } 두 방식 모두 유효하며, 원하는 방식대로 사용하면 된다.\nRequest payloads @Body() 데코레이터를 사용하여 POST route handler에서도 클라이언트로부터 parameter를 받아올 수 있다. 그러나 먼저 DTO(Data Transfer Object) 스키마를 정의해야 한다. DTO는 네트워크를 통해 데이터를 어떤 형식으로 주고받을지 정의하는 오브젝트이다. DTO는 TypeScript interface 또는 class로 정의할 수 있다. 하지만 class를 추천하는데, class는 JS ES6 standard한 문법이며, 따라서 컴파일된 JS에서도 real entity로 보존된다. 반면, TypeScript interface는 transpilation 도중 제거되기 때문에 Nest는 그것을 런타임에 호출할 수 없다. 이것은 Pipe와 같은 feature가 런타임에 변수의 메타타입에 접근하는 경우 중요하다.\n// create-cat.dto.ts  export class CreateCatDto { name: string; age: number; breed: string; } // cat.controller.ts  @Post() async create(@Body() createCatDto: CreateCatDto) { return \u0026#39;This action adds a new cat\u0026#39;; } Handling errors 따로 분리된 에러 핸들링 페이지에서 볼 수 있다.\nFull resource sample // cat.controller.ts  import { Controller, Get, Query, Post, Body, Put, Param, Delete } from \u0026#39;@nestjs/common\u0026#39;; import { CreateCatDto, UpdateCatDto, ListAllEntities } from \u0026#39;./dto\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Post() create(@Body() createCatDto: CreateCatDto) { return \u0026#39;This action adds a new cat\u0026#39;; } @Get() findAll(@Query() query: ListAllEntities) { return `This action returns all cats (limit: ${query.limit}items)`; } @Get(\u0026#39;:id\u0026#39;) findOne(@Param(\u0026#39;id\u0026#39;) id: string) { return `This action returns a #${id}cat`; } @Put(\u0026#39;:id\u0026#39;) update(@Param(\u0026#39;id\u0026#39;) id: string, @Body() updateCatDto: UpdateCatDto) { return `This action updates a #${id}cat`; } @Delete(\u0026#39;:id\u0026#39;) remove(@Param(\u0026#39;id\u0026#39;) id: string) { return `This action removes a #${id}cat`; } } Getting up and running 위처럼 풀소스코드가 정의되어 있어도, Nest는 CatsController가 존재하는지 알지 못하기 때문에, 해당 클래스의 인스턴스를 생성하지 못한다. Controller는 항상 module에 속해있어야 하며, @Module() 데코레이터를 통해 포함시킨다.\n// app.module.ts  import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { CatsController } from \u0026#39;./cats/cats.controller\u0026#39;; @Module({ controllers: [CatsController], }) export class AppModule {} module class에 @Module() 데코레이터를 통해 포함시키면, Nest는 해당 controller를 찾아 mount한다.\nLibrary-specific approach library-specific response object를 injection하기 위해 @Res() 또는 @Response() 데코레이터를 사용한다.\n// cat.controller.ts  import { Controller, Get, Post, Res, HttpStatus } from \u0026#39;@nestjs/common\u0026#39;; import { Response } from \u0026#39;express\u0026#39;; @Controller(\u0026#39;cats\u0026#39;) export class CatsController { @Post() create(@Res() res: Response) { res.status(HttpStatus.CREATED).send(); } @Get() findAll(@Res() res: Response) { res.status(HttpStatus.OK).json([]); } } 이 방식을 통해, response object를 더 유연한 방식으로 컨트롤 할 수 있다. 일반적으로 이러한 접근 방식은 덜 clear하며, disadvantage를 가져올 수 있으므로 조심해서 다루어야 한다. 가장 주요한 disadvantage는 코드가 platform 의존적(기반 플랫폼들은 response object에 대해 서로 다른 API를 갖고 있다.)이 되며 테스트하기가 힘들어진다는 것이다. 또한, 위의 예제와 같이, Nest standard로 제공하는 response 핸들링 기능들을 사용할 수 없다(예를 들어, @HttpCode() / @Header() 데코레이터 등). 이것을 해결하기 위해 passthrough 옵션을 사용할 수 있다.\n@Get() findAll(@Res({ passthrough: true }) res: Response) { res.status(HttpStatus.OK); return []; } ","permalink":"https://icecat471.github.io/devlog/post/nestjs/controllers/","summary":"NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/controllers\nControllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.\nrouting mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다.","title":"[NestJS] (공식문서 번역) Controllers"},{"content":"톰캣 홈페이지\nhttp://tomcat.apache.org/\n받은 파일의 압축을 푼다 (다운로드 폴더 기준, apache-tomcat-9.0.45)\n# 폴더를 /usr/local 경로로 이동 $ sudo mv ~/Downloads/apache-tomcat-9.0.45 /usr/local/ # 기존에 존재하는 /Library/Tomcat 경로를 지우고 이동한 폴더를 링크함  $ sudo rm -f /Library/Tomcat $ sudo ln -s /usr/local/apache-tomcat-9.0.45/ /Library/Tomcat # 소유자를 본인으로 변경 $ sudo chown -R \u0026lt;userName\u0026gt; /Library/Tomcat # 실행권한 추가 $ sudo chmod +x /Library/Tomcat/bin/*.sh # Tomcat 실행 $ /Library/Tomcat/bin/startup.sh # Tomcat 종료 $ /Library/Tomcat/bin/shutdown.sh 톰캣 실행 확인\nhttp://localhost:8080\n","permalink":"https://icecat471.github.io/devlog/post/spring/install_apache_tomcat/","summary":"톰캣 홈페이지\nhttp://tomcat.apache.org/\n받은 파일의 압축을 푼다 (다운로드 폴더 기준, apache-tomcat-9.0.45)\n# 폴더를 /usr/local 경로로 이동 $ sudo mv ~/Downloads/apache-tomcat-9.0.45 /usr/local/ # 기존에 존재하는 /Library/Tomcat 경로를 지우고 이동한 폴더를 링크함  $ sudo rm -f /Library/Tomcat $ sudo ln -s /usr/local/apache-tomcat-9.0.45/ /Library/Tomcat # 소유자를 본인으로 변경 $ sudo chown -R \u0026lt;userName\u0026gt; /Library/Tomcat # 실행권한 추가 $ sudo chmod +x /Library/Tomcat/bin/*.sh # Tomcat 실행 $ /Library/Tomcat/bin/startup.sh # Tomcat 종료 $ /Library/Tomcat/bin/shutdown.sh 톰캣 실행 확인","title":"맥북 Tomcat9 설치"},{"content":"docker로 mongoDB 설치 pull # 최신버전 받아오기 $ docker pull mongo run $ docker run -d \\ # background 실행 --name mongo_db \\ # container name -v /Users/docker/mongodb/data/db:/data/db \\ # volume 설정 -p 27017:27017 \\ # port 설정 mongo -auth 컨테이너 접속 $ docker exec -it mongo_db /bin/bash mongo db # mongo db 접속. 권한이 없는 상태라 바로 접속 됨. $ mongo # admin db 선택 \u0026gt; use admin # admin 계정 생성 \u0026gt; db.createUser({ user: \u0026#34;admin\u0026#34;, # admin name pwd: \u0026#34;password\u0026#34;, # admin password roles: [ {role: \u0026#34;userAdminAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;}, {role: \u0026#34;dbAdminAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;}, {role: \u0026#34;readWriteAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;} ] # admin role }) # admin 계정 접속 $ mongo -u \u0026#34;admin\u0026#34; -p --authenticationDatabase \u0026#34;admin\u0026#34; (password 입력) user 추가 # 유저 생성 \u0026gt; db.createUser({ user: \u0026#39;username\u0026#39;, pwd: \u0026#39;password\u0026#39;, roles: [{role: \u0026#39;readWrite\u0026#39;, db: \u0026#39;test\u0026#39;}, {role: \u0026#39;read\u0026#39;, db: \u0026#39;reporting\u0026#39;}] }) # 로그인 db.auth(\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;); ","permalink":"https://icecat471.github.io/devlog/post/docker/install_mongo_db/","summary":"docker로 mongoDB 설치 pull # 최신버전 받아오기 $ docker pull mongo run $ docker run -d \\ # background 실행 --name mongo_db \\ # container name -v /Users/docker/mongodb/data/db:/data/db \\ # volume 설정 -p 27017:27017 \\ # port 설정 mongo -auth 컨테이너 접속 $ docker exec -it mongo_db /bin/bash mongo db # mongo db 접속. 권한이 없는 상태라 바로 접속 됨. $ mongo # admin db 선택 \u0026gt; use admin # admin 계정 생성 \u0026gt; db.","title":"[Docker] 몽고db 컨테이너 설치"},{"content":"ECDSA (Elliptic Curve Digital Signature Algorithm) 타원곡선암호(ECC)를 전자서명에 접목시킨 암호 알고리즘.타원곡선의 정의 일반적으로 타원 곡선 방정식은 아래와 같다.\n y2+ b1xy + b2y = x3+ a1x2+ a2x + a3 그러나, 실수상의 타원 곡선은 아래와 같은 특별한 타원 곡선을 사용한다.\n y2= x3+ ax + b\n 타원곡선의 특징은 x축을 중심으로 대칭되며, 비 수직선에 대해 최대 3개 지점에서 곡선과 교차.\n타원곡선상의 연산 타원곡선상의 점 P와 Q의 덧셈연산은 P와 Q를 지나는 직선이 타원과 만나는 교점(-R)을 x축으로 대칭시킨 점 R에 대해\nP + Q = R로 정의한다.타원곡선 암호화 원리 및 키생성 타원곡선에은 임의의 정수 a, b에 대해 정의된 다음과 같은 방정식의 해 (X, Y)의 집합이다.\n Y2= X3+ aX + b (mod p)\n 점 p=(x, y)가 타원곡선상에 있다는 것은 위의 방정식을 만족시킨다는 의미이다.또한, 두 점 P, Q와 임의의 정수 x에 대해 다음과 같은 방정식을 정의할 수 있다.\n Q = xG\n 타원곡선 이산대수 문제는 위와 같은 상황에서 해 x를 구하는 것이다.이로부터 타원곡선 암호에서 사용하는 키 쌍은 다음과 같이 정의할 수 있다.\n G: 생성자. 임의의 시작포인트\nx: 개인키. p보다 적은 소수(prime)로, 난수 생성기로 생성.\nQ: 공개키. 개인키로부터 연산.\n 이 때, 공개키 Q는 Q = xG = G+G+G+\u0026hellip;+G(x번 덧셈) 한 값이다.\nQ = xG 수식에서 x와 G를 이용해 Q를 구하기는 쉽지만, G와 Q를 이용해 x를 구하기는 힘들다.\nG는 타원곡선상 임의의 점이며, xG는 G를 타원곡선상에서 x번 덧셈 연산한 것을 의미한다.\n2G=G+G 는 점 G에서 점 G에서의 접선이 타원곡선과 만나는 제 3의 점을 x축으로 대칭시킨 점이다.4G=2G+2G 는 2G의 점에서 마찬가지로 접선을 그어 타원곡선과 만나는 점을 x축으로 대칭시킨 점이다.G의 상수배 연산은 이를 반복적으로 수행하여 표현한다.\n블록체인에서의 타원곡선 암호(ECDSA) 블록체인 기반 기술에서는 키 쌍 생성시 타원곡선 알고리즘을 사용하며, 키 길이는 256비트 이상을 사용한다.비트코인의 경우 미국국립표준기술원(NIST)에서 개발한 secp256k1 표준에 정의된 타원곡선을 사용한다.secp256k1은 표준으로 제정된 elliptic curve를 만들기 위한 상수 집합이다.참고로 NIST에서는 secp256r1을 추천하고 있다.비트코인에서 secp256r1 대신 secp256k1을 사용한 이유는 여러가지 추측이 있지만, 속도 때문이라는 이유가 타당하다고 여겨진다.secp256k1이란 이름은, sec(Standard for Efficient Cryptography) + p(Paramter p over Fp) + 256(Field size p의 bit수) + k(Koblitz curve 변형) + 1(sequence number) 로 구성.r은 Random parameter를 의미한다.secp256k1의 경우, a와 b의 값이 a=0, b=7로 정해져 있어\n y2mod p = (x3+ 7) mod p\n 의 타원곡선 수식을 사용한다.\nReference   해시넷 - 타원곡선 디지털서명 알고리즘\n  아이리포 - ECC 알고리즘\n  APE코리아네트 블로그 - 비트코인에서 사용하는 타원곡선암호기술(ECC)\n  ","permalink":"https://icecat471.github.io/devlog/post/encryption/ecdsa/","summary":"ECDSA (Elliptic Curve Digital Signature Algorithm) 타원곡선암호(ECC)를 전자서명에 접목시킨 암호 알고리즘.타원곡선의 정의 일반적으로 타원 곡선 방정식은 아래와 같다.\n y2+ b1xy + b2y = x3+ a1x2+ a2x + a3 그러나, 실수상의 타원 곡선은 아래와 같은 특별한 타원 곡선을 사용한다.\n y2= x3+ ax + b\n 타원곡선의 특징은 x축을 중심으로 대칭되며, 비 수직선에 대해 최대 3개 지점에서 곡선과 교차.\n타원곡선상의 연산 타원곡선상의 점 P와 Q의 덧셈연산은 P와 Q를 지나는 직선이 타원과 만나는 교점(-R)을 x축으로 대칭시킨 점 R에 대해","title":"ECDSA 알고리즘"},{"content":"Decorator Pattern 출처: https://golangbyexample.com/decorator-pattern-golang/\n개요 개체를 변경하지 않고 기능을 추가할 수 있음.\n=\u0026gt; 이미 테스트가 끝난 코드를 수정하면 안됨 (Open-Closed Principle에 위배됨) 두가지 피자가 존재한다고 가정해보자.\n vegge mania pizza peppy tofu pizza  UML 다이어그램 코드 pizza.go\npackage main type pizza interface { getPrice() int } peppyPaneer.go\npackage main type peppyPaneer struct { } func (p *peppyPaneer) getPrice() int { return 20 } veggeMania.go\npackage main type veggeMania struct { } func (p *veggeMania) getPrice() int { return 15 } 토핑을 추가하기 위해 위쪽에 만들어진 구조체들은 더 이상 수정하면 안됨.\ncheeseTopping.go\npackage main type cheeseTopping struct { pizza pizza } func (c *cheeseTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 10 } tomatoTopping.go\npackage main type tomatoTopping struct { pizza pizza } func (c *tomatoTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 7 } main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { veggiePizza := \u0026amp;veggeMania{} //Add cheese topping  veggiePizzaWithCheese := \u0026amp;cheeseTopping{ pizza: veggiePizza, } //Add tomato topping  veggiePizzaWithCheeseAndTomato := \u0026amp;tomatoTopping{ pizza: veggiePizzaWithCheese, } fmt.Printf(\u0026#34;Price of veggieMania pizza with tomato and cheese topping is %d\\n\u0026#34;, veggiePizzaWithCheeseAndTomato.getPrice()) peppyPaneerPizza := \u0026amp;peppyPaneer{} //Add cheese topping  peppyPaneerPizzaWithCheese := \u0026amp;cheeseTopping{ pizza: peppyPaneerPizza, } fmt.Printf(\u0026#34;Price of peppyPaneer with tomato and cheese topping is %d\\n\u0026#34;, peppyPaneerPizzaWithCheese.getPrice()) } 실행 결과\nPrice of veggieMania pizza with tomato and cheese topping is 32 Price of peppyPaneer with tomato and cheese topping is 30 ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/decorator/","summary":"Decorator Pattern 출처: https://golangbyexample.com/decorator-pattern-golang/\n개요 개체를 변경하지 않고 기능을 추가할 수 있음.\n=\u0026gt; 이미 테스트가 끝난 코드를 수정하면 안됨 (Open-Closed Principle에 위배됨) 두가지 피자가 존재한다고 가정해보자.\n vegge mania pizza peppy tofu pizza  UML 다이어그램 코드 pizza.go\npackage main type pizza interface { getPrice() int } peppyPaneer.go\npackage main type peppyPaneer struct { } func (p *peppyPaneer) getPrice() int { return 20 } veggeMania.go\npackage main type veggeMania struct { } func (p *veggeMania) getPrice() int { return 15 } 토핑을 추가하기 위해 위쪽에 만들어진 구조체들은 더 이상 수정하면 안됨.","title":"[디자인패턴] Decorator 패턴"},{"content":"Composite Pattern 출처: https://golangbyexample.com/composite-design-pattern-golang/\n개요 \u0026lsquo;composite\u0026rsquo;라고 불리는 개체그룹이 단일개체와 유사한 방식으로 처리되기를 원할때 사용.\n트리구조로 객체들을 엮는다. UML 다이어그램 OS의 파일시스템에는 폴더와 파일 두가지 유형의 개체가 있는데, 폴더와 파일은 동일하게 취급받는 경우가 있다.\nMapping          Component interface component.go   Composite folder.go   Leaf file.go   client main.go    코드 component.go\npackage main type component interface { search(string) } folder.go\npackage main import \u0026#34;fmt\u0026#34; type folder struct { components []component name string } func (f *folder) search(keyword string) { fmt.Printf(\u0026#34;Serching recursively for keyword %s in folder %s\\n\u0026#34;, keyword, f.name) for _, composite := range f.components { composite.search(keyword) } } func (f *folder) add(c component) { f.components = append(f.components, c) } file.go\npackage main import \u0026#34;fmt\u0026#34; type file struct { name string } func (f *file) search(keyword string) { fmt.Printf(\u0026#34;Searching for keyword %s in file %s\\n\u0026#34;, keyword, f.name) } func (f *file) getName() string { return f.name } main.go\npackage main func main() { file1 := \u0026amp;file{name: \u0026#34;File1\u0026#34;} file2 := \u0026amp;file{name: \u0026#34;File2\u0026#34;} file3 := \u0026amp;file{name: \u0026#34;File3\u0026#34;} folder1 := \u0026amp;folder{ name: \u0026#34;Folder1\u0026#34;, } folder1.add(file1) folder2 := \u0026amp;folder{ name: \u0026#34;Folder2\u0026#34;, } folder2.add(file2) folder2.add(file3) folder2.add(folder1) folder2.search(\u0026#34;rose\u0026#34;) } 실행 결과\nSerching recursively for keyword rose in folder Folder2 Searching for keyword rose in file File2 Searching for keyword rose in file File3 Serching recursively for keyword rose in folder Folder1 Searching for keyword rose in file File1 ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/composite/","summary":"Composite Pattern 출처: https://golangbyexample.com/composite-design-pattern-golang/\n개요 \u0026lsquo;composite\u0026rsquo;라고 불리는 개체그룹이 단일개체와 유사한 방식으로 처리되기를 원할때 사용.\n트리구조로 객체들을 엮는다. UML 다이어그램 OS의 파일시스템에는 폴더와 파일 두가지 유형의 개체가 있는데, 폴더와 파일은 동일하게 취급받는 경우가 있다.\nMapping          Component interface component.go   Composite folder.go   Leaf file.go   client main.go    코드 component.go\npackage main type component interface { search(string) } folder.","title":"[디자인패턴] Composite 패턴"},{"content":"Bridge Pattern 출처: https://golangbyexample.com/bridge-design-pattern-in-go/\n개요 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.이 패턴은 큰 클래스를 두개의 개별 계층으로 나누는것을 제안한다.\n Abstraction: interface. Implementation에 대한 참조가 포함됨.\nAbstraction의 자식을 Refined Abstraction 이라고 부름. Implementation: interface.\nImplementation의 자식을 Concrete Implementation 이라고 부름.  UML 다이어그램 2가지 유형의 컴퓨터 Mac과 Windows가 있다고 가정. 2가지 유형의 프린터 epson과 hp가 있다고 가정. 2*2의 조합의 4개의 구조체를 만드는 대신 2개의 계층을 만든다.\n코드 computer.go\npackage main type computer interface { print() setPrinter(printer) } mac.go\npackage main import \u0026#34;fmt\u0026#34; type mac struct { printer printer } func (m *mac) print() { fmt.Println(\u0026#34;Print request for mac\u0026#34;) m.printer.printFile() } func (m *mac) setPrinter(p printer) { m.printer = p } windows.go\npackage main import \u0026#34;fmt\u0026#34; type windows struct { printer printer } func (w *windows) print() { fmt.Println(\u0026#34;Print request for windows\u0026#34;) w.printer.printFile() } func (w *windows) setPrinter(p printer) { w.printer = p } printer.go\npackage main type printer interface { printFile() } epson.go\npackage main import \u0026#34;fmt\u0026#34; type epson struct { } func (p *epson) printFile() { fmt.Println(\u0026#34;Printing by a EPSON Printer\u0026#34;) } hp.go\npackage main import \u0026#34;fmt\u0026#34; type hp struct { } func (p *hp) printFile() { fmt.Println(\u0026#34;Printing by a HP Printer\u0026#34;) } main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { hpPrinter := \u0026amp;hp{} epsonPrinter := \u0026amp;epson{} macComputer := \u0026amp;mac{} macComputer.setPrinter(hpPrinter) macComputer.print() fmt.Println() macComputer.setPrinter(epsonPrinter) macComputer.print() fmt.Println() winComputer := \u0026amp;windows{} winComputer.setPrinter(hpPrinter) winComputer.print() fmt.Println() winComputer.setPrinter(epsonPrinter) winComputer.print() fmt.Println() } 실행 결과\nPrint request for mac Printing by a HP Printer Print request for mac Printing by a EPSON Printer Print request for windows Printing by a HP Printer Print request for windows Printing by a EPSON Printer ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/bridge/","summary":"Bridge Pattern 출처: https://golangbyexample.com/bridge-design-pattern-in-go/\n개요 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.이 패턴은 큰 클래스를 두개의 개별 계층으로 나누는것을 제안한다.\n Abstraction: interface. Implementation에 대한 참조가 포함됨.\nAbstraction의 자식을 Refined Abstraction 이라고 부름. Implementation: interface.\nImplementation의 자식을 Concrete Implementation 이라고 부름.  UML 다이어그램 2가지 유형의 컴퓨터 Mac과 Windows가 있다고 가정. 2가지 유형의 프린터 epson과 hp가 있다고 가정. 2*2의 조합의 4개의 구조체를 만드는 대신 2개의 계층을 만든다.","title":"[디자인패턴] Bridge 패턴"},{"content":"Adapter Pattern 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.코드 출처: https://refactoring.guru/design-patterns/adapter/go/example 윈도우에는 USB, 맥북에는 thunderbolt 포트가 있다.윈도우 PC에 thunderbolt포트를 연결하기 위해 adapter가 필요하다client.go\npackage main import \u0026#34;fmt\u0026#34; type client struct { } func (c *client) insertLightningConnectorIntoComputer(com computer) { fmt.Println(\u0026#34;Client inserts Lightning connector into computer.\u0026#34;) com.insertIntoLightningPort() } computer.go\npackage main type computer interface { insertIntoLightningPort() } mac.go\npackage main import \u0026#34;fmt\u0026#34; type mac struct { } func (m *mac) insertIntoLightningPort() { fmt.Println(\u0026#34;Lightning connector is plugged into mac machine.\u0026#34;) } window.go\npackage main import \u0026#34;fmt\u0026#34; type windows struct{} func (w *windows) insertIntoUSBPort() { fmt.Println(\u0026#34;USB connector is plugged into windows machine.\u0026#34;) } windowAdapter.go\npackage main import \u0026#34;fmt\u0026#34; type windowsAdapter struct { windowMachine *windows } func (w *windowsAdapter) insertIntoLightningPort() { fmt.Println(\u0026#34;Adapter converts Lightning signal to USB.\u0026#34;) w.windowMachine.insertIntoUSBPort() } main.go\npackage main func main() { client := \u0026amp;client{} mac := \u0026amp;mac{} client.insertLightningConnectorIntoComputer(mac) windowsMachine := \u0026amp;windows{} windowsMachineAdapter := \u0026amp;windowsAdapter{ windowMachine: windowsMachine, } client.insertLightningConnectorIntoComputer(windowsMachineAdapter) } 실행 결과\nClient inserts Lightning connector into computer. Lightning connector is plugged into mac machine. Client inserts Lightning connector into computer. Adapter converts Lightning signal to USB. USB connector is plugged into windows machine. ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/adapter/","summary":"Adapter Pattern 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.코드 출처: https://refactoring.guru/design-patterns/adapter/go/example 윈도우에는 USB, 맥북에는 thunderbolt 포트가 있다.윈도우 PC에 thunderbolt포트를 연결하기 위해 adapter가 필요하다client.go\npackage main import \u0026#34;fmt\u0026#34; type client struct { } func (c *client) insertLightningConnectorIntoComputer(com computer) { fmt.Println(\u0026#34;Client inserts Lightning connector into computer.\u0026#34;) com.insertIntoLightningPort() } computer.go\npackage main type computer interface { insertIntoLightningPort() } mac.","title":"[디자인패턴] Adapter 패턴"},{"content":"Singleton 패턴 하나의 클래스에 대해 하나의 인스턴스만 존재하는 패턴go에서는 sync.Once를 통해 구현 가능하다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type User struct { uid int name string level int } type userDatabase struct { users map[int]*User } var once sync.Once var instance *userDatabase func (d *userDatabase) GetUser(uid int) (*User, bool) { user, ok := d.users[uid] return user, ok } func GetUserDatabase() *userDatabase { // sync.Once.Do()는 딱 한번만 실행  once.Do(func() { db := \u0026amp;userDatabase{ map[int]*User{ 1: {1, \u0026#34;zz\u0026#34;, 2}, 2: {2, \u0026#34;지존도적z\u0026#34;, 32}, 3: {3, \u0026#34;\u0026#34;, 21}, 4: {4, \u0026#34;zz\u0026#34;, 27}, }, } instance = db }) return instance } func main() { db := GetUserDatabase() user2, _ := db.GetUser(2) fmt.Println(user2) } 실행결과\n\u0026amp;{2 지존도적z 32} singleton에서 테스트 코드 작성시 문제점 전체 유저의 레벨의 합을 구하는 함수가 필요하다고 해보자.\nfunc GetUserTotalLevel(uids []int) int { total := 0 for _, uid := range uids { total += GetUserDatabase().users[uid].level } return total } 실제 라이브 db는 수치가 변경될 수 있기때문에 dummy db를 만들어서 테스트를 수행해야 한다.하지만 위 코드에서\n total += GetUserDatabase().users[uid].level\n 부분은 userDatabase에 종속적이므로 테스트를 작성하기 쉽지 않다. (종속성 반전 원칙에 위배됨)해결방법 인터페이스를 통해 단계를 추상화하여 종속성 반전을 통해 해결한다.\n// interface type Database interface { GetUser(int) (*User, bool) } type DummyDatabase struct { users map[int]*User } func (d *DummyDatabase) GetUser(uid int) (*User, bool) { if len(d.users) == 0 { d.users = map[int]*User{ 1: {1, \u0026#34;zz\u0026#34;, 2}, 2: {2, \u0026#34;지존도적z\u0026#34;, 32}, 3: {3, \u0026#34;\u0026#34;, 21}, 4: {4, \u0026#34;zz\u0026#34;, 27}, } } user, ok := d.users[uid] return user, ok } // GetUserTotalLevel() 함수 수정 func GetUserTotalLevel(db Database, uids []int) int { total := 0 for _, uid := range uids { user, _ := db.GetUser(uid) total += user.level } return total } func main() { liveDb := GetUserDatabase() liveTotalLevel := GetUserTotalLevel(liveDb, []int{1, 3, 4}) fmt.Println(liveTotalLevel == 50) // test code  db := \u0026amp;DummyDatabase{} totalLevel := GetUserTotalLevel(db, []int{1, 3, 4}) fmt.Println(totalLevel == 50) } 실행결과\ntrue true ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/singleton/","summary":"Singleton 패턴 하나의 클래스에 대해 하나의 인스턴스만 존재하는 패턴go에서는 sync.Once를 통해 구현 가능하다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type User struct { uid int name string level int } type userDatabase struct { users map[int]*User } var once sync.Once var instance *userDatabase func (d *userDatabase) GetUser(uid int) (*User, bool) { user, ok := d.users[uid] return user, ok } func GetUserDatabase() *userDatabase { // sync.Once.Do()는 딱 한번만 실행  once.","title":"[디자인패턴] Singleton 패턴"},{"content":"프로토타입 패턴 프로토타입 패턴(prototype pattern)은 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.얕은 복사(shallow copy) vs 깊은 복사(deep copy) 얕은 복사 객체를 복사할때 참조값을 가진 멤버는 참조값만 복사 됨.\ntype Status struct { str int dex int wis int } type Monster struct { Name string Status *Status } func main() { slime := Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1,1,1}, } goblin := slime goblin.Name = \u0026#34;goblin\u0026#34; goblin.Status.str = 3 fmt.Println(slime, slime.Status) fmt.Println(goblin, goblin.Status) } 실행결과\n{slime 0xc0000141a0} \u0026amp;{3 1 1} {goblin 0xc0000141a0} \u0026amp;{3 1 1} =\u0026gt; Status의 참조값만 복사되었기때문에 고블린의 스탯을 변경하면 슬라임의 스탯도 같이 변경된다.\n깊은 복사 type Status struct { Str int Dex int Wis int } type Monster struct { Name string Status *Status } func (m *Monster) DeepCopy() *Monster { return \u0026amp;Monster{ m.Name, \u0026amp;Status{ m.Status.Str, m.Status.Dex, m.Status.Wis, }, } } func main() { slime := \u0026amp;Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1, 1, 1}, } goblin := slime.DeepCopy() goblin.Name = \u0026#34;goblin\u0026#34; goblin.Status.Str = 3 fmt.Println(slime, slime.Status) fmt.Println(goblin, goblin.Status) } 실행결과\n{slime 0xc0000141a0} \u0026amp;{1 1 1} {goblin 0xc0000141a0} \u0026amp;{3 1 1} =\u0026gt; Status의 참조값이 아닌 참조된 객체의 내용을 복사했기때문에 고블린의 Status를 변경해도 슬라임의 Status에는 영향이 없음.\n직렬화(serialization)를 통한 깊은 복사 type Status struct { Str int Dex int Wis int } type Monster struct { Name string Status *Status } func (m *Monster) DeepCopy() *Monster { b := bytes.Buffer{} e := gob.NewEncoder(\u0026amp;b) _ = e.Encode(m) d := gob.NewDecoder(\u0026amp;b) monster := Monster{} _ = d.Decode(\u0026amp;monster) return \u0026amp;monster } func main() { slime := \u0026amp;Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1, 1, 1}, } goblin := slime.DeepCopy() goblin.Name = \u0026#34;goblin\u0026#34; goblin.Status.Str = 3 fmt.Println(slime, slime.Status) fmt.Println(goblin, goblin.Status) } 실행 결과\n\u0026amp;{slime 0xc0000141c0} \u0026amp;{1 1 1} \u0026amp;{goblin 0xc000014460} \u0026amp;{3 1 1} prototype factory  현재 아래코드에서 스킬 배열이 복사가 안됨 =\u0026gt; 원인파악중  package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/gob\u0026#34; \u0026#34;fmt\u0026#34; ) type Status struct { Str int Dex int Wis int } type Monster struct { Name string Status *Status Skills []string } func (m *Monster) DeepCopy() *Monster { b := bytes.Buffer{} e := gob.NewEncoder(\u0026amp;b) _ = e.Encode(m) d := gob.NewDecoder(\u0026amp;b) monster := Monster{} _ = d.Decode(\u0026amp;monster) return \u0026amp;monster } // prototype var ( slime = Monster{\u0026#34;slime\u0026#34;, \u0026amp;Status{1, 1, 1}, []string{}} goblin = Monster{\u0026#34;goblin\u0026#34;, \u0026amp;Status{3, 1, 1}, []string{}} ) func NewMonster(proto *Monster, name string, skills []string) *Monster { monster := proto.DeepCopy() monster.Name = name copy(monster.Skills, skills) return monster } func main() { normalSlime := NewMonster(\u0026amp;slime, \u0026#34;평범한 슬라임\u0026#34;, []string{}) normalGoblin := NewMonster(\u0026amp;goblin, \u0026#34;평범한 고블린\u0026#34;, []string{}) fireGoblin := NewMonster(\u0026amp;goblin, \u0026#34;화염 고블린\u0026#34;, []string{\u0026#34;파이어볼\u0026#34;}) fmt.Println(normalSlime, normalSlime.Status) fmt.Println(normalGoblin, normalGoblin.Status) fmt.Println(fireGoblin, fireGoblin.Status) } ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/prototype_pattern/","summary":"프로토타입 패턴 프로토타입 패턴(prototype pattern)은 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.얕은 복사(shallow copy) vs 깊은 복사(deep copy) 얕은 복사 객체를 복사할때 참조값을 가진 멤버는 참조값만 복사 됨.\ntype Status struct { str int dex int wis int } type Monster struct { Name string Status *Status } func main() { slime := Monster{ \u0026#34;slime\u0026#34;, \u0026amp;Status{1,1,1}, } goblin := slime goblin.Name = \u0026#34;goblin\u0026#34; goblin.","title":"[디자인패턴] Prototype 패턴"},{"content":"Factory Pattern 1. factory method pattern 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type Character interface { Attack() } const ( warrior = iota mage ) type Warrior struct { } func (w *Warrior) Attack() { fmt.Println(\u0026#34;sword attack\u0026#34;) } type Mage struct { } func (m *Mage) Attack() { fmt.Println(\u0026#34;magic attack\u0026#34;) }  Factory struct  type CharacterFactory struct { } func (f *CharacterFactory) Create(job int) (Character, error) { switch job { case warrior: return \u0026amp;Warrior{}, nil case mage: return \u0026amp;Mage{}, nil default: return nil, errors.New(\u0026#34;unsupported character type\u0026#34;) } } func main() { cf := \u0026amp;CharacterFactory{} c1, _ := cf.Create(warrior) c2, _ := cf.Create(mage) c1.Attack() c2.Attack() }  Function  func NewCharacter(job int) (Character, error) { switch job { case warrior: return \u0026amp;Warrior{}, nil case mage: return \u0026amp;Mage{}, nil default: return nil, errors.New(\u0026#34;unsupported character type\u0026#34;) } } func main() { c1, _ := NewCharacter(warrior) c2, _ := NewCharacter(mage) c1.Attack() c2.Attack() } 실행결과\nsword attack magic attack 2. factory generator 1) functional type Clothes struct { kind, color string price int } func NewClothesFactory(kind string, price int) func(color string) *Clothes { return func(color string) *Clothes { return \u0026amp;Clothes{kind, color, price} } } func main() { jeanFactory := NewClothesFactory(\u0026#34;jean\u0026#34;, 25000) skirtFactory := NewClothesFactory(\u0026#34;skirt\u0026#34;, 18000) jean := jeanFactory(\u0026#34;blue\u0026#34;) skirt := skirtFactory(\u0026#34;black\u0026#34;) skirt2 := skirtFactory(\u0026#34;white\u0026#34;) fmt.Println(jean) fmt.Println(skirt) fmt.Println(skirt2) } 2) struct type Clothes struct { kind, color string price int } type ClothesFactory struct { kind string price int } func (f *ClothesFactory) Create(color string) *Clothes { return \u0026amp;Clothes{f.kind, color, f.price} } func NewClothesFactory(kind string, price int) *ClothesFactory { return \u0026amp;ClothesFactory{kind, price} } func main() { jeanFactory := NewClothesFactory(\u0026#34;jean\u0026#34;, 25000) skirtFactory := NewClothesFactory(\u0026#34;skirt\u0026#34;, 18000) jean := jeanFactory.Create(\u0026#34;blue\u0026#34;) skirt := skirtFactory.Create(\u0026#34;black\u0026#34;) skirt2 := skirtFactory.Create(\u0026#34;white\u0026#34;) fmt.Println(jean) fmt.Println(skirt) fmt.Println(skirt2) } 실행결과\n\u0026amp;{jean blue 25000} \u0026amp;{skirt black 18000} \u0026amp;{skirt white 18000} ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/factory/","summary":"Factory Pattern 1. factory method pattern 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type Character interface { Attack() } const ( warrior = iota mage ) type Warrior struct { } func (w *Warrior) Attack() { fmt.Println(\u0026#34;sword attack\u0026#34;) } type Mage struct { } func (m *Mage) Attack() { fmt.Println(\u0026#34;magic attack\u0026#34;) }  Factory struct  type CharacterFactory struct { } func (f *CharacterFactory) Create(job int) (Character, error) { switch job { case warrior: return \u0026amp;Warrior{}, nil case mage: return \u0026amp;Mage{}, nil default: return nil, errors.","title":"[디자인패턴] Factory 패턴"},{"content":"1. Builder Pattern Person 객체를 예로 들어보자\ntype Person struct { name string age int job string height float32 weight float32 } func NewPerson(name string, age int, job string, height float32, weight float32) *Person { return \u0026amp;Person{ name, age, job, height, weight, } } func main() { p := NewPerson(\u0026#34;홍길동\u0026#34;, 22, \u0026#34;developer\u0026#34;, 177.2, 72.9) } 위처럼 모든 정보를 입력하지 않아도 될때도 있고, 가독성도 좋지않으며 parameter의 순서도 맞춰주어야한다.또 객체에 새로운 정보가 추가된다면 NewPerson()을 계속 수정해주어야 한다.이를 해결하기 위해 Builder를 이용해보자.\ntype Person struct { name string age int job string height float32 weight float32 } type PersonBuilder struct { person *Person } func NewPersonBuilder() *PersonBuilder { return \u0026amp;PersonBuilder{\u0026amp;Person{}} } func (b *PersonBuilder) Name(name string) *PersonBuilder { b.name = name return b } func (b *PersonBuilder) Age(age int) *PersonBuilder { b.age = age return b } func (b *PersonBuilder) Job(job string) *PersonBuilder { b.job = job return b } func (b *PersonBuilder) Height(height float32) *PersonBuilder { b.height = height return b } func (b *PersonBuilder) Weight(weight float32) *PersonBuilder { b.weight = weight return b } func (b *PersonBuilder) Build() *Person { return b.person } func main() { pb := NewPersonBuilder(). Age(22). Height(177.2). Weight(72.9). Name(\u0026#34;홍길동\u0026#34;). Job(\u0026#34;developer\u0026#34;) p := pb.Build() } 순서를 맞추지 않아도 되고 가독성도 좋아졌다.\n2. 함수형으로 Builder Pattern 사용 type Person struct { name string age int job string height float32 weight float32 } type modPerson func(*Person) type PersonBuilder struct { actions []modPerson } func (b *PersonBuilder) Name(name string) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.name = name }) return b } func (b *PersonBuilder) Age(age int) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.age = age }) return b } func (b *PersonBuilder) Job(job string) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.job = job }) return b } func (b *PersonBuilder) Height(height float32) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.height = height }) return b } func (b *PersonBuilder) Weight(weight float32) *PersonBuilder { b.actions = append(b.actions, func(p *Person) { p.weight = weight }) return b } func (b *PersonBuilder) Build() *Person { p := \u0026amp;Person{} for _, action := range b.actions { action(p) } return p } func NewPersonBuilder() *PersonBuilder { return \u0026amp;PersonBuilder{} } func main() { pb := NewPersonBuilder(). Age(22). Height(177.2). Weight(72.9). Name(\u0026#34;홍길동\u0026#34;). Job(\u0026#34;developer\u0026#34;) p := pb.Build() } ","permalink":"https://icecat471.github.io/devlog/post/design_pattern/bulilder/","summary":"1. Builder Pattern Person 객체를 예로 들어보자\ntype Person struct { name string age int job string height float32 weight float32 } func NewPerson(name string, age int, job string, height float32, weight float32) *Person { return \u0026amp;Person{ name, age, job, height, weight, } } func main() { p := NewPerson(\u0026#34;홍길동\u0026#34;, 22, \u0026#34;developer\u0026#34;, 177.2, 72.9) } 위처럼 모든 정보를 입력하지 않아도 될때도 있고, 가독성도 좋지않으며 parameter의 순서도 맞춰주어야한다.또 객체에 새로운 정보가 추가된다면 NewPerson()을 계속 수정해주어야 한다.","title":"[디자인패턴] Builder 패턴"},{"content":"vscode에서 아래와 같은 에러 발생시\n gopls requires a module at the root of your workspace. You can work with multiple modules by opening each one as a workspace folder.\n settings.json 파일에 아래와 같이 추가하고 vscode를 재실행한다.\n\u0026#34;gopls\u0026#34;: { \u0026#34;experimentalWorkspaceModule\u0026#34;: true, }, ","permalink":"https://icecat471.github.io/devlog/post/golang/gopls_error/","summary":"vscode에서 아래와 같은 에러 발생시\n gopls requires a module at the root of your workspace. You can work with multiple modules by opening each one as a workspace folder.\n settings.json 파일에 아래와 같이 추가하고 vscode를 재실행한다.\n\u0026#34;gopls\u0026#34;: { \u0026#34;experimentalWorkspaceModule\u0026#34;: true, }, ","title":"[Go언어] VSCode에서 gopls 에러가 날때"},{"content":"1. 원하는 테마 찾기 highlightjs.org에서 원하는 테마를 찾는다.2. css 찾기 highlightjs github에서 원하는 테마의 css파일 내용을 복사한다.3. 테마 변경 config.yml에 아래의 내용을 추가한다.pygmentsUseClasses:true(Hugo PaperMod 테마 기준)/themes/PaperMod/assests/css/hljs/an-old-hope.min.css 의 내용을 복사한 내용으로 바꾼다.=\u0026gt; 임시적으로 설정한것으로 theme overriding으로 변경 가능한지 찾아봐야 함.","permalink":"https://icecat471.github.io/devlog/post/hugo/syntax_highlight/","summary":"1. 원하는 테마 찾기 highlightjs.org에서 원하는 테마를 찾는다.2. css 찾기 highlightjs github에서 원하는 테마의 css파일 내용을 복사한다.3. 테마 변경 config.yml에 아래의 내용을 추가한다.pygmentsUseClasses:true(Hugo PaperMod 테마 기준)/themes/PaperMod/assests/css/hljs/an-old-hope.min.css 의 내용을 복사한 내용으로 바꾼다.=\u0026gt; 임시적으로 설정한것으로 theme overriding으로 변경 가능한지 찾아봐야 함.","title":"Hugo syntax highlight 변경"},{"content":"1. 세팅하기 이곳을 클릭 하여 utterances 사이트로 이동한다.configuration 부분을 따라 utterances app을 설치하고 repository설정을 한다.그 외 Blog Post \u0026lt;=\u0026gt; Issue Mapping, Theme 설정등을 한다.설정을 끝내면 Enalble Utterances 부분에 코드가 생성된다\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;(account)/(repo)\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-dark\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 2. hugo에 적용하기 테마마다 설정 방법이 다른데 내가 사용중인 PaperMod 기준 설정방법이다.ParperMod 깃허브 에서도 확인 가능하다./layouts/partials/comments.html 파일을 만들고 위에서 생성된 코드를 붙여넣기한다.그 후 config.yml 파일에 아래부분을 추가해준다.\nparams:comments:true","permalink":"https://icecat471.github.io/devlog/post/hugo/comment/","summary":"1. 세팅하기 이곳을 클릭 하여 utterances 사이트로 이동한다.configuration 부분을 따라 utterances app을 설치하고 repository설정을 한다.그 외 Blog Post \u0026lt;=\u0026gt; Issue Mapping, Theme 설정등을 한다.설정을 끝내면 Enalble Utterances 부분에 코드가 생성된다\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;(account)/(repo)\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-dark\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 2. hugo에 적용하기 테마마다 설정 방법이 다른데 내가 사용중인 PaperMod 기준 설정방법이다.ParperMod 깃허브 에서도 확인 가능하다./layouts/partials/comments.html 파일을 만들고 위에서 생성된 코드를 붙여넣기한다.그 후 config.yml 파일에 아래부분을 추가해준다.","title":"Hugo 블로그 댓글 기능 추가하기"},{"content":"gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.HTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.HTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling         gRPC의 장점 1. 다양한 언어와 플랫폼 지원 ProtoBuf의 IDL을 활용한 서비스 정의 한개로 다양한 언어와 플랫폼에서 동작.공식지원하는 언어 및 플랫폼 목록2. HTTP/2 기반  양방향 스트리밍. 높은 메시지 압축률과 성능.  3. MSA(microservice architecture)에 적합  gRPC를 활용하면 비지니스 로직에 집중하여 빠른 서비스 개발이 가능. MSA의 다양한 기술 스택의 공존으로 인한 중복 발생의 단점 보완 및 수많은 서비스간의 API 호출로 인한 성능저하 개선. ProtoBuf에 의한 높은 메시지 압축률은 시스템 전체의 네트워크 트래픽을 획기적으로 줄여줌.  출처 1. Microsoft Docs 2. 네이버 클라우드 플랫폼 기술 블로그\n","permalink":"https://icecat471.github.io/devlog/post/network/grpc/","summary":"gRPC란? 구글에서 개발한 RPC 시스템. 기본 개념은 RPC와 동일하지만 HTTP/2 기반으로 양방향 스트리밍 지원.HTTP/2를 사용함으로써 메세지의 압축률과 성능이 좋음.HTTP와 비교    Feature gRPC HTTP APIs with JSON     Contract Required (.proto) Optional (OpenAPI)   Protocol HTTP/2 HTTP   Payload Protobuf (small, binary) JSON (large, human readable)   Prescriptiveness Strict specification Loose. Any HTTP is valid.   Streaming Client, server, bi-directional Client, server   Browser support No (requires grpc-web) Yes   Security Transport (TLS) Transport (TLS)   Clientcode-generation Yes OpenAPI + third-party tooling         gRPC의 장점 1.","title":"gRPC란?"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func init() { log.SetPrefix(\u0026#34;Blockchain: \u0026#34;) } func main() { fmt.Println(\u0026#34;test\u0026#34;) log.Println(\u0026#34;test\u0026#34;) } 실행시켜보면\ntest Blockchain: 2021/04/15 15:04:03 test ","permalink":"https://icecat471.github.io/devlog/post/golang/set_prefix_on_log/","summary":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func init() { log.SetPrefix(\u0026#34;Blockchain: \u0026#34;) } func main() { fmt.Println(\u0026#34;test\u0026#34;) log.Println(\u0026#34;test\u0026#34;) } 실행시켜보면\ntest Blockchain: 2021/04/15 15:04:03 test ","title":"Go언어 log.SetPrefix()"},{"content":"\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;800\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; let canvas = document.querySelector(\u0026#39;#myCanvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = \u0026#39;이미지 경로\u0026#39;; context.drawImage(dragon, x좌표, y좌표, width, height); setInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.\n// 1초마다 새로 그림 setInterval(()=\u0026gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms ","permalink":"https://icecat471.github.io/devlog/post/html/draw_image_on_canvas/","summary":"\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;800\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; let canvas = document.querySelector(\u0026#39;#myCanvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); // 이미지 로딩 let dragon = new Image(); dragon.src = \u0026#39;이미지 경로\u0026#39;; context.drawImage(dragon, x좌표, y좌표, width, height); setInterval()을 사용해서 특정시간마다 화면을 새로 그릴 수 있다.\n// 1초마다 새로 그림 setInterval(()=\u0026gt; { context.drawImage(dragon, x좌표, y좌표, width, height); }, 1000); // 1000ms ","title":"html 캔버스에 이미지 그리기"},{"content":"출처: 예제로 배우는 Go 프로그래밍\n1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.\npackage main import \u0026#34;os\u0026#34; func main() { f, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } 2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.이것은 콜스택을 따라 상위함수에도 모두 적용.마지막에는 프로그램이 에러를 내고 종료된다.\npackage main import \u0026#34;os\u0026#34; func main() { // 잘못된 파일명을 넣음  openFile(\u0026#34;Invalid.txt\u0026#34;) // openFile() 안에서 panic이 실행되면  // 아래 println 문장은 실행 안됨  println(\u0026#34;Done\u0026#34;) } func openFile(fn string) { f, err := os.Open(fn) if err != nil { panic(err) } defer f.Close() } 3. recover panic 상태를 다시 정상으로 돌리는 함수.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 잘못된 파일명을 넣음  openFile(\u0026#34;Invalid.txt\u0026#34;) // recover에 의해  // 이 문장 실행됨  println(\u0026#34;Done\u0026#34;) } func openFile(fn string) { // defer 함수. panic 호출시 실행됨  defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;OPEN ERROR\u0026#34;, r) } }() f, err := os.Open(fn) if err != nil { panic(err) } defer f.Close() } ","permalink":"https://icecat471.github.io/devlog/post/golang/defer_and_panic/","summary":"출처: 예제로 배우는 Go 프로그래밍\n1. defer 특정 문장 혹은 함수를 defer를 호출하는 함수가 return하기 직전에 실행하게 한다.\npackage main import \u0026#34;os\u0026#34; func main() { f, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } // main 마지막에 파일 close 실행  defer f.Close() // 파일 읽기  bytes := make([]byte, 1024) f.Read(bytes) println(len(bytes)) } 2. panic 함수를 즉시 멈추고 defer를 모두 실행한 뒤 즉시 리턴.이것은 콜스택을 따라 상위함수에도 모두 적용.","title":"Go언어 defer와 panic"},{"content":"golang flag package\ncommand-line flag를 파싱해주는 패키지.\n// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(\u0026#34;max\u0026#34;, 10, \u0026#34;Defines maximum value\u0026#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(\u0026amp;minValue, \u0026#34;min\u0026#34;, 0, \u0026#34;Defines minimum value\u0026#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() ","permalink":"https://icecat471.github.io/devlog/post/golang/flag/","summary":"golang flag package\ncommand-line flag를 파싱해주는 패키지.\n// flag값에 저장된 int64변수의 주소값 반환 maxValue := flag.Int64(\u0026#34;max\u0026#34;, 10, \u0026#34;Defines maximum value\u0026#34;) /* xxxVar() 함수는 반환값이 없고 첫번째 인자로 변수의 포인터를 넘겨주면 변수에 값을 할당해줌. */ var minValue int64 flag.Int64Var(\u0026amp;minValue, \u0026#34;min\u0026#34;, 0, \u0026#34;Defines minimum value\u0026#34;) // flag에 command-line 파싱 // 꼭 호출해주어야 함 flag.Parse() ","title":"Go언어 flag 패키지를 통한 command-line flag 파싱"},{"content":"go.mod 파일에서\nrequire ( \u0026lt;모듈명\u0026gt; v0.0.0 ) replace \u0026lt;모듈명\u0026gt; v0.0.0 =\u0026gt; ../module // 이런 형태로 경로를 지정해줌 ","permalink":"https://icecat471.github.io/devlog/post/golang/external_module/","summary":"go.mod 파일에서\nrequire ( \u0026lt;모듈명\u0026gt; v0.0.0 ) replace \u0026lt;모듈명\u0026gt; v0.0.0 =\u0026gt; ../module // 이런 형태로 경로를 지정해줌 ","title":"Go언어 프로젝트 외부의 모듈 import하기"},{"content":"참고: Unity Document WebGL\nbuild시 생성되는 unityInstance에 메세지를 보내서 호출.\nunityInstace.SendMessage(\u0026#39;오브젝트명\u0026#39;, \u0026#39;함수명\u0026#39;); ","permalink":"https://icecat471.github.io/devlog/post/unity/call_unity_func_in_js/","summary":"참고: Unity Document WebGL\nbuild시 생성되는 unityInstance에 메세지를 보내서 호출.\nunityInstace.SendMessage(\u0026#39;오브젝트명\u0026#39;, \u0026#39;함수명\u0026#39;); ","title":"브라우저에서 유니티 함수 호출하기"},{"content":"참고: Unity Document WebGL\nAssets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다\n// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(\u0026#34;Hello, world!\u0026#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i \u0026lt; size; i++) console.log(HEAPF32[(array \u0026gt;\u0026gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = \u0026#34;bla\u0026#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.bindTexture(GLctx.TEXTURE_2D, GL.textures[texture]); }, }); using UnityEngine; using System.Runtime.InteropServices; public class NewBehaviourScript : MonoBehaviour { [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void Hello(); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void HelloString(string str); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void PrintFloatArray(float[] array, int size); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern int AddNumbers(int x, int y); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern string StringReturnValueFunction(); [DllImport(\u0026#34;__Internal\u0026#34;)] private static extern void BindWebGLTexture(int texture); void Start() { Hello(); HelloString(\u0026#34;This is a string.\u0026#34;); float[] myArray = new float[10]; PrintFloatArray(myArray, myArray.Length); int result = AddNumbers(5, 7); Debug.Log(result); Debug.Log(StringReturnValueFunction()); var texture = new Texture2D(0, 0, TextureFormat.ARGB32, false); BindWebGLTexture(texture.GetNativeTextureID()); } } if(Application.platform == RuntimePlatform.WebGLPlayer) { Hello(); } ","permalink":"https://icecat471.github.io/devlog/post/unity/call_javascript/","summary":"참고: Unity Document WebGL\nAssets/Plugins 폴더를 만들고 Plugin.jslib 파일을 만든다\n// Plugin.jslib  mergeInto(LibraryManager.library, { Hello: function () { window.alert(\u0026#34;Hello, world!\u0026#34;); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, PrintFloatArray: function (array, size) { for(var i = 0; i \u0026lt; size; i++) console.log(HEAPF32[(array \u0026gt;\u0026gt; 2) + i]); }, AddNumbers: function (x, y) { return x + y; }, StringReturnValueFunction: function () { var returnStr = \u0026#34;bla\u0026#34;; var bufferSize = lengthBytesUTF8(returnStr) + 1; var buffer = _malloc(bufferSize); stringToUTF8(returnStr, buffer, bufferSize); return buffer; }, BindWebGLTexture: function (texture) { GLctx.","title":"유니티 WebGL 자바스크립트 함수 호출"},{"content":"아래처럼 나올 때\nzsh: command not found: dotnet dotnet package를 설치했다면/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인./usr/local/bin 경로에 링크를 만들어주면 된다.ln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow\n","permalink":"https://icecat471.github.io/devlog/post/unity/command_not_found_dotnet/","summary":"아래처럼 나올 때\nzsh: command not found: dotnet dotnet package를 설치했다면/usr/local/share/dotnet 경로에 설치되어 있는 것을 확인./usr/local/bin 경로에 링크를 만들어주면 된다.ln -s /usr/local/share/dotnet/dotnet /usr/local/bin 출처: stackoverflow","title":"터미널에서 command not found: dotnet 에러"},{"content":"webGL \u0026ldquo;build and run\u0026rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림로컬에서 서버를 열어서 실행해볼 수 있다.\nhttp-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.\n","permalink":"https://icecat471.github.io/devlog/post/unity/local_server/","summary":"webGL \u0026ldquo;build and run\u0026rdquo; 버튼을 눌러서 실행하면 빌드가 다시 되기때문에 시간이 오래걸림로컬에서 서버를 열어서 실행해볼 수 있다.\nhttp-server 설치 $ npm i -g http-server 실행 // 유니티 빌드 폴더로 이동 $ http-server Starting up http-server, serving ./ Available on: http://127.0.0.1:8080 http://120.50.93.152:8080 http://192.168.2.1:8080 Hit CTRL-C to stop the server http://localhost:8080 로 접속해보면 게임이 실행된것을 확인해 볼 수 있다.","title":"유니티 webGL 프로젝트 로컬서버에서 실행하기"},{"content":"// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 \u0026lt;image name\u0026gt; // stat 확인 docker stats \u0026lt;container id\u0026gt; ","permalink":"https://icecat471.github.io/devlog/post/docker/docker_memory_limit/","summary":"// 512MB의 메모리와 50%의 CPU 할당 docker run -m 512m --cpu-quota=50000 \u0026lt;image name\u0026gt; // stat 확인 docker stats \u0026lt;container id\u0026gt; ","title":"Docker 컨테이너 메모리 및 CPU 제한하기"},{"content":"출처: IALY\u0026rsquo;s BLOG\n1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown 2. Hugo Project 생성 hugo new site \u0026lt;프로젝트명\u0026gt; 3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.\n원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운\n$ git clone \u0026lt;테마 깃허브 주소\u0026gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.)config 파일 예시는 각 테마 깃허브에서 확인 가능.\n# config.ymlbaseURL:\u0026#34;https://\u0026lt;userid.github.io\u0026gt;/\u0026lt;repo name\u0026gt;/\u0026#34;title:\u0026#34;블로그 타이틀\u0026#34;theme:\u0026#34;테마명\u0026#34;# /themes 폴더에 다운 받은 테마폴더명4. 포스팅 하기 프로젝트 내에서\n$ hugo new \u0026lt;파일이름\u0026gt; ex) hugo new post/test.md 라고 입력하면content 폴더내부에 content/post/test.md 경로로 파일 생성.5. 로컬서버에서 블로그 확인 $ hugo server -D -D 옵션을 주면 draft: true인 글도 확인가능하다.기본적으로 http://localhost:1313/ 로 확인 가능. 6. build 및 push hugo project를 push할 repo와 빌드한 public 파일을 push할 repo를 따로 만든다.프로젝트 루트에서$ git init $ git remote add origin \u0026lt;첫번째 repo\u0026gt; // 두번째 repo를 첫번째 repo의 submodule로 지정 $ git submodule add -b master \u0026lt;두번째 repo\u0026gt; public // build $ hugo // push $ cd public $ git add . $ git commit -m \u0026#34;\u0026lt;커밋 메세지\u0026gt;\u0026#34; $ git push origin master $ cd .. $ git add . $ git commit -m \u0026#34;\u0026lt;커밋 메세지\u0026gt;\u0026#34; $ git push origin master ","permalink":"https://icecat471.github.io/devlog/post/hugo/start_hugo/","summary":"출처: IALY\u0026rsquo;s BLOG\n1. Hugo 설치  MacOS  // 설치 $ brew install hugo // 설치 확인 $ hugo version hugo v0.82.0+extended darwin/amd64 BuildDate=unknown 2. Hugo Project 생성 hugo new site \u0026lt;프로젝트명\u0026gt; 3. Hugo 테마 다운로드 휴고 테마 사이트 위 사이트에서 원하는 테마를 확인 가능.\n원하는 테마를 찾으면 프로젝트의 /themes 폴더에서 아래 명령어로 다운\n$ git clone \u0026lt;테마 깃허브 주소\u0026gt; 그 후 config.toml 파일 수정 (여기서는 config.yml 파일로 변경하였다.)config 파일 예시는 각 테마 깃허브에서 확인 가능.","title":"Hugo로 블로그 시작하기"}]