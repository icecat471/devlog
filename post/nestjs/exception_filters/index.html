<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[NestJS] (공식문서 번역) Exception Filters | icecat471&#39;s Devlog</title>
<meta name="keywords" content="NestJS, backend" />
<meta name="description" content="NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/exception-filters
Exception filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.
특히, 이것은 HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.
{ &#34;statusCode&#34;: 500, &#34;message&#34;: &#34;Internal server error&#34; } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다.">
<meta name="author" content="icecat471">
<link rel="canonical" href="https://icecat471.github.io/devlog/post/nestjs/exception_filters/" />
<link crossorigin="anonymous" href="/devlog/assets/css/stylesheet.min.5ddba2377cef4826c901d6600bb403811fc5084e4de37bd1a967782b2b74485f.css" integrity="sha256-XduiN3zvSCbJAdZgC7QDgR/FCE5N43vRqWd4Kyt0SF8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/devlog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://icecat471.github.io/devlog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://icecat471.github.io/devlog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://icecat471.github.io/devlog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://icecat471.github.io/devlog/apple-touch-icon.png">
<link rel="mask-icon" href="https://icecat471.github.io/devlog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="[NestJS] (공식문서 번역) Exception Filters" />
<meta property="og:description" content="NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/exception-filters
Exception filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.
특히, 이것은 HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.
{ &#34;statusCode&#34;: 500, &#34;message&#34;: &#34;Internal server error&#34; } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://icecat471.github.io/devlog/post/nestjs/exception_filters/" /><meta property="og:image" content="https://icecat471.github.io/devlog/papermod-cover.png"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-03T23:49:12&#43;09:00" />
<meta property="article:modified_time" content="2021-05-03T23:49:12&#43;09:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://icecat471.github.io/devlog/papermod-cover.png"/>

<meta name="twitter:title" content="[NestJS] (공식문서 번역) Exception Filters"/>
<meta name="twitter:description" content="NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/exception-filters
Exception filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.
특히, 이것은 HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.
{ &#34;statusCode&#34;: 500, &#34;message&#34;: &#34;Internal server error&#34; } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://icecat471.github.io/devlog/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[NestJS] (공식문서 번역) Exception Filters",
      "item": "https://icecat471.github.io/devlog/post/nestjs/exception_filters/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[NestJS] (공식문서 번역) Exception Filters",
  "name": "[NestJS] (공식문서 번역) Exception Filters",
  "description": "NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/exception-filters\nException filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.\n특히, 이것은 \u0008HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.\n{ \u0026#34;statusCode\u0026#34;: 500, \u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34; } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다.",
  "keywords": [
    "NestJS", "backend"
  ],
  "articleBody": "NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/exception-filters\nException filters Exception filters Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.\n특히, 이것은 \u0008HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.\n{ \"statusCode\": 500, \"message\": \"Internal server error\" } Throwing standard exceptions Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다. 일반적인 HTTP REST/GraphQL API 기반의 애플리케이션에서 특정 에러가 발생했을 때, 표준 HTTP response object를 보내는 것이 좋은 방법이다.예를 들어, CatsController에 findAll() method를 정의하였다. 이 route handler가 어떠한 이유에 의해 예외를 throw 했다고 가정해보자.\n// cats.controller.ts  @Get() async findAll() { throw new HttpException('Forbidden', HttpStatus.FORBIDDEN); } 클라이언트가 이 엔드포인트를 호출하면, 아래와 같은 응답이 전송될 것이다.\n{ \"statusCode\": 403, \"message\": \"Forbidden\" } HttpException class의 생성자는 두 개의 인자를 필수로 받는다.\n JSON response body를 정의하는데 필요한, string 또는 object 타입. HTTP status code로 정의된 status.  기본적으로 JSON response body는 두개의 property로 구성된다.\n statusCode: 기본적으로 status 인자로 받은 HTTP status code 값. message: status에 따른 짧은 HTTP 에러에 대한 메세지  message만을 override 하기 위해서는 response 인자에 string 값을 전달하면 된다. 전체 JSON body를 override 하려면 response 인자로 object를 전달한다. Nest는 object를 직렬화하여 JSON body로 변환할 것이다.2번째 인자인 status는 유효한 HTTP status code 이어야 한다. 가장 좋은 방법은 HttpStatus enum을 사용하는 것이다.\n// cats.controller.ts  @Get() async findAll() { throw new HttpException({ status: HttpStatus.FORBIDDEN, error: 'This is a custom message', }, HttpStatus.FORBIDDEN); } 위의 예제는 아래와 같은 response를 전송할 것이다.\n{ \"status\": 403, \"error\": \"This is a custom message\" } Custom Exceptions 많은 경우, custom exception을 사용하는 대신, Nest HTTP exception을 사용하면 된다. 만약 custom exception이 필요한 경우 HttpException 클래스를 상속받아 exception hierarchy를 만드는 것이 좋다. 이러한 접근법을 사용하면 Nest는 custom exception을 인식하고 자동으로 관리해 줄 것이다.\n// forbidden.exception.ts  export class ForbiddenException extends HttpException { constructor() { super('Forbidden', HttpStatus.FORBIDDEN); } } 기본 HttpException을 상속했기때문에 내장 exception handler에 의해 같은 방식으로 동작한다.\n// cats.controller.ts  @Get() async findAll() { throw new ForbiddenException(); } Built-in HTTP Exceptions Nest는 HttpException class를 상속받은 standard exception 세트를 제공한다.\n BadRequestException UnauthorizedException NotFoundException ForbiddenException NotAcceptableException RequestTimeoutException ConflictException GoneException HttpVersionNotSupportedException PayloadTooLargeException UnsupportedMediaTypeException UnprocessableEntityException InternalServerErrorException NotImplementedException ImATeapotException MethodNotAllowedException BadGatewayException ServiceUnavailableException GatewayTimeoutException PreconditionFailedException  Exception filters 내장 exception filter에 의해 대부분의 예외가 자동으로 핸들링 되지만, exception layer를 컨트롤 하고 싶은 경우가 생긴다. 예를 들어, 로그를 추가하거나 기본 JSON 형태를 변경하고 싶은 경우이다. exception filter는 이러한 목적을 위해 디자인 되었다. 이것들은 올바른 흐름통제와 response의 콘텐츠를 제공해준다.HttpException class의 예외를 캐치하는 exception filter를 만들어보자. 이것을 위해 우리는 platform 기반의 request와 response object에 접근할 필요가 있다. 우리는 request object에 접근하여 original url을 사용하여 로그를 남길것이다. response object는 직접 컨트롤하여 response.json() method를 통해 전송할 것이다.\n// http-exception.filter.ts  import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch(HttpException) export class HttpExceptionFilter implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponseResponse(); const request = ctx.getRequestRequest(); const status = exception.getStatus(); response .status(status) .json({ statusCode: status, timestamp: new Date().toISOString(), path: request.url, }); } }  모든 exception filter는 ExceptionFilterinterface를 구현해야한다. 이를 통해 catch(exception: T, host: ArgumentsHost) method를 제공받는다.\n @Catch(HttpException) 데코레이터는 exception filter에 필요한 메타데이터를 bind하고 있어서 Nest에게 특정 filter가 HttpException임을 알려준다. @Catch() 데코레이터는 단일 혹은 콤마로 구분된 여러개의 인자를 받는다. 이를 통해 여러가지 예외를 필터에 적용할 수 있다.\nArguments host catch() method를 살펴보자. exception 파라미터는 현재 처리되고 있는 예외이다. host parameter는 ArgumentsHost obejct이다. ArgumentHost는 execution context 챕터에서 자세히 알아보자. 위의 예제에서는 request와 response object의 참조값을 얻기 위해 사용되었다.\nBinding filters 새로 만든 HttpExceptionFilter를 CatsController에 적용해보자.\n// cats.controller.ts  @Post() @UseFilters(new HttpExceptionFilter()) async create(@Body() createCatDto: CreateCatDto) { throw new ForbiddenException(); } @UseFilter() 데코레이터는 @Catch() 데코레이터와 유사하게, 단일 filter 인스턴스 또는 여러개의 filter 인스턴스 리스트를 받는다. 위의 예제에서는 새로운 HttpExceptionFilter 인스턴스를 만들어서 넣어주었다. 인스턴스 대신, 클래스를 넣어도 dependency injection에 의해 인스턴스화 된다.\n// cats.controller.ts  @Post() @UseFilters(HttpExceptionFilter) async create(@Body() createCatDto: CreateCatDto) { throw new ForbiddenException(); }  가능하면 인스턴스를 넣는것보다 클래스를 넣자. 그러면 Nest는 같은 클래스의 인스턴스를 다른 모듈에서 재사용하여 메모리낭비를 줄일 수 있다.\n 위 예제에서, HttpExceptionFilter는 method-scope로 하나의 create() route handler에만 적용되었다. Exception filter는 다른 scope로 적용가능하다(method-scope, controller-scope, global-scope 등). 예를 들어, filter를 controller-scope로 적용하고 싶다면 아래의 예제처럼 하면 된다.\n// cats.controller.ts  @UseFilters(new HttpExceptionFilter()) export class CatsController {} 이러한 구조는 \u0008HttpExceptionFilter를 CatsController 내의 모든 route handler에 정의해준다.global-scope로 적용하기 위해서는, 아래의 예제처럼 적용한다.\n// app.module.ts  async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000); } bootstrap();  useGlobalFilters() method는 gateway나 hybrid application에 적용되지 않는다.\n global-scope filter는 모든 controller와 route handler에 적용된다. module 외부에서 등록된 global filter(위의 예제처럼, useGlobalFilters()를 적용하는 경우)는 module context 외부에서 완료되기 때문에 dependency를 주입할 수 없다. 이것을 해결하기 위해, global-scope filter를 직접 module에 등록할 수 있다.\n// app.module.ts  import { Module } from '@nestjs/common'; import { APP_FILTER } from '@nestjs/core'; @Module({ providers: [ { provide: APP_FILTER, useClass: HttpExceptionFilter, }, ], }) export class AppModule {}  DI를 위해 이러한 접근법을 사용하면, 어떠한 module에서 사용되었든 filter는 global이다.\n 위와 같은 방법으로 array 형태의 여러개의 filter를 등록가능하다.\nCatch everything 모든 예외를 핸들링하고 싶다면, @Catch() 데코레이터의 인자를 비워두면 된다.\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus, } from '@nestjs/common'; @Catch() export class AllExceptionsFilter implements ExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); const request = ctx.getRequest(); const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; response.status(status).json({ statusCode: status, timestamp: new Date().toISOString(), path: request.url, }); } } 위의 에제에서 filter는 예외의 타입에 관계없이 모든 예외를 처리한다.\nInheritance 일반적으로, 애플리케이션의 요구사항에 충족하는 완전히 커스터마이징 된 filter를 만들것이다. 그러나, 내장된 기본 global exception filter를 상속하여 일부분을 override하여 사용할 수도 있다.base filter를 이용하려면, BaseExceptionFilter를 상속받고, 상속받은 catch() method를 호출한다.\n// all-exception.filter.ts  import { Catch, ArgumentsHost } from '@nestjs/common'; import { BaseExceptionFilter } from '@nestjs/core'; @Catch() export class AllExceptionsFilter extends BaseExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { super.catch(exception, host); } }  BaseExceptionFilter를 상속받은 method-scope filter와 controller-scope filter는 new를 통해 인스턴스화 하면 안된다. 대신, 프레임워크가 자동으로 인스턴스화 할 것이다.\n global filter도 base filter를 상속받을 수 있다. 이것에는 두가지 방법이 있다.첫번째 방법은, custom global filter가 인스턴스화 될 때, http server에 injection 하는 방법이다.\nasync function bootstrap() { const app = await NestFactory.create(AppModule); const { httpAdapter } = app.get(HttpAdapterHost); app.useGlobalFilters(new AllExceptionsFilter(httpAdapter)); await app.listen(3000); } bootstrap(); 두번째 방법은, 여기에서 설명한 것처럼 APP_FILTER를 사용하는 것이다.\n",
  "wordCount" : "1018",
  "inLanguage": "en",
  "datePublished": "2021-05-03T23:49:12+09:00",
  "dateModified": "2021-05-03T23:49:12+09:00",
  "author":{
    "@type": "Person",
    "name": "icecat471"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://icecat471.github.io/devlog/post/nestjs/exception_filters/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "icecat471's Devlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://icecat471.github.io/devlog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://icecat471.github.io/devlog/" accesskey="h" title="icecat471&#39;s Devlog (Alt + H)">icecat471&#39;s Devlog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://icecat471.github.io/devlog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://icecat471.github.io/devlog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://icecat471.github.io/devlog/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://icecat471.github.io/devlog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://icecat471.github.io/devlog/">Home</a>&nbsp;»&nbsp;<a href="https://icecat471.github.io/devlog/post/">Posts</a></div>
    <h1 class="post-title">
      [NestJS] (공식문서 번역) Exception Filters
    </h1>
    <div class="post-meta">May 3, 2021&nbsp;·&nbsp;5 min&nbsp;·&nbsp;icecat471

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#exception-filters" aria-label="Exception filters">Exception filters</a><ul>
                        
                <li>
                    <a href="#exception-filters-1" aria-label="Exception filters">Exception filters</a></li>
                <li>
                    <a href="#throwing-standard-exceptions" aria-label="Throwing standard exceptions">Throwing standard exceptions</a></li>
                <li>
                    <a href="#custom-exceptions" aria-label="Custom Exceptions">Custom Exceptions</a></li>
                <li>
                    <a href="#built-in-http-exceptions" aria-label="Built-in HTTP Exceptions">Built-in HTTP Exceptions</a></li>
                <li>
                    <a href="#exception-filters-2" aria-label="Exception filters">Exception filters</a></li>
                <li>
                    <a href="#arguments-host" aria-label="Arguments host">Arguments host</a></li>
                <li>
                    <a href="#binding-filters" aria-label="Binding filters">Binding filters</a></li>
                <li>
                    <a href="#catch-everything" aria-label="Catch everything">Catch everything</a></li>
                <li>
                    <a href="#inheritance" aria-label="Inheritance">Inheritance</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>NestJS 공식문서 번역 겸 공부하는 글 입니다.<br>
의역 및 오역이 있을 수 있습니다.<br>
<a href="https://docs.nestjs.com/exception-filters">https://docs.nestjs.com/exception-filters</a></p>
<h1 id="exception-filters">Exception filters<a hidden class="anchor" aria-hidden="true" href="#exception-filters">#</a></h1>
<h2 id="exception-filters-1">Exception filters<a hidden class="anchor" aria-hidden="true" href="#exception-filters-1">#</a></h2>
<p>Nest에는 핸들링 되지 않은 예외를 처리해주는 exception layer가 내장되어 있다. 코드에서 예외를 처리해주지 않았다면 이 layer에서 예외를 캐치하여 자동으로 유저친화적인 response를 전송한다.</p>
<p><img loading="lazy" src="../../../img/nestjs/exception_filters01.png" alt="exception layer"  />
</p>
<p>특히, 이것은 HttpException과 서브클래스들을 핸들링하는 global exception filter에 의해 수행된다. 예외가 인식되지 않을 때(HttpException과 그 서브클래스가 아닌 경우), exception filter는 자동으로 아래의 데이터를 JSON 형식으로 response한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;statusCode&#34;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
  <span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;Internal server error&#34;</span>
<span class="p">}</span>
</code></pre></div><h2 id="throwing-standard-exceptions">Throwing standard exceptions<a hidden class="anchor" aria-hidden="true" href="#throwing-standard-exceptions">#</a></h2>
<p>Nest는 @nestjs/common 패키지를 통해, HttpException class를 제공한다. 일반적인 HTTP REST/GraphQL API 기반의 애플리케이션에서 특정 에러가 발생했을 때, 표준 HTTP response object를 보내는 것이 좋은 방법이다.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>예를 들어, CatsController에 findAll() method를 정의하였다. 이 route handler가 어떠한 이유에 의해 예외를 throw 했다고 가정해보자.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findAll() {</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nx">HttpException</span><span class="p">(</span><span class="s1">&#39;Forbidden&#39;</span><span class="p">,</span> <span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">FORBIDDEN</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>클라이언트가 이 엔드포인트를 호출하면, 아래와 같은 응답이 전송될 것이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;statusCode&#34;</span><span class="p">:</span> <span class="mi">403</span><span class="p">,</span>
  <span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;Forbidden&#34;</span>
<span class="p">}</span>
</code></pre></div><p>HttpException class의 생성자는 두 개의 인자를 필수로 받는다.</p>
<ul>
<li>JSON response body를 정의하는데 필요한, string 또는 object 타입.</li>
<li>HTTP status code로 정의된 status.</li>
</ul>
<p>기본적으로 JSON response body는 두개의 property로 구성된다.</p>
<ul>
<li>statusCode: 기본적으로 status 인자로 받은 HTTP status code 값.</li>
<li>message: status에 따른 짧은 HTTP 에러에 대한 메세지</li>
</ul>
<p>message만을 override 하기 위해서는 response 인자에 string 값을 전달하면 된다. 전체 JSON body를 override 하려면 response 인자로 object를 전달한다. Nest는 object를 직렬화하여 JSON body로 변환할 것이다.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>2번째 인자인 status는 유효한 HTTP status code 이어야 한다. 가장 좋은 방법은 HttpStatus enum을 사용하는 것이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findAll() {</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nx">HttpException</span><span class="p">({</span>
    <span class="nx">status</span>: <span class="kt">HttpStatus.FORBIDDEN</span><span class="p">,</span>
    <span class="nx">error</span><span class="o">:</span> <span class="s1">&#39;This is a custom message&#39;</span><span class="p">,</span>
  <span class="p">},</span> <span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">FORBIDDEN</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>위의 예제는 아래와 같은 response를 전송할 것이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="mi">403</span><span class="p">,</span>
  <span class="nt">&#34;error&#34;</span><span class="p">:</span> <span class="s2">&#34;This is a custom message&#34;</span>
<span class="p">}</span>
</code></pre></div><h2 id="custom-exceptions">Custom Exceptions<a hidden class="anchor" aria-hidden="true" href="#custom-exceptions">#</a></h2>
<p>많은 경우, custom exception을 사용하는 대신, Nest HTTP exception을 사용하면 된다. 만약 custom exception이 필요한 경우 HttpException 클래스를 상속받아 exception hierarchy를 만드는 것이 좋다. 이러한 접근법을 사용하면 Nest는 custom exception을 인식하고 자동으로 관리해 줄 것이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// forbidden.exception.ts
</span><span class="c1"></span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">ForbiddenException</span> <span class="kr">extends</span> <span class="nx">HttpException</span> <span class="p">{</span>
  <span class="kr">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="s1">&#39;Forbidden&#39;</span><span class="p">,</span> <span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">FORBIDDEN</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>기본 HttpException을 상속했기때문에 내장 exception handler에 의해 같은 방식으로 동작한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findAll() {</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nx">ForbiddenException</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="built-in-http-exceptions">Built-in HTTP Exceptions<a hidden class="anchor" aria-hidden="true" href="#built-in-http-exceptions">#</a></h2>
<p>Nest는 HttpException class를 상속받은 standard exception 세트를 제공한다.</p>
<ul>
<li>BadRequestException</li>
<li>UnauthorizedException</li>
<li>NotFoundException</li>
<li>ForbiddenException</li>
<li>NotAcceptableException</li>
<li>RequestTimeoutException</li>
<li>ConflictException</li>
<li>GoneException</li>
<li>HttpVersionNotSupportedException</li>
<li>PayloadTooLargeException</li>
<li>UnsupportedMediaTypeException</li>
<li>UnprocessableEntityException</li>
<li>InternalServerErrorException</li>
<li>NotImplementedException</li>
<li>ImATeapotException</li>
<li>MethodNotAllowedException</li>
<li>BadGatewayException</li>
<li>ServiceUnavailableException</li>
<li>GatewayTimeoutException</li>
<li>PreconditionFailedException</li>
</ul>
<h2 id="exception-filters-2">Exception filters<a hidden class="anchor" aria-hidden="true" href="#exception-filters-2">#</a></h2>
<p>내장 exception filter에 의해 대부분의 예외가 자동으로 핸들링 되지만, exception layer를 컨트롤 하고 싶은 경우가 생긴다. 예를 들어, 로그를 추가하거나 기본 JSON 형태를 변경하고 싶은 경우이다. exception filter는 이러한 목적을 위해 디자인 되었다. 이것들은 올바른 흐름통제와 response의 콘텐츠를 제공해준다.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>HttpException class의 예외를 캐치하는 exception filter를 만들어보자. 이것을 위해 우리는 platform 기반의 request와 response object에 접근할 필요가 있다. 우리는 request object에 접근하여 original url을 사용하여 로그를 남길것이다. response object는 직접 컨트롤하여 response.json() method를 통해 전송할 것이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// http-exception.filter.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">ExceptionFilter</span><span class="p">,</span> <span class="nx">Catch</span><span class="p">,</span> <span class="nx">ArgumentsHost</span><span class="p">,</span> <span class="nx">HttpException</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Request</span><span class="p">,</span> <span class="nx">Response</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;express&#39;</span><span class="p">;</span>

<span class="kd">@Catch</span><span class="p">(</span><span class="nx">HttpException</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">HttpExceptionFilter</span> <span class="kr">implements</span> <span class="nx">ExceptionFilter</span> <span class="p">{</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">exception</span>: <span class="kt">HttpException</span><span class="p">,</span> <span class="nx">host</span>: <span class="kt">ArgumentsHost</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">host</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">();</span>
    <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getResponse</span><span class="p">&lt;</span><span class="nt">Response</span><span class="p">&gt;();</span>
    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getRequest</span><span class="p">&lt;</span><span class="nt">Request</span><span class="p">&gt;();</span>
    <span class="kr">const</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">exception</span><span class="p">.</span><span class="nx">getStatus</span><span class="p">();</span>

    <span class="nx">response</span>
      <span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="nx">status</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">json</span><span class="p">({</span>
        <span class="nx">statusCode</span>: <span class="kt">status</span><span class="p">,</span>
        <span class="nx">timestamp</span>: <span class="kt">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">toISOString</span><span class="p">(),</span>
        <span class="nx">path</span>: <span class="kt">request.url</span><span class="p">,</span>
      <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>모든 exception filter는 ExceptionFilter<!-- raw HTML omitted --> interface를 구현해야한다. 이를 통해 catch(exception: T, host: ArgumentsHost) method를 제공받는다.</p>
</blockquote>
<p>@Catch(HttpException) 데코레이터는 exception filter에 필요한 메타데이터를 bind하고 있어서 Nest에게 특정 filter가 HttpException임을 알려준다. @Catch() 데코레이터는 단일 혹은 콤마로 구분된 여러개의 인자를 받는다. 이를 통해 여러가지 예외를 필터에 적용할 수 있다.</p>
<h2 id="arguments-host">Arguments host<a hidden class="anchor" aria-hidden="true" href="#arguments-host">#</a></h2>
<p>catch() method를 살펴보자. exception 파라미터는 현재 처리되고 있는 예외이다. host parameter는 ArgumentsHost obejct이다. ArgumentHost는 <a href="https://docs.nestjs.com/fundamentals/execution-context">execution context 챕터</a>에서 자세히 알아보자. 위의 예제에서는 request와 response object의 참조값을 얻기 위해 사용되었다.</p>
<h2 id="binding-filters">Binding filters<a hidden class="anchor" aria-hidden="true" href="#binding-filters">#</a></h2>
<p>새로 만든 HttpExceptionFilter를 CatsController에 적용해보자.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Post</span><span class="p">()</span>
<span class="kd">@UseFilters</span><span class="p">(</span><span class="k">new</span> <span class="nx">HttpExceptionFilter</span><span class="p">())</span>
<span class="kr">async</span> <span class="nx">create</span><span class="p">(</span><span class="kd">@Body</span><span class="p">()</span> <span class="nx">createCatDto</span>: <span class="kt">CreateCatDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nx">ForbiddenException</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>@UseFilter() 데코레이터는 @Catch() 데코레이터와 유사하게, 단일 filter 인스턴스 또는 여러개의 filter 인스턴스 리스트를 받는다. 위의 예제에서는 새로운 HttpExceptionFilter 인스턴스를 만들어서 넣어주었다. 인스턴스 대신, 클래스를 넣어도 dependency injection에 의해 인스턴스화 된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Post</span><span class="p">()</span>
<span class="kd">@UseFilters</span><span class="p">(</span><span class="nx">HttpExceptionFilter</span><span class="p">)</span>
<span class="kr">async</span> <span class="nx">create</span><span class="p">(</span><span class="kd">@Body</span><span class="p">()</span> <span class="nx">createCatDto</span>: <span class="kt">CreateCatDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nx">ForbiddenException</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>가능하면 인스턴스를 넣는것보다 클래스를 넣자. 그러면 Nest는 같은 클래스의 인스턴스를 다른 모듈에서 재사용하여 메모리낭비를 줄일 수 있다.</p>
</blockquote>
<p>위 예제에서, HttpExceptionFilter는 method-scope로 하나의 create() route handler에만 적용되었다. Exception filter는 다른 scope로 적용가능하다(method-scope, controller-scope, global-scope 등). 예를 들어, filter를 controller-scope로 적용하고 싶다면 아래의 예제처럼 하면 된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@UseFilters</span><span class="p">(</span><span class="k">new</span> <span class="nx">HttpExceptionFilter</span><span class="p">())</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{}</span>
</code></pre></div><p>이러한 구조는 HttpExceptionFilter를 CatsController 내의 모든 route handler에 정의해준다.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>global-scope로 적용하기 위해서는, 아래의 예제처럼 적용한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// app.module.ts
</span><span class="c1"></span>
<span class="kr">async</span> <span class="kd">function</span> <span class="nx">bootstrap() {</span>
  <span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">NestFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">);</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">useGlobalFilters</span><span class="p">(</span><span class="k">new</span> <span class="nx">HttpExceptionFilter</span><span class="p">());</span>
  <span class="k">await</span> <span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">bootstrap</span><span class="p">();</span>
</code></pre></div><blockquote>
<p>useGlobalFilters() method는 gateway나 hybrid application에 적용되지 않는다.</p>
</blockquote>
<p>global-scope filter는 모든 controller와 route handler에 적용된다. module 외부에서 등록된 global filter(위의 예제처럼, useGlobalFilters()를 적용하는 경우)는 module context 외부에서 완료되기 때문에 dependency를 주입할 수 없다. 이것을 해결하기 위해, global-scope filter를 직접 module에 등록할 수 있다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// app.module.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Module</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">APP_FILTER</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/core&#39;</span><span class="p">;</span>

<span class="kd">@Module</span><span class="p">({</span>
  <span class="nx">providers</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">provide</span>: <span class="kt">APP_FILTER</span><span class="p">,</span>
      <span class="nx">useClass</span>: <span class="kt">HttpExceptionFilter</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">],</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AppModule</span> <span class="p">{}</span>
</code></pre></div><blockquote>
<p>DI를 위해 이러한 접근법을 사용하면, 어떠한 module에서 사용되었든 filter는 global이다.</p>
</blockquote>
<p>위와 같은 방법으로 array 형태의 여러개의 filter를 등록가능하다.</p>
<h2 id="catch-everything">Catch everything<a hidden class="anchor" aria-hidden="true" href="#catch-everything">#</a></h2>
<p>모든 예외를 핸들링하고 싶다면, @Catch() 데코레이터의 인자를 비워두면 된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">import</span> <span class="p">{</span>
  <span class="nx">ExceptionFilter</span><span class="p">,</span>
  <span class="nx">Catch</span><span class="p">,</span>
  <span class="nx">ArgumentsHost</span><span class="p">,</span>
  <span class="nx">HttpException</span><span class="p">,</span>
  <span class="nx">HttpStatus</span><span class="p">,</span>
<span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="kd">@Catch</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AllExceptionsFilter</span> <span class="kr">implements</span> <span class="nx">ExceptionFilter</span> <span class="p">{</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">exception</span>: <span class="kt">unknown</span><span class="p">,</span> <span class="nx">host</span>: <span class="kt">ArgumentsHost</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">host</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">();</span>
    <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getResponse</span><span class="p">();</span>
    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getRequest</span><span class="p">();</span>

    <span class="kr">const</span> <span class="nx">status</span> <span class="o">=</span>
      <span class="nx">exception</span> <span class="k">instanceof</span> <span class="nx">HttpException</span>
        <span class="o">?</span> <span class="nx">exception</span><span class="p">.</span><span class="nx">getStatus</span><span class="p">()</span>
        <span class="o">:</span> <span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">INTERNAL_SERVER_ERROR</span><span class="p">;</span>

    <span class="nx">response</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="nx">status</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span>
      <span class="nx">statusCode</span>: <span class="kt">status</span><span class="p">,</span>
      <span class="nx">timestamp</span>: <span class="kt">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">toISOString</span><span class="p">(),</span>
      <span class="nx">path</span>: <span class="kt">request.url</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>위의 에제에서 filter는 예외의 타입에 관계없이 모든 예외를 처리한다.</p>
<h2 id="inheritance">Inheritance<a hidden class="anchor" aria-hidden="true" href="#inheritance">#</a></h2>
<p>일반적으로, 애플리케이션의 요구사항에 충족하는 완전히 커스터마이징 된 filter를 만들것이다. 그러나, 내장된 기본 global exception filter를 상속하여 일부분을 override하여 사용할 수도 있다.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>base filter를 이용하려면, BaseExceptionFilter를 상속받고, 상속받은 catch() method를 호출한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// all-exception.filter.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Catch</span><span class="p">,</span> <span class="nx">ArgumentsHost</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">BaseExceptionFilter</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/core&#39;</span><span class="p">;</span>

<span class="kd">@Catch</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AllExceptionsFilter</span> <span class="kr">extends</span> <span class="nx">BaseExceptionFilter</span> <span class="p">{</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">exception</span>: <span class="kt">unknown</span><span class="p">,</span> <span class="nx">host</span>: <span class="kt">ArgumentsHost</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">exception</span><span class="p">,</span> <span class="nx">host</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>BaseExceptionFilter를 상속받은 method-scope filter와 controller-scope filter는 new를 통해 인스턴스화 하면 안된다. 대신, 프레임워크가 자동으로 인스턴스화 할 것이다.</p>
</blockquote>
<p>global filter도 base filter를 상속받을 수 있다. 이것에는 두가지 방법이 있다.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>첫번째 방법은, custom global filter가 인스턴스화 될 때, http server에 injection 하는 방법이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">bootstrap() {</span>
  <span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">NestFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">);</span>

  <span class="kr">const</span> <span class="p">{</span> <span class="nx">httpAdapter</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">app</span><span class="p">.</span><span class="kr">get</span><span class="p">(</span><span class="nx">HttpAdapterHost</span><span class="p">);</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">useGlobalFilters</span><span class="p">(</span><span class="k">new</span> <span class="nx">AllExceptionsFilter</span><span class="p">(</span><span class="nx">httpAdapter</span><span class="p">));</span>

  <span class="k">await</span> <span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">bootstrap</span><span class="p">();</span>
</code></pre></div><p>두번째 방법은, <a href="#binding-filters">여기</a>에서 설명한 것처럼 APP_FILTER를 사용하는 것이다.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://icecat471.github.io/devlog/tags/nestjs/">NestJS</a></li>
      <li><a href="https://icecat471.github.io/devlog/tags/backend/">backend</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://icecat471.github.io/devlog/post/vuejs/dotenv_undefined/">
    <span class="title">« Prev Page</span>
    <br>
    <span>[Vue] dotenv 환경변수를 undefined로 불러올 때</span>
  </a>
  <a class="next" href="https://icecat471.github.io/devlog/post/nestjs/middleware/">
    <span class="title">Next Page »</span>
    <br>
    <span>[NestJS] (공식문서 번역) Middleware</span>
  </a>
</nav>

  </footer><script src="https://utteranc.es/client.js"
        repo="icecat471/devlog"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://icecat471.github.io/devlog/">icecat471&#39;s Devlog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
