<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[NestJS] (공식문서 번역) Controllers | icecat471&#39;s Devlog</title>
<meta name="keywords" content="NestJS, backend" />
<meta name="description" content="NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/controllers
Controllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.
routing mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다.">
<meta name="author" content="icecat471">
<link rel="canonical" href="https://icecat471.github.io/devlog/post/nestjs/controllers/" />
<link crossorigin="anonymous" href="/devlog/assets/css/stylesheet.min.06b0e077dc7b9f0b9b5296f5053df8edb6c3f609984056a0cc5249467ca8ba72.css" integrity="sha256-BrDgd9x7nwubUpb1BT347bbD9gmYQFagzFJJRnyounI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/devlog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://icecat471.github.io/devlog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://icecat471.github.io/devlog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://icecat471.github.io/devlog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://icecat471.github.io/devlog/apple-touch-icon.png">
<link rel="mask-icon" href="https://icecat471.github.io/devlog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.82.0" />
<meta property="og:title" content="[NestJS] (공식문서 번역) Controllers" />
<meta property="og:description" content="NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/controllers
Controllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.
routing mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://icecat471.github.io/devlog/post/nestjs/controllers/" /><meta property="og:image" content="https://icecat471.github.io/devlog/papermod-cover.png"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-01T20:48:45&#43;09:00" />
<meta property="article:modified_time" content="2021-05-01T20:48:45&#43;09:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://icecat471.github.io/devlog/papermod-cover.png"/>

<meta name="twitter:title" content="[NestJS] (공식문서 번역) Controllers"/>
<meta name="twitter:description" content="NestJS 공식문서 번역 겸 공부하는 글 입니다.
의역 및 오역이 있을 수 있습니다.
https://docs.nestjs.com/controllers
Controllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.
routing mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://icecat471.github.io/devlog/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[NestJS] (공식문서 번역) Controllers",
      "item": "https://icecat471.github.io/devlog/post/nestjs/controllers/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[NestJS] (공식문서 번역) Controllers",
  "name": "[NestJS] (공식문서 번역) Controllers",
  "description": "NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/controllers\nControllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.\nrouting mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다.",
  "keywords": [
    "NestJS", "backend"
  ],
  "articleBody": "NestJS 공식문서 번역 겸 공부하는 글 입니다.\n의역 및 오역이 있을 수 있습니다.\nhttps://docs.nestjs.com/controllers\nControllers Controllers Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.\nrouting mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.Routing 아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다. @Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다. 이 경우, @Controller(‘customers’) 데코레이터를 사용하여 쉽게 그룹화 가능하다.\n// cats.controller.ts  import { Controller, Get } from '@nestjs/common'; @Controller('cats') export class CatsController { @Get() findAll(): string { return 'This action returns all cats'; } } @Get() HTTP request method 데코레이터는 Nest에게 HTTP request의 특정 엔드포인트에 대한 핸들러를 만들도록 한다. 엔드포인트는 HTTP request method(위 예제에서는 GET), route path에 일치하는 경로로 라우팅 된다. route path란, controller에 선언된 prefix와 request decorator에 의해 특정된 path의 결합이다.\n예제에서 모든 route에 대한 prefix(cats)를 선언하였고, decorator에는 path 정보를 추가하지 않았으므로, Nest는 GET /cats에 대한 request를 해당 핸들러에 매핑할 것이다.\n만약, path prefix가 customers 이고, decorator가 @Get(‘profile’)인 경우는 GET /customers/profile 경로로 매핑될 것이다.\n위의 예제에서, 해당 엔드포인트에서 GET request가 만들어지면, Nest는 request를 findAll() method에 라우팅 할 것이다. method명은 임의로 지어진 것이다. 우리는 route에 bind될 method를 선언해야하지만, Nest는 method의 이름은 신경쓰지 않는다.\n이 method는 200이라는 status code와 string을 response로 반환할 것이다. 이것에 대해 설명하려면, response를 다루기 위해 Nest에서 제공하는 2가지 옵션에 대해 알아야 한다.\n         Standard(recommended) request handler가 Javascript object 또는 array를 반환할 때 자동으로 JSON 형태로 직렬화 된다. 그러나, Javascript 원시타입(string, number, boolean 등)을 반환할 때에는 직렬화 없이 값을 반환한다. 이것은 response handling을 간단하게 만들어 준다.또한, response의 status code는 항상 기본값이 200이며, POST의 경우는 201을 사용한다. 이것은 @HttpCode() 데코레이터를 추가하여 간단하게 변경 가능하다.   Library-specific @Res() 데코레이터를 사용하여 library-specific response object(예를 들어, Express)를 사용할 수도 있다(예를 들어, findAll(@Res() response)). 이러한 접근법으로 native response handling method들을 사용 가능하다. 예를 들어, Express를 사용한다면 아래의 코드처럼 사용 가능하다.response.status(200).send()     Warningibrary-specific option을 사용하기 위해 @Res()와 @Next()를 모두 사용하면 Nest는 이를 감지하여 standard는 자동으로 disabled 된다. 두 접근법을 동시에 사용하기 위해서는 passthrough option을 true로 사용해야 한다. @Res({ passthrough: true })\n Request object Handler는 가끔 request 세부사항에 접근해야 하는 경우가 있다. Nest는 platform(default는 Express)에 종속된 request object를 제공한다. @Req() 데코레이터를 사용하여 request object를 injection하여 접근 가능하다.\n// cats.controller.ts  import { Controller, Get, Req } from '@nestjs/common'; import { Request } from 'express'; @Controller('cats') export class CatsController { @Get() findAll(@Req() request: Request): string { return 'This action returns all cats'; } }  위 예제처럼 request: Request 로 typing을 하기 위해서는 @types/express 패키지를 설치하면 된다.\n request object는 query string, parameter, HTTP header, body 등의 속성값을 가진 HTTP request이다. 대부분의 경우, 속성들을 수동으로 가져올 필요 없이 @Body(), @Query()와 같은 데코레이터를 사용하면 된다. 아래는 platform-specifit object의 데코레이터 목록이다.\n         @Request(), @Req() req   @Response(), @Res() res   @Next() next   @Session() req.session   @Param(key?: string) req.params / req.params[key]   @Body(key?: string) req.body / req.body[key]   @Query(key?: string) req.query / req.query[key]   @Headers(name?: string) req.headers / req.headers[name]   @Ip() req.ip   @HostParam() req.hosts    HTTP platform(Express와 Fastify) 기반의 typing을 위해 Nest는 @Res(), @Response() 데코레이터를 제공한다. 이 데코레이터는 native platform의 response 오브젝트를 노출한다. 이것을 사용할 때, 기반 라이브러리를 import 해주어야 한다(예를 들어, @types/express). @Res(), @Response() 데코레이터를 사용하면, Nest에게 핸들러에 대해 Library-specific mode로 설정하게 하고, response를 관리할 수 있게 된다. 이를 통해, res.json()이나 res.send() 같은 response object의 method를 사용할 수 있다.\nResources 앞서, cats resource(GET route)를 fetch하기 위한 엔드포인트를 정의했다. 일반적으로 새로운 레코드를 만드는 엔드포인트도 제공하고 싶을것이다. 이를 위해, POST 핸들러를 사용한다.\n// cats.controller.ts  import { Controller, Get, Post } from '@nestjs/common'; @Controller('cats') export class CatsController { @Post() create(): string { return 'This action adds a new cat'; } @Get() findAll(): string { return 'This action returns all cats'; } } Nest는 모든 standart HTTP method에 대한 데코레이터를 제공한다: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(). 또한 @All() 을 사용하면 모든 요청에 대한 엔드포인트를 정의한다.\nRoute wildcards wildcard로 별표(*)를 사용한 패턴도 제공한다.\n@Get('ab*cd') findAll() { return 'This route uses a wildcard'; } 'ab*cd' route path는 abcd, ab_cd, abecd등과 match된다. ?, +, *, () 같은 문자도 정규식의 부분으로 route path에 사용가능하다. '-', '.'은 string기반 path에 의해 문자 그대로 번역된다.\nStatus code 앞서 이야기했듯이, response status code는 기본값이 200이다(POST request의 경우 201). 이것은 @HttpCode() 데코레이터를 통해 핸들러 수준에서 쉽게 변경 가능하다.\n@Post() @HttpCode(204) create() { return 'This action adds a new cat'; } 종종 status code는 static하지 않고 여러가지 변수에 의존한다. 이런 경우, @Res() 데코레이터를 통해 library-specific response를 사용할 수 있다.\nHeaders custom response header를 특정하기 위해, @Header() 데코레이터 또는 library-specific response object에서 res.header()를 호출할 수 있다.\n@Post() @Header('Cache-Control', 'none') create() { return 'This action adds a new cat'; } Redirection response를 특정 URL로 redirection하기 위해, @Redirect() 데코레이터 또는 library-specific response object를 통해 res.redirect()를 호출할 수 있다. @Redirect()는 url과 statusCode를 인자로 받으며 둘 모두 optional이다. statusCode의 기본값은 302 이다.\n@Get() @Redirect('https://nestjs.com', 301) 가끔, status code나 redirect URL을 동적으로 결정해야 할 때가 있다. route handler method로부터 object를 아래와 같은 형태로 반환하면 된다.\n{ \"url\": string, \"statusCode\": number } 반환된 값은 @Redirect() 데코레이터의 인자를 override 할 것이다.\n@Get('docs') @Redirect('https://docs.nestjs.com', 302) getDocs(@Query('version') version) { if (version \u0026\u0026 version === '5') { return { url: 'https://docs.nestjs.com/v5/' }; } } Route parameters 정적 경로를 가진 route는 request의 일부로 dynamic data에 접근해야 할 경우에는 사용할 수 없다. parameter를 갖는 route를 정의하기 위해 route parameter token을 path에 추가하면 된다. 아래는 @Get() 데코레이터에 사용한 route parameter token에 대한 예제이다. 이렇게 선언된 route parameter는 @Param() 데코레이터를 통해 접근할 수 있다.\n@Get(':id') findOne(@Param() params): string { console.log(params.id); return `This action returns a #${params.id}cat`; } 위 예제에서 @Param()을 통해 id에 접근하려면 params.id로 접근할 수 있다. 또는 특정 parameter token을 데코레이터에서 접근 가능하다.\n@Get(':id') findOne(@Param('id') id: string): string { return `This action returns a #${id}cat`; } Sub-Domain Routing @Controller() 데코레이터는 host option을 받을 수 있다. HTTP host는 들어오는 request와 특정 값을 matching하기 위해 사용된다.\n@Controller({ host: 'admin.example.com' }) export class AdminController { @Get() index(): string { return 'Admin page'; } }  Fastify는 nested router에 대한 지원을 하지 않으므로, sub-domain routing을 사용할 떄에는, Express adpater를 사용해야 한다.(기본값으로 설정되어 있음)\n route path와 마찬가지로, host option의 host name의 token도 동적값으로 사용가능하다. 이 방식으로 선언된 host parameter는 @HostParam() 데코레이터를 통해 사용 할 수 있다.\n@Controller({ host: ':account.example.com' }) export class AccountController { @Get() getInfo(@HostParam('account') account: string) { return account; } } Scopes Nest에서는 들어오는 request를 통해 거의 모든것이 공유된다. database에 대한 connection pool, global state에서의 singleton service 등을 갖고 있다. Node.js는 request/response Multi-Threaded Stateless Model을 따르지 않고, 각각의 request에 대해 분리된 thread에서 진행된다. 따라서, singleton instance를 사용하는 것이 우리의 애플리케이션에 안전한 방식이다.\nAsynchronicity data extraction은 대부분 비동기로 일어난다. 따라서 Nest에서는 async fuction을 지원한다. 모든 비동기 함수는 Promise를 반환한다.\n// cats.controller.ts  @Get() async findAll(): Promiseany[] { return []; } 또한, Nest route handler는 RxJS observable stream을 반환할 수 있다. Nest는 자동으로 아래의 source를 subscribe하여 마지막으로 방출된 값을 가져올 수 있다.(stream이 끝날 때)\n@Get() findAll(): Observableany[] { return of([]); } 두 방식 모두 유효하며, 원하는 방식대로 사용하면 된다.\nRequest payloads @Body() 데코레이터를 사용하여 POST route handler에서도 클라이언트로부터 parameter를 받아올 수 있다. 그러나 먼저 DTO(Data Transfer Object) 스키마를 정의해야 한다. DTO는 네트워크를 통해 데이터를 어떤 형식으로 주고받을지 정의하는 오브젝트이다. DTO는 TypeScript interface 또는 class로 정의할 수 있다. 하지만 class를 추천하는데, class는 JS ES6 standard한 문법이며, 따라서 컴파일된 JS에서도 real entity로 보존된다. 반면, TypeScript interface는 transpilation 도중 제거되기 때문에 Nest는 그것을 런타임에 호출할 수 없다. 이것은 Pipe와 같은 feature가 런타임에 변수의 메타타입에 접근하는 경우 중요하다.\n// create-cat.dto.ts  export class CreateCatDto { name: string; age: number; breed: string; } // cat.controller.ts  @Post() async create(@Body() createCatDto: CreateCatDto) { return 'This action adds a new cat'; } Handling errors 따로 분리된 에러 핸들링 페이지에서 볼 수 있다.\nFull resource sample // cat.controller.ts  import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common'; import { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto'; @Controller('cats') export class CatsController { @Post() create(@Body() createCatDto: CreateCatDto) { return 'This action adds a new cat'; } @Get() findAll(@Query() query: ListAllEntities) { return `This action returns all cats (limit: ${query.limit}items)`; } @Get(':id') findOne(@Param('id') id: string) { return `This action returns a #${id}cat`; } @Put(':id') update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) { return `This action updates a #${id}cat`; } @Delete(':id') remove(@Param('id') id: string) { return `This action removes a #${id}cat`; } } Getting up and running 위처럼 풀소스코드가 정의되어 있어도, Nest는 CatsController가 존재하는지 알지 못하기 때문에, 해당 클래스의 인스턴스를 생성하지 못한다. Controller는 항상 module에 속해있어야 하며, @Module() 데코레이터를 통해 포함시킨다.\n// app.module.ts  import { Module } from '@nestjs/common'; import { CatsController } from './cats/cats.controller'; @Module({ controllers: [CatsController], }) export class AppModule {} module class에 @Module() 데코레이터를 통해 포함시키면, Nest는 해당 controller를 찾아 mount한다.\nLibrary-specific approach library-specific response object를 injection하기 위해 @Res() 또는 @Response() 데코레이터를 사용한다.\n// cat.controller.ts  import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common'; import { Response } from 'express'; @Controller('cats') export class CatsController { @Post() create(@Res() res: Response) { res.status(HttpStatus.CREATED).send(); } @Get() findAll(@Res() res: Response) { res.status(HttpStatus.OK).json([]); } } 이 방식을 통해, response object를 더 유연한 방식으로 컨트롤 할 수 있다. 일반적으로 이러한 접근 방식은 덜 clear하며, disadvantage를 가져올 수 있으므로 조심해서 다루어야 한다. 가장 주요한 disadvantage는 코드가 platform 의존적(기반 플랫폼들은 response object에 대해 서로 다른 API를 갖고 있다.)이 되며 테스트하기가 힘들어진다는 것이다. 또한, 위의 예제와 같이, Nest standard로 제공하는 response 핸들링 기능들을 사용할 수 없다(예를 들어, @HttpCode() / @Header() 데코레이터 등). 이것을 해결하기 위해 passthrough 옵션을 사용할 수 있다.\n@Get() findAll(@Res({ passthrough: true }) res: Response) { res.status(HttpStatus.OK); return []; } ",
  "wordCount" : "1519",
  "inLanguage": "en",
  "datePublished": "2021-05-01T20:48:45+09:00",
  "dateModified": "2021-05-01T20:48:45+09:00",
  "author":{
    "@type": "Person",
    "name": "icecat471"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://icecat471.github.io/devlog/post/nestjs/controllers/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "icecat471's Devlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://icecat471.github.io/devlog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://icecat471.github.io/devlog/" accesskey="h" title="icecat471&#39;s Devlog (Alt + H)">icecat471&#39;s Devlog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://icecat471.github.io/devlog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://icecat471.github.io/devlog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://icecat471.github.io/devlog/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://icecat471.github.io/devlog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://icecat471.github.io/devlog/">Home</a>&nbsp;»&nbsp;<a href="https://icecat471.github.io/devlog/post/">Posts</a></div>
    <h1 class="post-title">
      [NestJS] (공식문서 번역) Controllers
    </h1>
    <div class="post-meta">May 1, 2021&nbsp;·&nbsp;8 min&nbsp;·&nbsp;icecat471
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#controllers" aria-label="Controllers">Controllers</a><ul>
                        
                <li>
                    <a href="#controllers-1" aria-label="Controllers">Controllers</a></li>
                <li>
                    <a href="#routing" aria-label="Routing">Routing</a></li>
                <li>
                    <a href="#request-object" aria-label="Request object">Request object</a></li>
                <li>
                    <a href="#resources" aria-label="Resources">Resources</a></li>
                <li>
                    <a href="#route-wildcards" aria-label="Route wildcards">Route wildcards</a></li>
                <li>
                    <a href="#status-code" aria-label="Status code">Status code</a></li>
                <li>
                    <a href="#headers" aria-label="Headers">Headers</a></li>
                <li>
                    <a href="#redirection" aria-label="Redirection">Redirection</a></li>
                <li>
                    <a href="#route-parameters" aria-label="Route parameters">Route parameters</a></li>
                <li>
                    <a href="#sub-domain-routing" aria-label="Sub-Domain Routing">Sub-Domain Routing</a></li>
                <li>
                    <a href="#scopes" aria-label="Scopes">Scopes</a></li>
                <li>
                    <a href="#asynchronicity" aria-label="Asynchronicity">Asynchronicity</a></li>
                <li>
                    <a href="#request-payloads" aria-label="Request payloads">Request payloads</a></li>
                <li>
                    <a href="#handling-errors" aria-label="Handling errors">Handling errors</a></li>
                <li>
                    <a href="#full-resource-sample" aria-label="Full resource sample">Full resource sample</a></li>
                <li>
                    <a href="#getting-up-and-running" aria-label="Getting up and running">Getting up and running</a></li>
                <li>
                    <a href="#library-specific-approach" aria-label="Library-specific approach">Library-specific approach</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>NestJS 공식문서 번역 겸 공부하는 글 입니다.<br>
의역 및 오역이 있을 수 있습니다.<br>
<a href="https://docs.nestjs.com/controllers">https://docs.nestjs.com/controllers</a></p>
<h1 id="controllers">Controllers<a hidden class="anchor" aria-hidden="true" href="#controllers">#</a></h1>
<h2 id="controllers-1">Controllers<a hidden class="anchor" aria-hidden="true" href="#controllers-1">#</a></h2>
<p>Controller는 들어오는 request를 핸들링하고 클라이언트에게 response를 반환하는 역할.</p>
<p><img loading="lazy" src="../../../img/nestjs/controllers01.png" alt="Controllers"  />
</p>
<p>routing mechanism은 어떤 controller가 어떤 request를 받을지 컨트롤한다.<!-- raw HTML omitted -->
각각의 controller는 보통 하나 이상의 route를 갖고, 서로 다른 route는 각각 다른 일을 수행힌다.<!-- raw HTML omitted --></p>
<h2 id="routing">Routing<a hidden class="anchor" aria-hidden="true" href="#routing">#</a></h2>
<p>아래 예제에서는 basic controller를 정의하는데 필요한 @Controller() 데코레이터를 사용한다.
@Controller() 데코레이터는 관련된 route들을 쉽게 그룹화 할 수 있게 해주며, 코드의 반복을 줄여준다. 예를 들어, customer entity와 상호작용하는 route의 그룹이 있다면, /customers 라는 route로 묶을 수 있다. 이 경우, @Controller(&lsquo;customers&rsquo;) 데코레이터를 사용하여 쉽게 그룹화 가능하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Controller</span><span class="p">,</span> <span class="nx">Get</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{</span>
  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">findAll</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;This action returns all cats&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>@Get() HTTP request method 데코레이터는 Nest에게 HTTP request의 특정 엔드포인트에 대한 핸들러를 만들도록 한다. 엔드포인트는 HTTP request method(위 예제에서는 GET), route path에 일치하는 경로로 라우팅 된다. route path란, controller에 선언된 prefix와 request decorator에 의해 특정된 path의 결합이다.<br>
예제에서 모든 route에 대한 prefix(cats)를 선언하였고, decorator에는 path 정보를 추가하지 않았으므로, Nest는 GET /cats에 대한 request를 해당 핸들러에 매핑할 것이다.<br>
만약, path prefix가 customers 이고, decorator가 @Get(&lsquo;profile&rsquo;)인 경우는 GET /customers/profile 경로로 매핑될 것이다.</p>
<!-- raw HTML omitted -->
<p>위의 예제에서, 해당 엔드포인트에서 GET request가 만들어지면, Nest는 request를 findAll() method에 라우팅 할 것이다. method명은 임의로 지어진 것이다. 우리는 route에 bind될 method를 선언해야하지만, Nest는 method의 이름은 신경쓰지 않는다.</p>
<!-- raw HTML omitted -->
<p>이 method는 200이라는 status code와 string을 response로 반환할 것이다. 이것에 대해 설명하려면, response를 다루기 위해 Nest에서 제공하는 2가지 옵션에 대해 알아야 한다.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Standard<!-- raw HTML omitted --> (recommended)</td>
<td>request handler가 Javascript object 또는 array를 반환할 때 자동으로 JSON 형태로 직렬화 된다. 그러나, Javascript 원시타입(string, number, boolean 등)을 반환할 때에는 직렬화 없이 값을 반환한다. 이것은 response handling을 간단하게 만들어 준다.<!-- raw HTML omitted --><!-- raw HTML omitted --> 또한, response의 status code는 항상 기본값이 200이며, POST의 경우는 201을 사용한다. 이것은 @HttpCode() 데코레이터를 추가하여 간단하게 변경 가능하다.</td>
</tr>
<tr>
<td>Library-specific</td>
<td>@Res() 데코레이터를 사용하여 library-specific response object(예를 들어, Express)를 사용할 수도 있다(예를 들어, <code>findAll(@Res() response)</code>). 이러한 접근법으로 native response handling method들을 사용 가능하다. 예를 들어, Express를 사용한다면 아래의 코드처럼 사용 가능하다.<!-- raw HTML omitted --><code>response.status(200).send()</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>Warning</code><!-- raw HTML omitted -->
ibrary-specific option을 사용하기 위해 @Res()와 @Next()를 모두 사용하면 Nest는 이를 감지하여 standard는 자동으로 disabled 된다. 두 접근법을 동시에 사용하기 위해서는 passthrough option을 true로 사용해야 한다. <code>@Res({ passthrough: true })</code></p>
</blockquote>
<h2 id="request-object">Request object<a hidden class="anchor" aria-hidden="true" href="#request-object">#</a></h2>
<p>Handler는 가끔 request 세부사항에 접근해야 하는 경우가 있다. Nest는 platform(default는 Express)에 종속된 request object를 제공한다. @Req() 데코레이터를 사용하여 request object를 injection하여 접근 가능하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Controller</span><span class="p">,</span> <span class="nx">Get</span><span class="p">,</span> <span class="nx">Req</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Request</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;express&#39;</span><span class="p">;</span>

<span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{</span>
  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">findAll</span><span class="p">(</span><span class="kd">@Req</span><span class="p">()</span> <span class="nx">request</span>: <span class="kt">Request</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;This action returns all cats&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>위 예제처럼 request: Request 로 typing을 하기 위해서는 @types/express 패키지를 설치하면 된다.</p>
</blockquote>
<p>request object는 query string, parameter, HTTP header, body 등의 속성값을 가진 HTTP request이다. 대부분의 경우, 속성들을 수동으로 가져올 필요 없이 @Body(), @Query()와 같은 데코레이터를 사용하면 된다. 아래는 platform-specifit object의 데코레이터 목록이다.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>@Request(), @Req()</td>
<td>req</td>
</tr>
<tr>
<td>@Response(), @Res()</td>
<td>res</td>
</tr>
<tr>
<td>@Next()</td>
<td>next</td>
</tr>
<tr>
<td>@Session()</td>
<td>req.session</td>
</tr>
<tr>
<td>@Param(key?: string)</td>
<td>req.params / req.params[key]</td>
</tr>
<tr>
<td>@Body(key?: string)</td>
<td>req.body / req.body[key]</td>
</tr>
<tr>
<td>@Query(key?: string)</td>
<td>req.query / req.query[key]</td>
</tr>
<tr>
<td>@Headers(name?: string)</td>
<td>req.headers / req.headers[name]</td>
</tr>
<tr>
<td>@Ip()</td>
<td>req.ip</td>
</tr>
<tr>
<td>@HostParam()</td>
<td>req.hosts</td>
</tr>
</tbody>
</table>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>HTTP platform(Express와 Fastify) 기반의 typing을 위해 Nest는 @Res(), @Response() 데코레이터를 제공한다. 이 데코레이터는 native platform의 response 오브젝트를 노출한다. 이것을 사용할 때, 기반 라이브러리를 import 해주어야 한다(예를 들어, @types/express). @Res(), @Response() 데코레이터를 사용하면, Nest에게 핸들러에 대해 Library-specific mode로 설정하게 하고, response를 관리할 수 있게 된다. 이를 통해, res.json()이나 res.send() 같은 response object의 method를 사용할 수 있다.</p>
<h2 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h2>
<p>앞서, cats resource(GET route)를 fetch하기 위한 엔드포인트를 정의했다. 일반적으로 새로운 레코드를 만드는 엔드포인트도 제공하고 싶을것이다. 이를 위해, POST 핸들러를 사용한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Controller</span><span class="p">,</span> <span class="nx">Get</span><span class="p">,</span> <span class="nx">Post</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{</span>
  <span class="kd">@Post</span><span class="p">()</span>
  <span class="nx">create</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;This action adds a new cat&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">findAll</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;This action returns all cats&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Nest는 모든 standart HTTP method에 대한 데코레이터를 제공한다: <!-- raw HTML omitted -->
@Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(). 또한 @All() 을 사용하면 모든 요청에 대한 엔드포인트를 정의한다.</p>
<h2 id="route-wildcards">Route wildcards<a hidden class="anchor" aria-hidden="true" href="#route-wildcards">#</a></h2>
<p>wildcard로 별표(*)를 사용한 패턴도 제공한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">(</span><span class="s1">&#39;ab*cd&#39;</span><span class="p">)</span>
<span class="nx">findAll() {</span>
  <span class="k">return</span> <span class="s1">&#39;This route uses a wildcard&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>'ab*cd'</code> route path는 <code>abcd</code>, <code>ab_cd</code>, <code>abecd</code>등과 match된다. <code>?</code>, <code>+</code>, <code>*</code>, <code>()</code> 같은 문자도 정규식의 부분으로 route path에 사용가능하다. <code>'-'</code>, <code>'.'</code>은 string기반 path에 의해 문자 그대로 번역된다.</p>
<h2 id="status-code">Status code<a hidden class="anchor" aria-hidden="true" href="#status-code">#</a></h2>
<p>앞서 이야기했듯이, response status code는 기본값이 200이다(POST request의 경우 201). 이것은 @HttpCode() 데코레이터를 통해 핸들러 수준에서 쉽게 변경 가능하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Post</span><span class="p">()</span>
<span class="kd">@HttpCode</span><span class="p">(</span><span class="mi">204</span><span class="p">)</span>
<span class="nx">create() {</span>
  <span class="k">return</span> <span class="s1">&#39;This action adds a new cat&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>종종 status code는 static하지 않고 여러가지 변수에 의존한다. 이런 경우, @Res() 데코레이터를 통해 library-specific response를 사용할 수 있다.</p>
<h2 id="headers">Headers<a hidden class="anchor" aria-hidden="true" href="#headers">#</a></h2>
<p>custom response header를 특정하기 위해, @Header() 데코레이터 또는 library-specific response object에서 res.header()를 호출할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Post</span><span class="p">()</span>
<span class="kd">@Header</span><span class="p">(</span><span class="s1">&#39;Cache-Control&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="nx">create() {</span>
  <span class="k">return</span> <span class="s1">&#39;This action adds a new cat&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="redirection">Redirection<a hidden class="anchor" aria-hidden="true" href="#redirection">#</a></h2>
<p>response를 특정 URL로 redirection하기 위해, @Redirect() 데코레이터 또는 library-specific response object를 통해 res.redirect()를 호출할 수 있다.
<!-- raw HTML omitted --><!-- raw HTML omitted -->
@Redirect()는 url과 statusCode를 인자로 받으며 둘 모두 optional이다. statusCode의 기본값은 302 이다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">()</span>
<span class="kd">@Redirect</span><span class="p">(</span><span class="s1">&#39;https://nestjs.com&#39;</span><span class="p">,</span> <span class="mi">301</span><span class="p">)</span>
</code></pre></div><p>가끔, status code나 redirect URL을 동적으로 결정해야 할 때가 있다. route handler method로부터 object를 아래와 같은 형태로 반환하면 된다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="p">{</span>
  <span class="s2">&#34;url&#34;</span><span class="o">:</span> <span class="kt">string</span><span class="p">,</span>
  <span class="s2">&#34;statusCode&#34;</span><span class="o">:</span> <span class="kt">number</span>
<span class="p">}</span>
</code></pre></div><p>반환된 값은 @Redirect() 데코레이터의 인자를 override 할 것이다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">(</span><span class="s1">&#39;docs&#39;</span><span class="p">)</span>
<span class="kd">@Redirect</span><span class="p">(</span><span class="s1">&#39;https://docs.nestjs.com&#39;</span><span class="p">,</span> <span class="mi">302</span><span class="p">)</span>
<span class="nx">getDocs</span><span class="p">(</span><span class="kd">@Query</span><span class="p">(</span><span class="s1">&#39;version&#39;</span><span class="p">)</span> <span class="nx">version</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">version</span> <span class="o">&amp;&amp;</span> <span class="nx">version</span> <span class="o">===</span> <span class="s1">&#39;5&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;https://docs.nestjs.com/v5/&#39;</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="route-parameters">Route parameters<a hidden class="anchor" aria-hidden="true" href="#route-parameters">#</a></h2>
<p>정적 경로를 가진 route는 request의 일부로 dynamic data에 접근해야 할 경우에는 사용할 수 없다. parameter를 갖는 route를 정의하기 위해 route parameter token을 path에 추가하면 된다. 아래는 @Get() 데코레이터에 사용한 route parameter token에 대한 예제이다. 이렇게 선언된 route parameter는 @Param() 데코레이터를 통해 접근할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">(</span><span class="s1">&#39;:id&#39;</span><span class="p">)</span>
<span class="nx">findOne</span><span class="p">(</span><span class="kd">@Param</span><span class="p">()</span> <span class="nx">params</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="k">return</span> <span class="sb">`This action returns a #</span><span class="si">${</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="si">}</span><span class="sb"> cat`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>위 예제에서 @Param()을 통해 id에 접근하려면 params.id로 접근할 수 있다. 또는 특정 parameter token을 데코레이터에서 접근 가능하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">(</span><span class="s1">&#39;:id&#39;</span><span class="p">)</span>
<span class="nx">findOne</span><span class="p">(</span><span class="kd">@Param</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="nx">id</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="sb">`This action returns a #</span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb"> cat`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="sub-domain-routing">Sub-Domain Routing<a hidden class="anchor" aria-hidden="true" href="#sub-domain-routing">#</a></h2>
<p>@Controller() 데코레이터는 host option을 받을 수 있다. HTTP host는 들어오는 request와 특정 값을 matching하기 위해 사용된다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Controller</span><span class="p">({</span> <span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;admin.example.com&#39;</span> <span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AdminController</span> <span class="p">{</span>
  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">index</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;Admin page&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>Fastify는 nested router에 대한 지원을 하지 않으므로, sub-domain routing을 사용할 떄에는, Express adpater를 사용해야 한다.(기본값으로 설정되어 있음)</p>
</blockquote>
<p>route path와 마찬가지로, host option의 host name의 token도 동적값으로 사용가능하다. 이 방식으로 선언된 host parameter는 @HostParam() 데코레이터를 통해 사용 할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Controller</span><span class="p">({</span> <span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;:account.example.com&#39;</span> <span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AccountController</span> <span class="p">{</span>
  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">getInfo</span><span class="p">(</span><span class="kd">@HostParam</span><span class="p">(</span><span class="s1">&#39;account&#39;</span><span class="p">)</span> <span class="nx">account</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">account</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="scopes">Scopes<a hidden class="anchor" aria-hidden="true" href="#scopes">#</a></h2>
<p>Nest에서는 들어오는 request를 통해 거의 모든것이 공유된다. database에 대한 connection pool, global state에서의 singleton service 등을 갖고 있다. Node.js는 request/response Multi-Threaded Stateless Model을 따르지 않고, 각각의 request에 대해 분리된 thread에서 진행된다. 따라서, singleton instance를 사용하는 것이 우리의 애플리케이션에 안전한 방식이다.</p>
<h2 id="asynchronicity">Asynchronicity<a hidden class="anchor" aria-hidden="true" href="#asynchronicity">#</a></h2>
<p>data extraction은 대부분 비동기로 일어난다. 따라서 Nest에서는 async fuction을 지원한다. 모든 비동기 함수는 Promise를 반환한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findAll</span><span class="p">()</span><span class="o">:</span> <span class="nx">Promise</span><span class="p">&lt;</span><span class="nt">any</span><span class="err">[]</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[];</span>
<span class="p">}</span>
</code></pre></div><p>또한, Nest route handler는 RxJS observable stream을 반환할 수 있다. Nest는 자동으로 아래의 source를 subscribe하여 마지막으로 방출된 값을 가져올 수 있다.(stream이 끝날 때)</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">()</span>
<span class="nx">findAll</span><span class="p">()</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">any</span><span class="err">[]</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">of</span><span class="p">([]);</span>
<span class="p">}</span>
</code></pre></div><p>두 방식 모두 유효하며, 원하는 방식대로 사용하면 된다.</p>
<h2 id="request-payloads">Request payloads<a hidden class="anchor" aria-hidden="true" href="#request-payloads">#</a></h2>
<p>@Body() 데코레이터를 사용하여 POST route handler에서도 클라이언트로부터 parameter를 받아올 수 있다. 그러나 먼저 DTO(Data Transfer Object) 스키마를 정의해야 한다. DTO는 네트워크를 통해 데이터를 어떤 형식으로 주고받을지 정의하는 오브젝트이다. DTO는 TypeScript interface 또는 class로 정의할 수 있다. 하지만 class를 추천하는데, class는 JS ES6 standard한 문법이며, 따라서 컴파일된 JS에서도 real entity로 보존된다. 반면, TypeScript interface는 transpilation 도중 제거되기 때문에 Nest는 그것을 런타임에 호출할 수 없다. 이것은 Pipe와 같은 feature가 런타임에 변수의 메타타입에 접근하는 경우 중요하다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// create-cat.dto.ts
</span><span class="c1"></span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CreateCatDto</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">age</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="nx">breed</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cat.controller.ts
</span><span class="c1"></span>
<span class="kd">@Post</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">create</span><span class="p">(</span><span class="kd">@Body</span><span class="p">()</span> <span class="nx">createCatDto</span>: <span class="kt">CreateCatDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">&#39;This action adds a new cat&#39;</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="handling-errors">Handling errors<a hidden class="anchor" aria-hidden="true" href="#handling-errors">#</a></h2>
<p>따로 분리된 <a href="https://docs.nestjs.com/exception-filters">에러 핸들링 페이지</a>에서 볼 수 있다.</p>
<h2 id="full-resource-sample">Full resource sample<a hidden class="anchor" aria-hidden="true" href="#full-resource-sample">#</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cat.controller.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Controller</span><span class="p">,</span> <span class="nx">Get</span><span class="p">,</span> <span class="nx">Query</span><span class="p">,</span> <span class="nx">Post</span><span class="p">,</span> <span class="nx">Body</span><span class="p">,</span> <span class="nx">Put</span><span class="p">,</span> <span class="nx">Param</span><span class="p">,</span> <span class="nx">Delete</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">CreateCatDto</span><span class="p">,</span> <span class="nx">UpdateCatDto</span><span class="p">,</span> <span class="nx">ListAllEntities</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./dto&#39;</span><span class="p">;</span>

<span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{</span>
  <span class="kd">@Post</span><span class="p">()</span>
  <span class="nx">create</span><span class="p">(</span><span class="kd">@Body</span><span class="p">()</span> <span class="nx">createCatDto</span>: <span class="kt">CreateCatDto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;This action adds a new cat&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">findAll</span><span class="p">(</span><span class="kd">@Query</span><span class="p">()</span> <span class="nx">query</span>: <span class="kt">ListAllEntities</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="sb">`This action returns all cats (limit: </span><span class="si">${</span><span class="nx">query</span><span class="p">.</span><span class="nx">limit</span><span class="si">}</span><span class="sb"> items)`</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">@Get</span><span class="p">(</span><span class="s1">&#39;:id&#39;</span><span class="p">)</span>
  <span class="nx">findOne</span><span class="p">(</span><span class="kd">@Param</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="nx">id</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="sb">`This action returns a #</span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb"> cat`</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">@Put</span><span class="p">(</span><span class="s1">&#39;:id&#39;</span><span class="p">)</span>
  <span class="nx">update</span><span class="p">(</span><span class="kd">@Param</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="nx">id</span>: <span class="kt">string</span><span class="p">,</span> <span class="kd">@Body</span><span class="p">()</span> <span class="nx">updateCatDto</span>: <span class="kt">UpdateCatDto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="sb">`This action updates a #</span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb"> cat`</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">@Delete</span><span class="p">(</span><span class="s1">&#39;:id&#39;</span><span class="p">)</span>
  <span class="nx">remove</span><span class="p">(</span><span class="kd">@Param</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="nx">id</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="sb">`This action removes a #</span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb"> cat`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="getting-up-and-running">Getting up and running<a hidden class="anchor" aria-hidden="true" href="#getting-up-and-running">#</a></h2>
<p>위처럼 풀소스코드가 정의되어 있어도, Nest는 CatsController가 존재하는지 알지 못하기 때문에, 해당 클래스의 인스턴스를 생성하지 못한다.
<!-- raw HTML omitted --><!-- raw HTML omitted -->
Controller는 항상 module에 속해있어야 하며, @Module() 데코레이터를 통해 포함시킨다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// app.module.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Module</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">CatsController</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./cats/cats.controller&#39;</span><span class="p">;</span>

<span class="kd">@Module</span><span class="p">({</span>
  <span class="nx">controllers</span><span class="o">:</span> <span class="p">[</span><span class="nx">CatsController</span><span class="p">],</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AppModule</span> <span class="p">{}</span>
</code></pre></div><p>module class에 @Module() 데코레이터를 통해 포함시키면, Nest는 해당 controller를 찾아 mount한다.</p>
<h2 id="library-specific-approach">Library-specific approach<a hidden class="anchor" aria-hidden="true" href="#library-specific-approach">#</a></h2>
<p>library-specific response object를 injection하기 위해 @Res() 또는 @Response() 데코레이터를 사용한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// cat.controller.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Controller</span><span class="p">,</span> <span class="nx">Get</span><span class="p">,</span> <span class="nx">Post</span><span class="p">,</span> <span class="nx">Res</span><span class="p">,</span> <span class="nx">HttpStatus</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Response</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;express&#39;</span><span class="p">;</span>

<span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{</span>
  <span class="kd">@Post</span><span class="p">()</span>
  <span class="nx">create</span><span class="p">(</span><span class="kd">@Res</span><span class="p">()</span> <span class="nx">res</span>: <span class="kt">Response</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">CREATED</span><span class="p">).</span><span class="nx">send</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kd">@Get</span><span class="p">()</span>
  <span class="nx">findAll</span><span class="p">(</span><span class="kd">@Res</span><span class="p">()</span> <span class="nx">res</span>: <span class="kt">Response</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">OK</span><span class="p">).</span><span class="nx">json</span><span class="p">([]);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>이 방식을 통해, response object를 더 유연한 방식으로 컨트롤 할 수 있다. 일반적으로 이러한 접근 방식은 덜 clear하며, disadvantage를 가져올 수 있으므로 조심해서 다루어야 한다. 가장 주요한 disadvantage는 코드가 platform 의존적(기반 플랫폼들은 response object에 대해 서로 다른 API를 갖고 있다.)이 되며 테스트하기가 힘들어진다는 것이다.
<!-- raw HTML omitted --><!-- raw HTML omitted -->
또한, 위의 예제와 같이, Nest standard로 제공하는 response 핸들링 기능들을 사용할 수 없다(예를 들어, @HttpCode() / @Header() 데코레이터 등). 이것을 해결하기 위해 passthrough 옵션을 사용할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-ts" data-lang="ts"><span class="kd">@Get</span><span class="p">()</span>
<span class="nx">findAll</span><span class="p">(</span><span class="kd">@Res</span><span class="p">({</span> <span class="nx">passthrough</span>: <span class="kt">true</span> <span class="p">})</span> <span class="nx">res</span>: <span class="kt">Response</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">OK</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[];</span>
<span class="p">}</span>
</code></pre></div>
</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://icecat471.github.io/devlog/tags/nestjs/">NestJS</a></li>
      <li><a href="https://icecat471.github.io/devlog/tags/backend/">backend</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://icecat471.github.io/devlog/post/docker/install_postgres/">
    <span class="title">« Prev Page</span>
    <br>
    <span>[Docker] PostgresSQL 설치</span>
  </a>
  <a class="next" href="https://icecat471.github.io/devlog/post/spring/install_apache_tomcat/">
    <span class="title">Next Page »</span>
    <br>
    <span>맥북 Tomcat9 설치</span>
  </a>
</nav>

  </footer><script src="https://utteranc.es/client.js"
        repo="icecat471/devlog"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://icecat471.github.io/devlog/">icecat471&#39;s Devlog</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        container.appendChild(copybutton);
    });
</script>
</body>

</html>
